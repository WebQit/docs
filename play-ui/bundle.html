
	<div exportgroup="readme">

		<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/playui-js" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/playui-js.svg" alt="NPM version" /></a></span> <span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/playui-js" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/playui-js.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<h2 id="why-play-ui">Why Play UI</h2>
<p>Play UI is a family of tools that brings a utility-based approach and wholistic experience to UI development. This gives you full UI authoring capabilities in the liberty and combinational power of standalone utilities!</p>
<h2 id="getting-started">Getting Started</h2>
<p>Take the playbook! <a href="/tooling/play-ui/docs">Visit the docs</a> for an overview, the API and usage guides.</p>
<p><html-import data-id="quickstart" template="@layout/quickstart"></html-import></p>
<p>Also, <a href="https://github.com/webqit/play-ui/discussions">join the Github Discussions</a> for Play UI.</p>
<h2 id="contributing-to-the-project">Contributing to the Project</h2>
<p>Help report bugs, or request features; or join in the development.</p>
<ul>
<li><a href="https://github.com/webqit/play-ui">Visit this project on github</a>.</li>
<li><a href="https://github.com/webqit/webqit-tooling.docs/edit/master/play-ui/docs">Contribute to the docs on github</a>.</li>
</ul>
<h2 id="license">License</h2>
<p>The MIT license.</p>

	</div>

	

	<template name="docs">
		<div exportgroup="readme">

			<h1 id="play-ui-documentation">Play UI Documentation</h1>
<p>Welcome to the Play UI documentation. We hope you find it easy to understand and navigate. </p>
<p>If you have questions about anything related to the Play UI, you're always welcome to ask on our <a href="https://github.com/webqit/play-ui/discussions">GitHub Discussions</a>.</p>
<h2 id="explore-the-docs">Explore the Docs</h2>

		</div>

		<template name="api">
			<div exportgroup="readme">

				<h1 id="api-reference">API Reference</h1>
<p>Explore the API Reference.</p>

			</div>

			<template name="css">
				<div exportgroup="readme">

					<h1 id="api-category-css">API Category: CSS</h1>

				</div>

				<template name="classes">
					<div exportgroup="readme">

						<h1 id="classes">Classes</h1>
<p>Classes in this category.</p>

					</div>

					<template name="TransformRule">
						<div exportgroup="readme">

							<h1 id="class-transformrule-"><code>class TransformRule {}</code></h1>
<p>This class is an object model of the CSS transform rule.</p>
<h2 id="constructor-NaN">Constructor</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = <span class="hljs-keyword">new</span> TransformRule(transformRuleDefinition);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>transformRuleDefinition</code></strong>: <strong><code>Object|String</code></strong> - An object of the transform rule properties or the string <code>none</code>.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Create a transfrom rule instance from an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = <span class="hljs-keyword">new</span> TransformRule({
    <span class="hljs-attr">translate</span>: [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>],
    <span class="hljs-attr">sclae</span>: <span class="hljs-number">3</span>,
});

<span class="hljs-comment">// Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// translate(30, 40) scale(3)</span></code></pre>
<p>Create a transfrom rule instance from the string <code>none</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = <span class="hljs-keyword">new</span> TransformRule(<span class="hljs-string">&#x27;none&#x27;</span>);

<span class="hljs-comment">// Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// none</span></code></pre>
<h2 id="static-parse">static <code>parse()</code></h2>
<p>This function is used to parse an element's transform rule into an instance of <code>TransformRule</code>. If the input is a computed transform matrix, it automatically calls the <code>TransformRule.parseMatrix()</code> method.</p>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parse(rule);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>rule</code></strong> - <code>String</code>: A CSS transform rule.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>TransformRule</code></strong> - An object model of the parsed transform rule.</li>
</ul>
<h2 id="usage-1">Usage</h2>
<p>Parse <em>transform rule</em> declaration.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Parse</span>
<span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parse(<span class="hljs-string">&#x27;translate(30, 40) scale(3)&#x27;</span>);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject);
<span class="hljs-comment">/**
{
    translate: [30, 40],
    sclae: 3,
}
*/</span>

<span class="hljs-comment">//Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// translate(30, 40) scale(3)</span></code></pre>
<h2 id="static-parsematrix">static <code>parseMatrix()</code></h2>
<p>This function is used to parse an element's computed transform rule matrix into an instance of <code>TransformRule</code>.</p>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parseMatrix(matrix);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>matrix</code></strong> - <code>String</code>: The computed CSS transform matrix.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>TransformRule</code></strong> - An object model of the parsed transform rule.</li>
</ul>
<h2 id="usage-2">Usage</h2>
<p>Parse an element's <em>computed</em> transform rule.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">3</span>);
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRule = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>).style.transform;

<span class="hljs-comment">// Set attribute</span>
<span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parse(transformRule);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject);
<span class="hljs-comment">/**
{
    translate: [30, 40],
    sclae: 3,
}
*/</span>

<span class="hljs-comment">//Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// translate(30, 40) scale(3)</span></code></pre>

						</div>
					</template>
				</template>

				<template name="css">
					<div exportgroup="readme">

						<h1 id="css"><code>.css()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/css/cssSync"><code>.cssSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/css/cssSync"><code>.cssSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.css()</code> instance method is internally based on the standalone <code>css/cssSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">cssSync</span>: css } = $.css;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { cssSync <span class="hljs-keyword">as</span> css } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/css/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="cssAsync">
					<div exportgroup="readme">

						<h1 id="cssasync"><code>.cssAsync()</code></h1>
<p>This method is used to asynchronously set or get one or more style properties for the given element. It is a convenient alternative to the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/css/cssSync"><code>.cssSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<ul>
<li><a href="#a-set-css-properties">Set CSS Properties</a></li>
<li><a href="#b-get-css-properties">Get CSS Properties</a></li>
</ul>
<h2 id="a-set-css-properties">a. Set CSS Properties</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single property</span>
<span class="hljs-keyword">await</span> $(el).cssAsync(prop, value, params = {});

<span class="hljs-comment">// Set multiple properties</span>
<span class="hljs-keyword">await</span> $(el).cssAsync({
    [prop]: value,
}, params = {});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>prop</code></strong>: <strong><code>String</code></strong> - A CSS property.</li>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The property value to set. When an empty string <code>''</code>, the property is unset from the element.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional directives for the method. (This parameter only applies in the second syntax above, where the first parameter is an array.) Valid directives are:<ul>
<li><strong><code>scope</code></strong> - Set to <code>global</code> to write the new rules to a stylesheet. Or set to <code>inline</code> to write to the element's <code>style</code> attribute. By default, the element's <em>computed CSS</em> object is what is updated. But the browser also automatically writes the rules to the element's <code>style</code> attribute. The <code>scope:inline</code> directive thus has no special effect.</li>
<li><strong><code>prepend</code></strong> - Set to <code>true</code> to write the new rules behind existing rules instead, making existing rules take priority. With the <code>scope:global</code> directive, the given rules are inserted at the start of the target stylesheet. With the <code>scope:inline</code> directive, the given rules are prepended to the element's <code>style</code> attribute.</li>
<li><strong><code>pseudo</code></strong> - (Works with the <code>scope:global</code> directive. Forbidden otherwise.) Set to a pseudo selector (e.g <code>::before</code>) to set the CSS of a pseudo element associated with the matched element instead.</li>
<li><strong><code>autoUuid</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>false</code> to prevent Play UI from automatically generating a special attribute <code>playuo-uuid</code> for the element. By default, this is what is used as the CSS selector for the rules written to stylesheet.</li>
<li><strong><code>autoId</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to automatically generate an ID for the element where not present. This is used as the CSS selector for the rules written to stylesheet. This also prevents Play UI from automatically generating the special <code>playuo-uuid</code> attribute as above. Note that <code>autoUuid</code> and <code>autoId</code> cannot be both <code>false</code>.</li>
<li><strong><code>noScratchPad</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to target the latest <em>editable</em> stylesheet for the operation. Otherwise, a stylesheet maintained by Play UI is used.</li>
<li><strong><code>vendorize</code></strong> - Set to <code>true</code> to automatically handle applicable vendor-specific rule prefixing.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Change an element's CSS, then change the CSS of its <em>:after</em> pseudo element.</p>
<pre><code class="hljs js language-js">$(el).cssAsync(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>).then($el =&gt; {
    $el.cssAsync({
        <span class="hljs-attr">display</span>: <span class="hljs-string">&#x27;block&#x27;</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&quot;[NEW]&quot;&#x27;</span>,
    }, {<span class="hljs-attr">pseudo</span>: <span class="hljs-string">&#x27;:after&#x27;</span>});
});</code></pre>
<h2 id="b-get-css-properties">b. Get CSS Properties</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get a single property</span>
<span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> $(el).cssAsync(prop);

<span class="hljs-comment">// Get multiple properties</span>
<span class="hljs-keyword">let</span> values = <span class="hljs-keyword">await</span> $(el).cssAsync([...prop], params = {});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>prop</code></strong>: <strong><code>String</code></strong> - A CSS property.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional directives for the method. Valid directives are:<ul>
<li><strong><code>scope</code></strong> - Set to <code>global</code> to read the global, stylesheet-based CSS for the matched element. Or set to <code>inline</code> to read the element's <code>style</code> attribute instead. By default, the element's <em>computed CSS</em> object is what is read.</li>
<li><strong><code>pseudo</code></strong> - (Forbidden with the <code>scope:inline</code> directive.) Set to a pseudo selector (e.g <code>::before</code>) to get the CSS of a pseudo element associated with the matched element instead.</li>
<li><strong><code>all</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to return an array of rule blocks gathered for the matched element from across stylesheets. Otherwise, rule blocks are merged into a single object and returned.</li>
<li><strong><code>noCache</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to bypass Play UI's internal cache that optimizes traversing the document's stylesheets.</li>
<li><strong><code>vendorize</code></strong> - Set to <code>true</code> to automatically handle applicable vendor-specific rule prefixing.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The value of the named CSS property.</li>
<li><strong><code>values</code></strong>: <strong><code>Object</code></strong> - A key/value hash of the listed CSS properties.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's computed CSS. Note that if we must provide a <code>params</code> object, <em>props list</em> has to be an array.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> $(el).cssAsync([<span class="hljs-string">&#x27;color&#x27;</span>], {<span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;inline&#x27;</span>});
<span class="hljs-comment">// {color: &#x27;red&#x27;}</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.cssAsync()</code> instance method is internally based on the standalone <code>css/cssAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { cssAsync } = $.css;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { cssAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/css/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="cssSync">
					<div exportgroup="readme">

						<h1 id="csssync"><code>.cssSync()</code></h1>
<p>This method is used to set or get one or more style properties for the given element. It is a convenient alternative to the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/css/cssAsync"><code>.cssAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<ul>
<li><a href="#a-set-css-properties">Set CSS Properties</a></li>
<li><a href="#b-get-css-properties">Get CSS Properties</a></li>
</ul>
<h2 id="a-set-css-properties">a. Set CSS Properties</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single property</span>
$(el).cssSync(prop, value, params = {});

<span class="hljs-comment">// Set multiple properties</span>
$(el).cssSync({
    [prop]: value,
}, params = {});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>prop</code></strong>: <strong><code>String</code></strong> - A CSS property.</li>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The property value to set. When an empty string <code>''</code>, the property is unset from the element's inline CSS.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional directives for the method. Valid directives are:<ul>
<li><strong><code>scope</code></strong> - Set to <code>global</code> to write the new rules to a stylesheet. Or set to <code>inline</code> to write to the element's <code>style</code> attribute. By default, the element's <em>computed CSS</em> object is what is updated. But the browser also automatically writes the rules to the element's <code>style</code> attribute. The <code>scope:inline</code> directive thus has no special effect.</li>
<li><strong><code>prepend</code></strong> - Set to <code>true</code> to write the new rules behind existing rules instead, making existing rules take priority. With the <code>scope:global</code> directive, the given rules are inserted at the start of the target stylesheet. With the <code>scope:inline</code> directive, the given rules are prepended to the element's <code>style</code> attribute.</li>
<li><strong><code>pseudo</code></strong> - (Works with the <code>scope:global</code> directive. Forbidden otherwise.) Set to a pseudo selector (e.g <code>::before</code>) to set the CSS of a pseudo element associated with the matched element instead.</li>
<li><strong><code>autoUuid</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>false</code> to prevent Play UI from automatically generating a special attribute <code>playuo-uuid</code> for the element. By default, this is what is used as the CSS selector for the rules written to stylesheet.</li>
<li><strong><code>autoId</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to automatically generate an ID for the element where not present. This is used as the CSS selector for the rules written to stylesheet. This also prevents Play UI from automatically generating the special <code>playuo-uuid</code> attribute as above. Note that <code>autoUuid</code> and <code>autoId</code> cannot be both <code>false</code>.</li>
<li><strong><code>noScratchPad</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to target the latest <em>editable</em> stylesheet for the operation. Otherwise, a stylesheet maintained by Play UI is used.</li>
<li><strong><code>vendorize</code></strong> - Set to <code>true</code> to automatically handle applicable vendor-specific rule prefixing.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Change an element's CSS, then change the CSS of its <em>:after</em> pseudo element.</p>
<pre><code class="hljs js language-js">$(el).cssSync(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>);
$(el).cssSync({
    <span class="hljs-attr">display</span>: <span class="hljs-string">&#x27;block&#x27;</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&quot;[NEW]&quot;&#x27;</span>,
}, {<span class="hljs-attr">pseudo</span>: <span class="hljs-string">&#x27;:after&#x27;</span>});</code></pre>
<h2 id="b-get-css-properties">b. Get CSS Properties</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get a single property</span>
<span class="hljs-keyword">let</span> value = $(el).cssSync(prop);

<span class="hljs-comment">// Get multiple properties</span>
<span class="hljs-keyword">let</span> values = $(el).cssSync([...prop], params = {});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>prop</code></strong>: <strong><code>String</code></strong> - A CSS property.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional directives for the method. (This parameter only applies in the second syntax above, where the first parameter is an array.) Valid directives are:<ul>
<li><strong><code>scope</code></strong> - Set to <code>global</code> to read the global, stylesheet-based CSS for the matched element. Or set to <code>inline</code> to read the element's <code>style</code> attribute instead. By default, the element's <em>computed CSS</em> object is what is read.</li>
<li><strong><code>pseudo</code></strong> - (Forbidden with the <code>scope:inline</code> directive.) Set to a pseudo selector (e.g <code>::before</code>) to get the CSS of a pseudo element associated with the matched element instead.</li>
<li><strong><code>all</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to return an array of rule blocks gathered for the matched element from across stylesheets. Otherwise, rule blocks are merged into a single object and returned.</li>
<li><strong><code>noCache</code></strong> - (Works with the <code>scope:global</code> directive.) Set to <code>true</code> to bypass Play UI's internal cache that optimizes traversing the document's stylesheets.</li>
<li><strong><code>vendorize</code></strong> - Set to <code>true</code> to automatically handle applicable vendor-specific rule prefixing.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The value of the named CSS property.</li>
<li><strong><code>values</code></strong>: <strong><code>Object</code></strong> - A key/value hash of the listed CSS properties.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's computed CSS. Note that if we must provide a <code>params</code> object, <em>props list</em> has to be an array.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> result = $(el).cssSync([<span class="hljs-string">&#x27;color&#x27;</span>], {<span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;inline&#x27;</span>});
<span class="hljs-comment">// {color: &#x27;red&#x27;}</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.cssSync()</code> instance method is internally based on the standalone <code>css/cssSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { cssSync } = $.css;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { cssSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/css/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="cssTransaction">
					<div exportgroup="readme">

						<h1 id="csstransaction"><code>.cssTransaction()</code></h1>
<p>This method is used to start a transaction on an element for CSS operations that eventually might need to be rolled back. It is a convenient way to use the Play UI's <a href="/tooling/play-ui/docs/api/css/classes/transaction">Transaction</a> class.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transaction = $(el).cssTransaction(props, asyncWrites = <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>props</code></strong>: <strong><code>String|Array</code></strong> - A property or list of properties that describes the operation on the element.</li>
<li><strong><code>asyncWrites</code></strong>: <strong><code>Boolean</code></strong> - Specifies whether to use the asynchronous mode for writes by using <a href="/tooling/play-ui/docs/api/css/cssAsync"><code>cssAsync</code></a> instead of <a href="/tooling/play-ui/docs/api/css/cssSync"><code>cssSync</code></a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Transaction</code></strong> - The <a href="/tooling/play-ui/docs/api/css/classes/transaction">Transaction</a> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Below, we modify an element's CSS properties and later roll back the element to its initial state.</p>
<p><em>Define the element's stylesheet- and inline-based CSS:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background-color</span>: yellow;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Start a transaction:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtaine a Transaction instance. We&#x27;re using the asyncWrites mode</span>
<span class="hljs-keyword">let</span> transaction = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssTransaction([<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>], <span class="hljs-literal">true</span>);</code></pre>
<p><em>Do some modifications and create savepoints along the way:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Create a savepoint for the initial state of the element - savepoint1</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();

<span class="hljs-comment">// Alter the element&#x27;s computed style</span>
$(el).cssSync({
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;green&#x27;</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;black&#x27;</span>,
});
<span class="hljs-comment">// Create a savepoint - savepoint2</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();

<span class="hljs-comment">// Alter the element&#x27;s computed style further.</span>
<span class="hljs-comment">// Here we use the transaction&#x27;s .apply method to keep things neat.</span>
<span class="hljs-comment">// Calls cssSync() (or cssAsync where asyncWrites is true) under the hood. </span>
transaction.apply({
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;brown&#x27;</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;teal&#x27;</span>,
});
<span class="hljs-comment">// Create a savepoint - savepoint3</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();</code></pre>
<p><em>Rollback to a savepoint</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Rollback to anypoint after some time</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transaction.rollback(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// Now background-color should fallback to yellow</span>
    <span class="hljs-comment">// And color should be back to red</span>
}, <span class="hljs-number">2000</span>);</code></pre>
<p>In the code above, if another part of the app had changed one of those properties after the last <em>savepoint</em> we made, then the call to <code>rollback()</code> would have overridden those <em>foreign changes</em> to restore the element to the specified <em>savepoint</em>.</p>
<p>To automatically detect <em>foreign changes</em> and leave them untouched, we would set the <code>preserveCurrentState</code> parameter of the <a href="/tooling/play-ui/docs/api/css/classes/transaction/rollback"><code>rollback()</code></a> method to <code>true</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The following changes were made after our last savepoint</span>
el.style.color = <span class="hljs-string">&#x27;brown&#x27;</span>;

<span class="hljs-comment">// Rollback to savepoint2</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transaction.rollback(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">// Color will be left at &#x27;brown&#x27;</span>
}, <span class="hljs-number">2000</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.cssTransaction()</code> instance method is internally based on the standalone <code>css/cssTransaction()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { cssTransaction } = $.css;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { cssTransaction } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/css/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>
			</template>

			<template name="dom">
				<div exportgroup="readme">

					<h1 id="api-category-dom">API Category: DOM</h1>

				</div>

				<template name="append">
					<div exportgroup="readme">

						<h1 id="append"><code>.append()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/appendSync"><code>.appendSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/appendSync"><code>.appendSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.append()</code> instance method is internally based on the standalone <code>dom/appendSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">appendSync</span>: append } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { appendSync <span class="hljs-keyword">as</span> append } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="appendAsync">
					<div exportgroup="readme">

						<h1 id="appendasync"><code>.appendAsync()</code></h1>
<p>This method is used to asynchronously append content to an element. It works exactly the same as the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append"><code>ParentNode.append()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/appendSync"><code>.appendSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Append content(s) to an element</span>
<span class="hljs-keyword">await</span> $(el).appendAsync(content[, ...content]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to append.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Append an element node and some text content to an element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
$(el).appendAsync(div, <span class="hljs-string">&#x27;Playful&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;people&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.appendAsync()</code> instance method is internally based on the standalone <code>dom/appendAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { appendAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { appendAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="appendSync">
					<div exportgroup="readme">

						<h1 id="appendsync"><code>.appendSync()</code></h1>
<p>This method is used to append content to an element. It works exactly the same as the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append"><code>ParentNode.append()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/appendAsync"><code>.appendAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Append content(s) to an element</span>
$(el).appendSync(content[, ...content]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to append.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Append an element node and some text content to an element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
$(el).appendSync(div, <span class="hljs-string">&#x27;Playful&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;people&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.appendSync()</code> instance method is internally based on the standalone <code>dom/appendSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { appendSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { appendSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="appendToSync">
					<div exportgroup="readme">

						<h1 id="appendtosync"><code>.appendToSync()</code></h1>
<p>This method is used to append matched elements to target elements.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/appendToAsync"><code>.appendToAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">$(el).appendToSync(target);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>target</code></strong>: <strong><code>String|Element</code></strong> - A CSS selector of the element, or the element itself <code>Element</code>, to append to.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Append some dynamically-created nodes to document body.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-string">&#x27;&lt;h1&gt;Playful people!&lt;/h1&gt;&#x27;</span>).appendToSync(<span class="hljs-built_in">document</span>.body);</code></pre>
<p>Append an existing <code>div</code> to multiple targets. The <code>div</code> is cloned into all targets except the last target.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
$(div).appendToSync(<span class="hljs-string">&#x27;.multiple&#x27;</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.appendToSync()</code> instance method is internally based on the standalone <code>dom/appendToSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { appendToSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { appendToSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="attr">
					<div exportgroup="readme">

						<h1 id="attr"><code>.attr()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/attrSync"><code>.attrSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/attrSync"><code>.attrSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.attr()</code> instance method is internally based on the standalone <code>dom/attrSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">attrSync</span>: attr } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { attrSync <span class="hljs-keyword">as</span> attr } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="attrAsync">
					<div exportgroup="readme">

						<h1 id="attrasync"><code>.attrAsync()</code></h1>
<p>This method is used to asynchronously set or get an element's attribute. It is a shorter alternative to the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute"><code>Element.setAttribute()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute"><code>Element.getAttribute()</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a>. It also has special support for list-based attributes like <code>class</code>.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/attrSync"><code>attrSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<ul>
<li><a href="#a-set-attributes">Set Attributes</a></li>
<li><a href="#b-get-attributes">Get Attributes</a></li>
<li><a href="#c-unset-attributes">Unset Attributes</a></li>
<li><a href="#d-modyfying-delimited-attributes">Modyfying Delimited Attributes</a></li>
</ul>
<h2 id="a-set-attributes">a. Set Attributes</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
<span class="hljs-keyword">await</span> $(el).attrAsync(name, value);

<span class="hljs-comment">// Set multiple attributes</span>
<span class="hljs-keyword">await</span> $(el).attrAsync({
    [name]: value,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name to set.</li>
<li><strong><code>value</code></strong>: <strong><code>String|Boolean</code></strong> - The attribute value to set. When <code>true</code>, the string <code>"true"</code> is set on the attribute. When <code>false</code>, the attribute is unset from the element; <a href="#unset-attributes">see below</a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Set the ID attribute on an <code>&lt;input /&gt;</code> element. Then set other attributes.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
$(el).attrAsync(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;email-input&#x27;</span>).then($el =&gt; {
    $el.attrAsync({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;email&#x27;</span>,
        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    });
});</code></pre>
<h2 id="b-get-attributes">b. Get Attributes</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get a single attribute</span>
<span class="hljs-keyword">let</span> attribute = <span class="hljs-keyword">await</span> $(el).attrAsync(name);

<span class="hljs-comment">// Get multiple attributes</span>
<span class="hljs-keyword">let</span> attributes = <span class="hljs-keyword">await</span> $(el).attrAsync([...name]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The value of the named attribute.</li>
<li><strong><code>values</code></strong>: <strong><code>Object</code></strong> - A key/value hash of the listed attributes.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get the attribute on an <code>&lt;input /&gt;</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
<span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> $(el).attrAsync(<span class="hljs-string">&#x27;id&#x27;</span>);
<span class="hljs-comment">// email-input</span></code></pre>
<h2 id="c-unset-attributes">c. Unset Attributes</h2>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Remove a single attribute</span>
$(el).attrAsync(name, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Remove multiple attributes</span>
<span class="hljs-keyword">await</span> $(el).attrAsync({
    [name]: <span class="hljs-literal">false</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage-2">Usage</h3>
<p>Unset an element's ID attribute.</p>
<pre><code class="hljs js language-js">$(el).attrAsync(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-literal">false</span>);</code></pre>
<h2 id="d-modyfying-delimited-attributes">d. Modyfying Delimited Attributes</h2>
<h3 id="syntax-3">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Add a member to a single delimited attribute</span>
$(el).attrAsync(name, member, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Add a member to multiple delimited attributes</span>
$(el).attrAsync({
    [name]: member,
}, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Remove a member from a single delimited attribute</span>
$(el).attrAsync(name, member, mutation === <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Remove a member from multiple delimited attributes</span>
<span class="hljs-keyword">await</span> $(el).attrAsync({
    [name]: member,
}, mutation === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name to modify.</li>
<li><strong><code>member</code></strong>: <strong><code>String</code></strong> - The attribute member to add or remove.</li>
<li><strong><code>mutation</code></strong>: <strong><code>Boolean</code></strong> - The <em>add/remove</em> directive. When <code>true</code>, the given string is added to the attribute's value list. When <code>false</code>, the given string is removed from the attribute's value list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage-3">Usage</h3>
<p>Modify an element's <em>class</em> attribute, then confirm the operation.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;article&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
<span class="hljs-comment">// Insert a class entry</span>
$(el).attrAsync(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>).then($el =&gt; {
    <span class="hljs-comment">// Confirm the operation</span>
    <span class="hljs-built_in">console</span>.log($el.attrSync(<span class="hljs-string">&#x27;class&#x27;</span>)); <span class="hljs-comment">// class1 class2 class3</span>
});</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.attrAsync()</code> instance method is internally based on the standalone <code>dom/attrAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { attrAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { attrAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-4">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="attrSync">
					<div exportgroup="readme">

						<h1 id="attrsync"><code>.attrSync()</code></h1>
<p>This method is used to set or get an element's attribute. It is a shorter alternative to the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute"><code>Element.setAttribute()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute"><code>Element.getAttribute()</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a>. It also has special support for list-based attributes like <code>class</code>.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/attrAsync"><code>attrAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<ul>
<li><a href="#a-set-attributes">Set Attributes</a></li>
<li><a href="#b-get-attributes">Get Attributes</a></li>
<li><a href="#c-unset-attributes">Unset Attributes</a></li>
<li><a href="#d-modyfying-delimited-attributes">Modyfying Delimited Attributes</a></li>
</ul>
<h2 id="a-set-attributes">a. Set Attributes</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
$(el).attrSync(name, value);

<span class="hljs-comment">// Set multiple attributes</span>
$(el).attrSync({
    [name]: value,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name to set.</li>
<li><strong><code>value</code></strong>: <strong><code>String|Boolean</code></strong> - The attribute value to set. When <code>true</code>, the string <code>"true"</code> is set on the attribute. When <code>false</code>, the attribute is unset from the element; <a href="#unset-attributes">see below</a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Set the ID attribute on an <code>&lt;input /&gt;</code> element. Then set other attributes.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
$(el).attrSync(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;email-input&#x27;</span>);
$(el).attrSync({
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;email&#x27;</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
});</code></pre>
<h2 id="b-get-attributes">b. Get Attributes</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get a single attribute</span>
<span class="hljs-keyword">let</span> attribute = $(el).attrSync(name);

<span class="hljs-comment">// Get multiple attributes</span>
<span class="hljs-keyword">let</span> attributes = $(el).attrSync([...name]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The value of the named attribute.</li>
<li><strong><code>values</code></strong>: <strong><code>Object</code></strong> - A key/value hash of the listed attributes.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get the attribute on an <code>&lt;input /&gt;</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single attribute</span>
<span class="hljs-keyword">let</span> value = $(el).attrSync(<span class="hljs-string">&#x27;id&#x27;</span>);
<span class="hljs-comment">// email-input</span></code></pre>
<h2 id="c-unset-attributes">c. Unset Attributes</h2>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Remove a single attribute</span>
$(el).attrSync(name, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Remove multiple attributes</span>
$(el).attrSync({
    [name]: <span class="hljs-literal">false</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage-2">Usage</h3>
<p>Unset an element's ID attribute.</p>
<pre><code class="hljs js language-js">$(el).attrSync(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-literal">false</span>);</code></pre>
<h2 id="d-modyfying-delimited-attributes">d. Modyfying Delimited Attributes</h2>
<h3 id="syntax-3">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Add a member to a single delimited attribute</span>
$(el).attrSync(name, member, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Add a member to multiple delimited attributes</span>
$(el).attrSync({
    [name]: member,
}, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Remove a member from a single delimited attribute</span>
$(el).attrSync(name, member, mutation === <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Remove a member from multiple delimited attributes</span>
$(el).attrSync({
    [name]: member,
}, mutation === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>name</code></strong>: <strong><code>String</code></strong> - The attribute name to modify.</li>
<li><strong><code>member</code></strong>: <strong><code>String</code></strong> - The attribute member to add or remove.</li>
<li><strong><code>mutation</code></strong>: <strong><code>Boolean</code></strong> - The <em>add/remove</em> directive. When <code>true</code>, the given string is added to the attribute's value list. When <code>false</code>, the given string is removed from the attribute's value list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage-3">Usage</h3>
<p>Modify an element's <em>class</em> attribute, then confirm the operation.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;article&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
<span class="hljs-comment">// Insert a class entry</span>
$(el).attrSync(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Confirm the operation</span>
<span class="hljs-built_in">console</span>.log($(el).attrSync(<span class="hljs-string">&#x27;class&#x27;</span>)); <span class="hljs-comment">// class1 class2 class3</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.attrSync()</code> instance method is internally based on the standalone <code>dom/attrSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { attrSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { attrSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-4">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="class">
					<div exportgroup="readme">

						<h1 id="class"><code>.class()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/classSync"><code>.classSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/classSync"><code>.classSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.class()</code> instance method is internally based on the standalone <code>dom/classSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">classSync</span>: _class } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { classSync <span class="hljs-keyword">as</span> _class } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="classAsync">
					<div exportgroup="readme">

						<h1 id="classasync"><code>.classAsync()</code></h1>
<p>This method is used to asynchronously modify or match an element's class list. It provides convenience over using the <a href="/tooling/play-ui/docs/api/dom/attrAsync"><code>attrAsync()</code></a> method to modify an element's class attribute.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/classSync"><code>classSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<ul>
<li><a href="#a-modify-class-list">Modify Class List</a></li>
<li><a href="#b-match-class-list">Match Class List</a></li>
</ul>
<h2 id="a-modify-class-list">a. Modify Class List</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Add member classes</span>
<span class="hljs-keyword">await</span> $(el).classAsync(classList, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Remove member classes</span>
<span class="hljs-keyword">await</span> $(el).classAsync(classList, mutation === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>classList</code></strong>: <strong><code>String</code></strong> - The class list to add or remove.</li>
<li><strong><code>mutation</code></strong>: <strong><code>Boolean</code></strong> - The <em>add/remove</em> directive. When <code>true</code>, the given string is added to the class list. When <code>false</code>, the given string is removed from the class list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Add member classes to an element, then confirm operation.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
$(el).classAsync(<span class="hljs-string">&#x27;class3 class4&#x27;</span>, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-params">Sel</span> =&gt;</span> {
    <span class="hljs-comment">// Confirm operation</span>
    <span class="hljs-built_in">console</span>.log($el.attrSync(<span class="hljs-string">&#x27;class&#x27;</span>)); <span class="hljs-comment">// class1 class2 class3 class4</span>
});</code></pre>
<h2 id="b-match-class-list">b. Match Class List</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// See if one pr more class exists</span>
<span class="hljs-keyword">var</span> exists = <span class="hljs-keyword">await</span> $(el).classAsync(classList);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>classList</code></strong>: <strong><code>String|Array</code></strong> - One or more class names.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>exists</code></strong>: <strong><code>Boolean</code></strong> - This is <code>true</code> if <em>all</em> listed classes exist.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Assert that the given class names exist.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2 class3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
<span class="hljs-comment">// Match classes</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync(<span class="hljs-string">&#x27;class1&#x27;</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync(<span class="hljs-string">&#x27;class1 class3&#x27;</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync(<span class="hljs-string">&#x27;class1 class4&#x27;</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-comment">// As an array</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync([<span class="hljs-string">&#x27;class1 class3&#x27;</span>])); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>])); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class4&#x27;</span>])); <span class="hljs-comment">// false</span>
<span class="hljs-comment">// Mixed</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> $(el).classAsync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class3 class2&#x27;</span>])); <span class="hljs-comment">// true</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.classAsync()</code> instance method is internally based on the standalone <code>dom/classAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { classAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { classAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="classSync">
					<div exportgroup="readme">

						<h1 id="classsync"><code>.classSync()</code></h1>
<p>This method is used to modify or match an element's class list. It provides convenience over using the <a href="/tooling/play-ui/docs/api/dom/attrSync"><code>attrSync()</code></a> method to modify an element's class attribute.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/classAsync"><code>classAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<ul>
<li><a href="#a-modify-class-list">Modify Class List</a></li>
<li><a href="#b-match-class-list">Match Class List</a></li>
</ul>
<h2 id="a-modify-class-list">a. Modify Class List</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Add member classes</span>
$(el).classSync(classList, mutation === <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Remove member classes</span>
$(el).classSync(classList, mutation === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>classList</code></strong>: <strong><code>String|Array</code></strong> - The class list to add or remove.</li>
<li><strong><code>mutation</code></strong>: <strong><code>Boolean</code></strong> - The <em>add/remove</em> directive. When <code>true</code>, the given string is added to the class list. When <code>false</code>, the given string is removed from the class list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Add member classes to an element, then confirm operation.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
$(el).classSync(<span class="hljs-string">&#x27;class3 class4&#x27;</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Confirm operation</span>
<span class="hljs-built_in">console</span>.log($(el).attrSync(<span class="hljs-string">&#x27;class&#x27;</span>)); <span class="hljs-comment">// class1 class2 class3 class4</span></code></pre>
<h2 id="b-match-class-list">b. Match Class List</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// See if one pr more class exists</span>
<span class="hljs-keyword">var</span> exists = $(el).classSync(classList);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>classList</code></strong>: <strong><code>String|Array</code></strong> - One or more class names.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>exists</code></strong>: <strong><code>Boolean</code></strong> - This is <code>true</code> if <em>all</em> listed classes exist.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Assert that the given class names exist.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2 class3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);
<span class="hljs-comment">// Match classes</span>
<span class="hljs-built_in">console</span>.log($(el).classSync(<span class="hljs-string">&#x27;class1&#x27;</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log($(el).classSync(<span class="hljs-string">&#x27;class1 class3&#x27;</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log($(el).classSync(<span class="hljs-string">&#x27;class1 class4&#x27;</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-comment">// As an array</span>
<span class="hljs-built_in">console</span>.log($(el).classSync([<span class="hljs-string">&#x27;class1 class3&#x27;</span>])); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log($(el).classSync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>])); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log($(el).classSync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class4&#x27;</span>])); <span class="hljs-comment">// false</span>
<span class="hljs-comment">// Mixed</span>
<span class="hljs-built_in">console</span>.log($(el).classSync([<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-string">&#x27;class3 class2&#x27;</span>])); <span class="hljs-comment">// true</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.classSync()</code> instance method is internally based on the standalone <code>dom/classSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { classSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { classSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="getTextNodes">
					<div exportgroup="readme">

						<h1 id="gettextnodes"><code>.getTextNodes()</code></h1>
<p>This method is used to get all text nodes within an element.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> textNodes = $(el).getTextNodes();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>textNodes</code></strong>: <strong><code>Array</code></strong> - The text nodes found; each an instance of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Text"><code>Text</code></a>.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Return all text nodes in the document.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> textNodes = $(<span class="hljs-built_in">document</span>.body).getTextNodes();
textNodes.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
    <span class="hljs-comment">// Show text content</span>
    <span class="hljs-built_in">console</span>.log(node.wholeText);
    <span class="hljs-comment">// Replace text content</span>
    node.textContent = <span class="hljs-string">&#x27;New text content.&#x27;</span>;
});</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.getTextNodes()</code> instance method is internally based on the standalone <code>dom/getTextNodes()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { getTextNodes } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { getTextNodes } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="html">
					<div exportgroup="readme">

						<h1 id="html"><code>.html()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/htmlSync"><code>.htmlSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/htmlSync"><code>.htmlSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.html()</code> instance method is internally based on the standalone <code>dom/htmlSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">htmlSync</span>: html } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { htmlSync <span class="hljs-keyword">as</span> html } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="htmlAsync">
					<div exportgroup="readme">

						<h1 id="htmlasync"><code>.htmlAsync()</code></h1>
<p>This method is used to asynchronously set or get an element's HTML/XML content. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML"><code>Element.innerHTML</code></a>. Additionally, when this function receives <code>undefined</code> for a <em>set</em> operation, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/htmlSync"><code>.htmlSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<ul>
<li><a href="#a-set-html-content">Set HTML Content</a></li>
<li><a href="#b-get-html-content">Get HTML Content</a></li>
</ul>
<h2 id="a-set-html-content">a. Set HTML Content</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set HTML content of an element</span>
<span class="hljs-keyword">await</span> $(el).htmlAsync(content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to set.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Replace an element's content with some HTML markup.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-string">&#x27;&lt;div&gt;Playful people!&lt;/div&gt;&#x27;</span>;
$(el).htmlAsync(div);</code></pre>
<h2 id="b-get-html-content">b. Get HTML Content</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get HTML content of an element</span>
<span class="hljs-keyword">let</span> content = <span class="hljs-keyword">await</span> $(el).htmlAsync();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The element's HTML content.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's HTML content.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> content = <span class="hljs-keyword">await</span> $(el).htmlAsync();
<span class="hljs-comment">// &lt;div&gt;Playful people!&lt;/div&gt;</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.htmlAsync()</code> instance method is internally based on the standalone <code>dom/htmlAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { htmlAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { htmlAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="htmlSync">
					<div exportgroup="readme">

						<h1 id="htmlsync"><code>.htmlSync()</code></h1>
<p>This method is used to set or get an element's HTML/XML content. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML"><code>Element.innerHTML</code></a>. Additionally, when this function receives <code>undefined</code> for a <em>set</em> operation, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/htmlAsync"><code>.htmlAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<ul>
<li><a href="#a-set-html-content">Set HTML Content</a></li>
<li><a href="#b-get-html-content">Get HTML Content</a></li>
</ul>
<h2 id="a-set-html-content">a. Set HTML Content</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set HTML content of an element</span>
$(el).htmlSync(content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to set.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Replace an element's content with some HTML markup.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-string">&#x27;&lt;div&gt;Playful people!&lt;/div&gt;&#x27;</span>;
$(el).htmlSync(div);</code></pre>
<h2 id="b-get-html-content">b. Get HTML Content</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get HTML content of an element</span>
<span class="hljs-keyword">let</span> content = $(el).htmlSync();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The element's HTML content.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's HTML content.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> content = $(el).htmlSync();
<span class="hljs-comment">// &lt;div&gt;Playful people!&lt;/div&gt;</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.htmlSync()</code> instance method is internally based on the standalone <code>dom/htmlSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { htmlSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { htmlSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="initialization">
					<div exportgroup="readme">

						<h1 id="the-play-ui-constructor">The Play UI Constructor</h1>
<p>The main Play UI <em>constructor</em> is used to derive elements from a number of input formats and return a Play UI instance for them. It is a <em>constructable function</em> that can be instantiated either with the <code>new</code> keyword (<code>new $()</code>) or via a static call (<code>$()</code>).</p>
<ul>
<li><a href="#a-derive-elements-by-query">Derive Elements By Query</a></li>
<li><a href="#b-derive-elements-by-markup">Derive Elements By Markup</a></li>
<li><a href="#c-accept-actual-element-instances">Accept Actual Element Instances</a></li>
</ul>
<h2 id="a-derive-elements-by-query">a. Derive Elements By Query</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Pass in a CSS selector, and an optional query context</span>
$(selector[, queryContext]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>selector</code></strong> - <code>String</code>: A CSS selector.</li>
<li><strong><code>queryContext</code></strong> - <code>Element|Document</code>: A context within which to run the query. This defaults to the document in the current window.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>The document in context.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Select all <code>div</code> elements.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> $divs = $(<span class="hljs-string">&#x27;div&#x27;</span>).toArray(); <span class="hljs-comment">// .length: 2</span></code></pre>
<p>Select all <code>span</code> elements within a <code>div</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> $spans = $(<span class="hljs-string">&#x27;div&#x27;</span>, divs[<span class="hljs-number">0</span>]).toArray(); <span class="hljs-comment">// .length: 1</span></code></pre>
<p>The above works as when the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll"><code>Document.querySelectorAll()</code></a> / <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll"><code>Element.querySelectorAll()</code></a> method os used except that <code>$()</code> internally polyfills the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS/:is"><code>:is()</code>, (<code>:matches()</code>, <code>:any()</code>)</a> pseudo-class functions.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> $spans = $(<span class="hljs-string">&#x27;:is(div, p) &gt; span&#x27;</span>).toArray(); <span class="hljs-comment">// .length: 3</span></code></pre>
<h2 id="b-derive-elements-by-markup">b. Derive Elements By Markup</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Pass in an HTML markup</span>
$(markup);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>markup</code></strong> - <code>String</code>: An HTML markup.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Translate an HTML markup to actual elements.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> $divs = $(<span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&#x27;</span>).toArray(); <span class="hljs-comment">// .length: 2</span></code></pre>
<h2 id="c-accept-actual-element-instances">c. Accept Actual Element Instances</h2>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Accept an actual element instance</span>
$(element);

<span class="hljs-comment">// Accept a list of actual element instances</span>
$([...element]);

<span class="hljs-comment">// Accept an instance of NodeList</span>
$(nodeList);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong> - <code>Element</code>: A DOM Element.</li>
<li><strong><code>nodeList</code></strong> - <code>NodeList</code>: A DOM <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a> object.</li>
</ul>
<h3 id="usage-2">Usage</h3>
<p>Accept an actual element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> result = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
<span class="hljs-keyword">let</span> $divs = $(result).toArray(); <span class="hljs-comment">// .length: 1</span></code></pre>
<p>Accept a <em>NodeList</em> result.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>);
<span class="hljs-keyword">let</span> $divs = $(result).toArray(); <span class="hljs-comment">// .length: 2</span></code></pre>

					</div>
				</template>

				<template name="itemize">
					<div exportgroup="readme">

						<h1 id="itemize"><code>.itemize()</code></h1>
<p>This method is used to create a live list within an element in an <a href="/tooling/oohtml">OOHTML</a>-based document. (It requires the OHHTML polyfill to be available in the document.)</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">$(el).itemize(items[, params]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>items</code></strong>: <strong><code>Array</code></strong> - A list of data items to populate into a list container.</p></li>
<li><p><strong><code>params</code></strong>: <strong><code>Object</code></strong> - An optional list of additional parameters for the operation.</p>
<ul>
<li><p><strong><code>renderCallback</code></strong>: <strong><code>function(directive, itemElement, itemData, index[, isUpdate])</code></strong> - An optional callback that is called to handle rendering or <em>unrendering</em> of <code>itemData</code>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>directive</code></strong>: <strong><code>String</code></strong> - This will be <code>render</code> when <code>itemData</code> is to be rendered into the given <code>itemElement</code>. It will be <code>unrender</code> when <code>itemData</code> is to be disposed off the given <code>itemElement</code>.</li>
<li><strong><code>itemElement</code></strong>: <strong><code>Element</code></strong> - A newly created <em>list item element</em>, or an existing <em>list item element</em>, that corresponds to the current <code>itemData</code>.</li>
<li><strong><code>itemData</code></strong>: <strong><code>Any</code></strong> - The current entry in the input <code>items</code> associated with <code>itemElement</code>.</li>
<li><strong><code>index</code></strong>: <strong><code>Int</code></strong> - The index of <code>itemData</code> in the input <code>items</code>.</li>
<li><strong><code>isUpdate</code></strong>: <strong><code>Boolean</code></strong> - A flag that indicates whether or not the given <code>itemData</code> is an update to a previous entry in the input <code>items</code>. This flag is only supplied when <code>directive</code> is <code>render</code>.</li></ul>
<p><strong>Return</strong></p>
<p><code>viod|false</code> - A return value is not required for this function. But <code>false</code> can be returned to tell <code>temize()</code> that <code>itemData</code> has been successfully <em>rendered/unrendered</em>. Otherwise, <code>temize()</code> will automatically <em>render/unrender</em> <code>itemData</code> using the <code>itemElement</code>'s <code>setState()</code> and <code>clearState()</code> methods respectively.</p></li>
<li><p><strong><code>overflowCallback</code></strong>: <strong><code>function(directive, itemElement, itemData, index, collapsedCount)</code></strong> - An optional callback that is called to handle overflow events. When omitted, <code>temize()</code> doesn't watch any items for overflow.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>directive</code></strong>: <strong><code>String</code></strong> - This will be <code>collapse</code> when <code>itemElement</code> is at the verge of overflowing the list container. It will be <code>restore</code> when <code>itemElement</code> can be again restored from its <em>collapsed</em> state.</li>
<li><strong><code>itemElement</code></strong>: <strong><code>Element</code></strong> - The <em>list item element</em> to be collapsed or restored.</li>
<li><strong><code>itemData</code></strong>: <strong><code>Any</code></strong> - The current entry in the input <code>items</code> associated with <code>itemElement</code>.</li>
<li><strong><code>index</code></strong>: <strong><code>Int</code></strong> - The index of <code>itemData</code> in the input <code>items</code>.</li>
<li><strong><code>collapsedCount</code></strong>: <strong><code>Int</code></strong> - The number of items still in the <em>collapsed</em> state. This will be <code>0</code> if <code>itemElement</code> is the last element in <em>collapsed</em> state.</li></ul>
<p><strong>Return</strong></p>
<p><code>viod|Promise</code> - A return value is not required for this function. But a <code>Promise</code> can be returned to tell <code>temize()</code> to wait while collapsing or restoring <code>itemElement</code>.</p></li>
<li><p><strong><code>overflowContainerCallback</code></strong>: <strong><code>function(isOverflowing, containerElement, uncollapsedCount, collapsedCount)</code></strong> - An optional callback that is called both <em>at the start</em> and <em>at the end</em> of the reflow process that collapses or restores overflowing items.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>isOverflowing</code></strong>: <strong><code>Boolean</code></strong> - This is <code>true</code> when the reflow process is just beginning; <code>false</code> when the process has just ended.</li>
<li><strong><code>containerElement</code></strong>: <strong><code>Element</code></strong> - The container element undergoing a reflow.</li>
<li><strong><code>uncollapsedCount</code></strong>: <strong><code>Int</code></strong> - The number of items in the <em>uncollapsed</em> state.</li>
<li><strong><code>collapsedCount</code></strong>: <strong><code>Int</code></strong> - The number of items still in the <em>collapsed</em> state.</li></ul>
<p><strong>Return</strong></p>
<p><code>Boolean|Promise</code> - A return value is not required for this function. But <code>false</code> (or a <code>Promise</code> that resolves to <code>false</code>) can be returned when <code>isOverflowing</code> is <em>true</em> to tell <code>temize()</code> to skip a reflow.</p></li>
<li><p><strong><code>collapsionPoint</code></strong>: <strong><code>String</code></strong> - A keyword specifying at what point along the list container to clip overflowing elements. Valid values are:</p>
<ul>
<li><strong><code>start</code></strong> - Clip overflows at the left (for horizontal lists) or top (for vertical lists) of the list container.</li>
<li><strong><code>center-start</code></strong> - Clip overflows at the center of the list container, but when visible elements are even in number, go one item less to the left (for horizontal lists) or top (for vertical lists) of the list container.</li>
<li><strong><code>center</code></strong> - Clip overflows at the center of the list container. This behaves as <code>center-start</code> when visible elements are even in number.</li>
<li><strong><code>center-end</code></strong> - Clip overflows at the center of the list container, but when visible elements are even in number, go one item less to the right (for horizontal lists) or bottom (for vertical lists) of the list container.</li>
<li><strong><code>end</code></strong> - Clip overflows at the right (for horizontal lists) or bottom (for vertical lists) of the list container.</li></ul></li>
<li><p><strong><code>orientation</code></strong>: <strong><code>String</code></strong> - This is either <code>horizontal</code> or <code>vertical</code> to indicate the direction of the list and along which axis to watch for overflow. Default is <code>horizontal</code>.</p></li>
<li><p><strong><code>live</code></strong>: <strong><code>String</code></strong> - Specifies whether or not for <code>temize()</code> to observe input <code>items</code> for mutations. This is <code>true</code> by default.</p></li>
<li><p><strong><code>itemIndexAttribute</code></strong>: <strong><code>String</code></strong> - The attribute name on <code>itemElement</code> on which to set the index of the item. This defaults to <code>data-index</code>.</p></li>
<li><p><strong><code>itemExportId</code></strong>: <strong><code>String</code></strong> - The <em>export ID</em> used for importing <em>item elements</em> for each item in the input <code>items</code>. When this sub parameter is omitted, the fragment identifier found in the module reference on the list container is used. Otherwise, the <em>default</em> export of the  referenced module is used.</p></li>
<li><p><strong><code>parentalOverflowBounds</code></strong>: <strong><code>Boolean</code></strong> - Whether or not to use the container of the list container or the list container itself as the overflow bounds. By default, the container of the list container is used. Set to <code>false</code> to use the list container itself.</p></li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>The document in context. The list items <code>&lt;li&gt;</code> in the module will be used to derive the items for the list container <code>&lt;ul&gt;</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!-- the default export --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!-- a named export --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Create a list of cities.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> items = [
    {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;London&#x27;</span>},
    {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Lagos&#x27;</span>},
    {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Berlin&#x27;</span>},
];
$(<span class="hljs-string">&#x27;ul&#x27;</span>).itemize(items);</code></pre>
<p>A list item <code>&lt;li&gt;</code> is created for each city, and <code>itemize()</code>has bound the item data for each item element to the state of the element using the element's <code>.setState()</code> method. But binding the data alone doesn't get it rendered.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p>Now, we provide a <code>renderCallback</code> function to handle rendering of item data.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-string">&#x27;ul&#x27;</span>).itemize(items, {
    renderCallback(directive, itemElement, itemData) =&gt; {
        <span class="hljs-keyword">if</span> (directive === <span class="hljs-string">&#x27;render&#x27;</span>) {
            itemElement.innerHTML = itemData.name;
        }
    }
});</code></pre>
<p>Item data are now rendered.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Lagos<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Berlin<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<ul>
<li>Automatic data rendering can be achieved intwo ways.</li>
<li>Specifying the item export to use can be achieved intwo ways.</li>
<li>Reactive lists.</li>
<li>Overflow lists.</li>
</ul>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.itemize()</code> instance method is internally based on the standalone <code>dom/itemize()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { itemize } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { itemize } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="prepend">
					<div exportgroup="readme">

						<h1 id="prepend"><code>.prepend()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/prependsync"><code>.prependSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/prependsync"><code>.prependSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.prepend()</code> instance method is internally based on the standalone <code>dom/prependSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">prependSync</span>: prepend } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { prependSync <span class="hljs-keyword">as</span> prepend } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="prependAsync">
					<div exportgroup="readme">

						<h1 id="prependasync"><code>.prependAsync()</code></h1>
<p>This method is used to asynchronously prepend content to an element. It works exactly the same as the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend"><code>ParentNode.prepend()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/prependsync"><code>.prependSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Prepend content(s) to an element</span>
<span class="hljs-keyword">await</span> $(el).prependAsync(content[, ...content]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to prepend.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Prepend an element node and some text content to an element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
$(el).prependAsync(<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;people&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Playful&#x27;</span>, div);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.prependAsync()</code> instance method is internally based on the standalone <code>dom/appendAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { prependAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { prependAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="prependSync">
					<div exportgroup="readme">

						<h1 id="prependsync"><code>.prependSync()</code></h1>
<p>This method is used to prepend content to an element. It works exactly the same as the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend"><code>ParentNode.prepend()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/prependasync"><code>.prependAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Prepend content(s) to an element</span>
$(el).prependSync(content[, ...content]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String|Node</code></strong> - The text or HTML content, or some DOM node, to prepend.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Prepend an element node and some text content to an element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
$(el).prependSync(<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;people&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Playful&#x27;</span>, div);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.prependSync()</code> instance method is internally based on the standalone <code>dom/prependSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { prependSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { prependSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="prependToAsync">
					<div exportgroup="readme">

						<h1 id="prependtoasync"><code>.prependToAsync()</code></h1>
<p>This method is used to asynchronously prepend matched elements to target elements.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/prependtosync"><code>.prependToSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">await</span> $(el).prependToAsync(target);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>target</code></strong>: <strong><code>String|Element</code></strong> - A CSS selector of the element, or the element itself <code>Element</code>, to prepend to.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Prepend some dynamically-created nodes to document body.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-string">&#x27;&lt;h1&gt;Playful people!&lt;/h1&gt;&#x27;</span>).prependToAsync(<span class="hljs-built_in">document</span>.body);</code></pre>
<p>Prepend an existing <code>div</code> to multiple targets. The <code>div</code> is cloned into all targets except the last target.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
$(div).prependToAsync(<span class="hljs-string">&#x27;.multiple&#x27;</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.prependToAsync()</code> instance method is internally based on the standalone <code>dom/prependToAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { prependToAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { prependToAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="prependToSync">
					<div exportgroup="readme">

						<h1 id="prependtosync"><code>.prependToSync()</code></h1>
<p>This method is used to prepend matched elements to target elements.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/prependtoasync"><code>.prependToAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">$(el).prependToSync(target);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>target</code></strong>: <strong><code>String|Element</code></strong> - A CSS selector of the element, or the element itself <code>Element</code>, to prepend to.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Prepend some dynamically-created nodes to document body.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-string">&#x27;&lt;h1&gt;Playful people!&lt;/h1&gt;&#x27;</span>).prependToSync(<span class="hljs-built_in">document</span>.body);</code></pre>
<p>Prepend an existing <code>div</code> to multiple targets. The <code>div</code> is cloned into all targets except the last target.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
$(div).prependToSync(<span class="hljs-string">&#x27;.multiple&#x27;</span>);</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.prependToSync()</code> instance method is internally based on the standalone <code>dom/prependToSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { prependToSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { prependToSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="text">
					<div exportgroup="readme">

						<h1 id="text"><code>.text()</code></h1>
<p>This method is an alias of the <a href="/tooling/play-ui/docs/api/dom/textSync"><code>.textSync()</code></a> method. See <a href="/tooling/play-ui/docs/api/dom/textSync"><code>.textSync()</code></a> for documentation.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.text()</code> instance method is internally based on the standalone <code>dom/textSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { <span class="hljs-attr">textSync</span>: text } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { textSync <span class="hljs-keyword">as</span> text } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="textAsync">
					<div exportgroup="readme">

						<h1 id="textasync"><code>.textAsync()</code></h1>
<p>This method is used to asynchronously set or get an element's text content. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText"><code>Element.innerText</code></a>. Additionally, when this function receives <code>undefined</code> for a <em>set</em> operation, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/textSync"><code>.textSync()</code></a>. Unlike the <em>Sync</em> counterpart, this method is promised-based. See <a href="/tooling/play-ui/docs/api/overview#meet-async-ui">Async UI</a>.</p>
<ul>
<li><a href="#a-set-text-content">Set Text Content</a></li>
<li><a href="#b-get-text-content">Get Text Content</a></li>
</ul>
<h2 id="a-set-text-content">a. Set Text Content</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set text content of an element</span>
<span class="hljs-keyword">await</span> $(el).textAsync(content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The text content to set.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Replace an element's content with some text.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;Playful people!&#x27;</span>;
$(el).textAsync(text);</code></pre>
<h2 id="b-get-text-content">b. Get Text Content</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get Text content of an element</span>
<span class="hljs-keyword">let</span> content = <span class="hljs-keyword">await</span> $(el).textAsync();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The element's text content.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's text content.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> content = <span class="hljs-keyword">await</span> $(el).textAsync();
<span class="hljs-comment">// Playful people!</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.textAsync()</code> instance method is internally based on the standalone <code>dom/textAsync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { textAsync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { textAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="textSync">
					<div exportgroup="readme">

						<h1 id="textsync"><code>.textSync()</code></h1>
<p>This method is used to set or get an element's text content. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText"><code>Element.innerText</code></a>. Additionally, when this function receives <code>undefined</code> for a <em>set</em> operation, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/api/dom/textAsync"><code>.textAsync()</code></a>. Unlike the <em>Async</em> counterpart, this method is not promised-based.</p>
<ul>
<li><a href="#a-set-text-content">Set Text Content</a></li>
<li><a href="#b-get-text-content">Get Text Content</a></li>
</ul>
<h2 id="a-set-text-content">a. Set Text Content</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set text content of an element</span>
$(el).textSync(content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The text content to set.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Replace an element's content with some text.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;Playful people!&#x27;</span>;
$(el).textSync(text);</code></pre>
<h2 id="b-get-text-content">b. Get Text Content</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get Text content of an element</span>
<span class="hljs-keyword">let</span> content = $(el).textSync();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>content</code></strong>: <strong><code>String</code></strong> - The element's text content.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Get an element's text content.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> content = $(el).textSync();
<span class="hljs-comment">// Playful people!</span></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.textSync()</code> instance method is internally based on the standalone <code>dom/textSync()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { textSync } = $.dom;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { textSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-2">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>
			</template>

			<template name="misc">
				<div exportgroup="readme">

					<h1 id="api-category-miscellaneous">API Category: Miscellaneous</h1>

				</div>

				<template name="classes">
					<div exportgroup="readme">

						<h1 id="classes">Classes</h1>
<p>Classes in this category.</p>

					</div>

					<template name="Transaction">
						<div exportgroup="readme">

							<h1 id="class-transaction-"><code>class Transaction {}</code></h1>
<p>This class lets us create rollback points while manipulating an element.</p>
<h2 id="constructor-NaN">Constructor</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transaction = <span class="hljs-keyword">new</span> Transaction(el, props, readCallback, writeCallback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>el</code></strong>: <strong><code>Element</code></strong> - The element that will be modified.</p></li>
<li><p><strong><code>props</code></strong>: <strong><code>String|Array</code></strong> - A property or list of properties that describes the operation on the element.</p></li>
<li><p><strong><code>readCallback</code></strong>: <strong><code>function(el, props)</code></strong> - A function that is called to capture the state of the element using the listed <em>props</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>el</code></strong>: <strong><code>Element</code></strong> - The element being operated on.</li>
<li><strong><code>props</code></strong>: <strong><code>Array</code></strong> - An array of the properties passed to the instance.</li></ul>
<p><strong>Return</strong></p>
<ul>
<li><p><strong><code>Object</code></strong> - A key/value hash for the listed properties.</p></li>
<li><p><strong><code>Promise</code></strong> - A promise that should resolve to the object above.</p>
<p>This return value is what the transaction's <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/classes/transaction/savepoint"><code>savepoint()</code></a> instance method returns when called.</p></li></ul></li>
<li><p><strong><code>writeCallback</code></strong>: <strong><code>function(el, record)</code></strong> - A function that is called to re-apply the recorded state of the element as previously derived by the <code>readCallback</code> function.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>el</code></strong>: <strong><code>Element</code></strong> - The element being operated on.</li>
<li><strong><code>record</code></strong>: <strong><code>Object</code></strong> - The recorded state of the element as previously derived by the <code>readCallback</code> function.</li></ul>
<p><strong>Return</strong></p>
<ul>
<li><p><strong><code>Any</code></strong> - Any value may be returned and will not be used.</p></li>
<li><p><strong><code>Promise</code></strong> - A promise that may resolve to anything.</p>
<p>This return value is what the transaction's <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/rollback"><code>rollback()</code></a> and <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/apply"><code>apply()</code></a> instance methods return when called.</p></li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Transaction</code></strong> - The Transaction instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Below, we modify an element's CSS properties and later roll back the element to its initial state.</p>
<p><em>Define the element's stylesheet- and inline-based CSS:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background-color</span>: yellow;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Start a transaction:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The readCallback will read the INLINE values of the listed properties</span>
<span class="hljs-comment">// This state is what will be restored on a call to transaction.rollback() </span>
<span class="hljs-comment">// Notice the &quot;inline&quot; flag, which tells cssSync() to read INLINE CSS</span>
<span class="hljs-keyword">const</span> readCallback = <span class="hljs-function">(<span class="hljs-params">el, props</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> $(el).cssSync(props, {<span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>});
};

<span class="hljs-comment">// The writeCallback will restore the INLINE values of the listed properties previously stored</span>
<span class="hljs-comment">// It is triggered by a call to transaction.rollback() and to transaction.apply() </span>
<span class="hljs-keyword">const</span> writeCallback = <span class="hljs-function">(<span class="hljs-params">el, record</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> $(el).cssSync(record);
};

<span class="hljs-comment">// Obtaine a Transaction instance</span>
<span class="hljs-keyword">let</span> transaction = $(<span class="hljs-string">&#x27;#el&#x27;</span>).transaction([<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>], readCallback, writeCallback);</code></pre>
<p><em>Do some modifications and create savepoints along the way:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Create a savepoint for the initial state of the element - savepoint1</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();

<span class="hljs-comment">// Alter the element&#x27;s computed style</span>
el.style.color = <span class="hljs-string">&#x27;green&#x27;</span>;
el.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span>;
<span class="hljs-comment">// Create a savepoint - savepoint2</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();

<span class="hljs-comment">// Alter the element&#x27;s computed style further</span>
el.style.color = <span class="hljs-string">&#x27;brown&#x27;</span>;
el.style.backgroundColor = <span class="hljs-string">&#x27;teal&#x27;</span>;
<span class="hljs-comment">// Create a savepoint - savepoint3</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.savepoint();</code></pre>
<p><em>Rollback to a savepoint</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Rollback to anypoint after some time</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transaction.rollback(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// Now background-color should fallback to yellow</span>
    <span class="hljs-comment">// And color should be back to red</span>
}, <span class="hljs-number">2000</span>);</code></pre>
<p>In the code above, if another part of the app had changed one of those properties after the last <em>savepoint</em> we made, then the call to <code>rollback()</code> would have overridden those <em>foreign changes</em> to restore the element to the specified <em>savepoint</em>.</p>
<p>To automatically detect <em>foreign changes</em> and leave them untouched, we would set the <code>preserveCurrentState</code> parameter of the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/rollback"><code>rollback()</code></a> method to <code>true</code>. (The <code>readCallback</code> function will be called again to take the element's current state for comparison.)</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The following changes were made after our last savepoint</span>
el.style.color = <span class="hljs-string">&#x27;brown&#x27;</span>;

<span class="hljs-comment">// Rollback to savepoint2</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transaction.rollback(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">// Now, color will be left at &#x27;brown&#x27;</span>
}, <span class="hljs-number">2000</span>);</code></pre>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>.length</code></strong>: <strong><code>Int</code></strong> - Gives the number of savepoints in the transaction.</li>
</ul>
<h2 id="methods">Methods</h2>
<p>Check out <em>Transaction's</em> methods.</p>

						</div>

						<template name="apply">
							<div exportgroup="readme">

								<h1 id="apply"><code>.apply()</code></h1>
<blockquote>
  <p>The <code>transaction.apply()</code> method.</p>
</blockquote>
<p>This method is used to apply a new state to the element in a transaction. It is just another way to call the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#constructor"><code>writeCallback</code></a> function that was used to create the instance.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">transaction.apply(state);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>state</code></strong>: <strong><code>Object</code></strong> - A new state object that is passed to the instance's <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#constructor"><code>writeCallback</code></a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Any</code></strong> - The return value of the transaction's <code>writeCallback</code> function.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing transaction and call <code>.apply()</code>. Below, we build on the usage example on the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#usage">Transaction</a> page. Here we use the <code>.apply()</code> method to apply the CSS properties in that example.</p>
<pre><code class="hljs js language-js">ananimationi.apply({
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;brown&#x27;</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;teal&#x27;</span>,
});</code></pre>

							</div>
						</template>

						<template name="commit">
							<div exportgroup="readme">

								<h1 id="commit"><code>.commit()</code></h1>
<blockquote>
  <p>The <code>transaction.commit()</code> method.</p>
</blockquote>
<p>This method is used to commit up to a savepoint in a transaction. It is used to certify that all records up to the specified savepoint are permanent changes.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">transaction.commit(savepoint = <span class="hljs-number">0</span>);</code></pre>
<ul>
<li><strong><code>savepoint</code></strong>: <strong><code>Int</code></strong> - The savepoint to commit up to. <code>0</code> refers to the record of the first call to <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/savepoint"><code>.savepoint()</code></a>; <code>1</code> to the second call; and so on.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/">Transaction</a> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing transaction and call <code>.commit()</code>. Below, we build on the usage example on the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#usage">Transaction</a> page. Here we use the <code>.commit()</code> method to commit all savepoints. Calling the transaction's <code>.rollback()</code> method after this point will have no effect.</p>
<pre><code class="hljs js language-js">ananimationi.commit(<span class="hljs-number">0</span>);</code></pre>

							</div>
						</template>

						<template name="rollback">
							<div exportgroup="readme">

								<h1 id="rollback"><code>.rollback()</code></h1>
<blockquote>
  <p>The <code>transaction.rollback()</code> method.</p>
</blockquote>
<p>This method is used to roll back up to a savepoint in a transaction. It re-applies the previously recorded state of the element by calling the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#constructor"><code>writeCallback</code></a> function that was used to create the instance. The complementary <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#constructor"><code>readCallback</code></a> function will also be involved if the <code>preserveCurrentState</code> parameter is set to <code>true</code>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">transaction.rollback(savepoint = <span class="hljs-number">0</span>, preserveCurrentState = <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>savepoint</code></strong>: <strong><code>Int</code></strong> - The savepoint to roll back to. <code>0</code> refers to the record of the first call to <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/savepoint"><code>.savepoint()</code></a>; <code>1</code> to the second call; and so on.</li>
<li><strong><code>preserveCurrentState</code></strong>: <strong><code>Boolean</code></strong> - Specifies whether or not to detect and preserve any additional changes made after the last call to <code>savepoint()</code>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Any</code></strong> - The return value of the <code>writeCallback</code> function.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>See the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#usage">Transaction</a> class.</p>

							</div>
						</template>

						<template name="savepoint">
							<div exportgroup="readme">

								<h1 id="savepoint"><code>.savepoint()</code></h1>
<blockquote>
  <p>The <code>transaction.savepoint()</code> method.</p>
</blockquote>
<p>This method is used to create a savepoint from the current state of an element in a transaction. It takes records by calling the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#constructor"><code>readCallback</code></a> function that was used to create the instance.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">transaction.savepoint();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Any</code></strong> - The return value of the <code>readCallback</code> function.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>See the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction/#usage">Transaction</a> class.</p>

							</div>
						</template>
					</template>
				</template>

				<template name="data">
					<div exportgroup="readme">

						<h1 id="data">.data()</h1>
<p>This method is used to store and manage arbitrary data with a data store internally associated with an element.</p>
<ul>
<li><a href="#a-set-data">Set Data</a></li>
<li><a href="#b-get-data">Get Data</a></li>
<li><a href="#c-unset-data">Unset Data</a></li>
</ul>
<h2 id="a-set-data">a. Set Data</h2>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set a single value</span>
$(el).data(key, value);

<span class="hljs-comment">// Set multiple values</span>
$(el).data({
    [key]: value,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>key</code></strong>: <strong><code>String</code></strong> - The key to set.</li>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The data value to set. When <code>undefined</code>, the data key is unset from the data store; <a href="#c-unset-data">see below</a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Set several distinct values for all elements matched by <code>$()</code>.</p>
<pre><code class="hljs js language-js">$(el).data(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value 1&#x27;</span>).data({
    <span class="hljs-attr">key2</span>: <span class="hljs-string">&#x27;value 2&#x27;</span>,
    <span class="hljs-attr">key3</span>: <span class="hljs-string">&#x27;value 3&#x27;</span>
});</code></pre>
<h2 id="b-get-data">b. Get Data</h2>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Retrieve single value</span>
<span class="hljs-keyword">let</span> value = $(el).data(key);

<span class="hljs-comment">// Retrieve multiples values</span>
<span class="hljs-keyword">let</span> values = $(el).data([...key]);

<span class="hljs-comment">// Retrieve all values</span>
<span class="hljs-keyword">let</span> values = $(el).data();</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>key</code></strong>: <strong><code>String</code></strong> - The data key to read.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>value</code></strong>: <strong><code>Any</code></strong> - The data value as initially stored, or <code>undefined</code>.</li>
<li><strong><code>values</code></strong>: <strong><code>Object</code></strong> - A hash of key/value pairs for each key in the list or in the entire data store, as in the last syntax.</li>
</ul>
<h3 id="usage-1">Usage</h3>
<p>Retrieve values for the first element matched by <code>$()</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> value = $(el).data(<span class="hljs-string">&#x27;key1&#x27;</span>);
<span class="hljs-comment">// value-1</span></code></pre>
<h2 id="c-unset-data">c. Unset Data</h2>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unset single property</span>
.data(key, <span class="hljs-literal">undefined</span>);

<span class="hljs-comment">// Unset multiples values</span>
$(el).data({
    [key]: <span class="hljs-literal">undefined</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>key</code></strong>: <strong><code>String</code></strong> - The data key to unset.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage-2">Usage</h3>
<p>Unset values for all elements matched by <code>$()</code>.</p>
<pre><code class="hljs js language-js">$(el).data(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-literal">undefined</span>).data({
    <span class="hljs-attr">key2</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">key3</span>: <span class="hljs-literal">undefined</span>,
});</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.data()</code> instance method is internally based on the standalone <code>misc/data()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { data } = $.misc;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { data } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/misc/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-3">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="transaction">
					<div exportgroup="readme">

						<h1 id="transaction"><code>.transaction()</code></h1>
<p>This method is used to start a transaction on an element for operations that eventually might need to be rolled back. It is a convenient way to use the Play UI's <a href="/tooling/play-ui/docs/api/misc/classes/Transaction">Transaction</a> class.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transaction = $(el).transaction(props, readCallback, writeCallback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>props</code></strong>: <strong><code>String|Array</code></strong> - A property or list of properties that describes the operation on the element.</li>
<li><strong><code>readCallback</code></strong>: <strong><code>function(el, props)</code></strong> - A function that is called to capture the state of the element using the listed <em>props</em>. See the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction#constructor">Transaction</a> class.</li>
<li><strong><code>writeCallback</code></strong>: <strong><code>function(el, record)</code></strong> - A function that is called to re-apply the recorded state of the element as previously derived by the <code>readCallback</code> function. See the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction#constructor">Transaction</a> class.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>Transaction</code></strong> - The <a href="/tooling/play-ui/docs/api/misc/classes/Transaction">Transaction</a> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>See the <a href="/tooling/play-ui/docs/api/misc/classes/Transaction#constructor">Transaction</a> class.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.transaction()</code> instance method is internally based on the standalone <code>misc/transaction()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { transaction } = $.misc;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { transaction } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/misc/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>
			</template>

			<template name="ui">
				<div exportgroup="readme">

					<h1 id="api-category-ui">API Category: UI</h1>

				</div>

				<template name="classes">
					<template name="Animation">
						<div exportgroup="readme">

							<h1 id="class-animation-"><code>class Animation {}</code></h1>
<p>This class provides an intuitive way to use the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">Web Animations API (WAAPI)</a>.</p>
<h2 id="constructor-NaN">Constructor</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(element, effect[, timing = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - A DOM element.</li>
<li><strong><code>effect</code></strong>: <strong><code>Array|Object|String</code></strong> - The effect to play. This could be a standard keyframes array, a CSS rules object, or a stylesheet-based animation name.</li>
<li><strong><code>timing</code></strong>: <strong><code>Object</code></strong> - Options for the animation.<ul>
<li><strong><code>duration</code></strong>: <strong><code>Number</code></strong> - The animation's duration in milliseconds.</li>
<li><strong><code>fill</code></strong>: <strong><code>String</code></strong> - The element's final state on finish; one of <code>none</code> (default), <code>forwards</code>, <code>both</code>.</li>
<li><strong><code>delay</code></strong>: <strong><code>Number</code></strong> - The animation's delay in milliseconds before playing.</li>
<li><strong><code>endDelay</code></strong>: <strong><code>Number</code></strong> - The animation's delay in milliseconds after playing.</li>
<li><strong><code>direction</code></strong>: <strong><code>String</code></strong> - The animation's direction; one of <code>normal</code> (default), <code>reverse</code>, <code>alternate</code>, <code>alternate-reverse</code>.</li>
<li><strong><code>easing</code></strong>: <strong><code>String</code></strong> - The rate of the animation's change over time; one of <code>linear</code> (default), <code>ease</code>, <code>ease-in</code>, <code>ease-out</code>, <code>ease-in-out</code>, or a custom <code>cubic-bezier</code> value like <code>cubic-bezier(0.42, 0, 0.58, 1)</code>.</li>
<li><strong><code>iterations</code></strong>: <strong><code>Number</code></strong> - The number of times the animation should repeat.</li>
<li><strong><code>iterationStart</code></strong>: <strong><code>Number</code></strong> - At what point in the iteration the animation should start.</li>
<li><strong><code>cancelForCss</code></strong>: <strong><code>Boolean</code></strong> - (Specific to this class) Whether or not to cancel the animation on finish for subsequent CSS rules on the element to take effect. By default, properties animated with WAAPI cannot be modified with CSS. Setting <code>cancelForCss</code> to <code>true</code> fixes it. </li></ul></li>
</ul>
<h2 id="usage">Usage</h2>
<p>Create and play an animation.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});

animation.play().then(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<h2 id="features">Features</h2>
<p><em>Animation</em> provides the following rich set of features over WAAPI:</p>
<ul>
<li><p><strong>Support for single-frame keyframes.</strong> <em>Animation</em> will automatically derive the animation's first frame from the element's current state.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Fade out from current opacity level</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>}, timing);</code></pre></li>
<li><p><strong>Support for CSS keyframes.</strong> <em>Animation</em> can play animations defined in the document's stylesheets. Just mention an animation name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

<span class="hljs-keyword">@keyframes</span> fadeout {
<span class="hljs-number">0%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;}
<span class="hljs-number">100%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;}
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Play the animation from stylesheet</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, <span class="hljs-string">&#x27;fadeout&#x27;</span>, timing);</code></pre></li>
<li><p><strong>Support for <em>auto</em> height and width.</strong> <em>Animation</em> accepts and automacally computes the keyword <em>auto</em> for the width and height properties.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:0px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Expand to the element&#x27;s real size at &quot;auto&quot;</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;auto&#x27;</span>}, timing);</code></pre></li>
<li><p><strong>Automatic units for unit-based CSS properties.</strong> <em>Animation</em> will automacally suffix numeric values with <code>px</code> for properties like <code>top</code> that don't go without units.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Help add &quot;px&quot; to the value for width</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">width</span>: <span class="hljs-number">50</span>}, timing);</code></pre></li>
<li><p><strong>Support for shortform rules.</strong> <em>Animation</em> will accept an object or array for the following shortforms: inset, margin, padding.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Destructure the following object into their individual properties</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">inset</span>: {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">100</span>}}, timing);
<span class="hljs-comment">// Here we actually mean </span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">100</span>}, timing);
<span class="hljs-comment">// ---------------</span>
<span class="hljs-comment">// Destructure the following array into their individual properties</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">inset</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">75</span>, <span class="hljs-number">125</span>,]}, timing);
<span class="hljs-comment">// Here we actually mean </span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">75</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">125</span>}, timing);
<span class="hljs-comment">// All shortforms go in this order: top, right, bottom, left</span></code></pre></li>
<li><p><strong>Sensible default timing parameters.</strong> <em>Animation</em> will automatically create sensible values for the animation timing where not defined.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timing object has the following defaults</span>
{
    <span class="hljs-attr">duration</span>: <span class="hljs-number">400</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">&#x27;both&#x27;</span>,
}</code></pre></li>
<li><p><strong>Other usefull methods.</strong> See below.</p></li>
</ul>
<h2 id="methods">Methods</h2>
<p>Explore the instance methods of this class.</p>

						</div>

						<template name="cancel">
							<div exportgroup="readme">

								<h1 id="cancel"><code>.cancel()</code></h1>
<blockquote>
  <p>The <code>animation.cancel()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to cancel an animation. If there are <em>oncancel</em> handlers, they are called.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.cancel();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.cancel()</code>.</p>
<pre><code class="hljs js language-js">animation.cancel();</code></pre>

							</div>
						</template>

						<template name="finish">
							<div exportgroup="readme">

								<h1 id="finish"><code>.finish()</code></h1>
<blockquote>
  <p>The <code>animation.finish()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to force an animation to the finished state. If there are <em>onfinish</em> handlers, they are called.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.finish();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.finish()</code>.</p>
<pre><code class="hljs js language-js">animation.finish();</code></pre>

							</div>
						</template>

						<template name="oncancel">
							<div exportgroup="readme">

								<h1 id="oncancel"><code>.oncancel()</code></h1>
<blockquote>
  <p>The <code>animation.oncancel()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to bind a handler to the 'cancelled' state of an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.oncancel(callback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>callback</code></strong>: <strong><code>function(element)</code></strong> - The function to call on <em>cancel</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - The DOM element of the animation instance.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Bind an <em>oncancel</em> callback to an animation.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Animation instance</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>});

<span class="hljs-comment">// Bind a callback</span>
animation.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Animation on the &#x27;</span> + el.id + <span class="hljs-string">&#x27; element cancelled!&#x27;</span>);
});

<span class="hljs-comment">// Bind another callback if necessary</span>
animation.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>

							</div>
						</template>

						<template name="onfinish">
							<div exportgroup="readme">

								<h1 id="onfinish"><code>.onfinish()</code></h1>
<blockquote>
  <p>The <code>animation.onfinish()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to bind a handler to the 'finished' state of an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.onfinish(callback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>callback</code></strong>: <strong><code>function(element)</code></strong> - The function to call on <em>finish</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - The DOM element of the animation instance.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Bind an <em>onfinish</em> callback to an animation.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Animation instance</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>});

<span class="hljs-comment">// Bind a callback</span>
animation.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Animation on the &#x27;</span> + el.id + <span class="hljs-string">&#x27; element finished!&#x27;</span>);
});

<span class="hljs-comment">// Bind another callback if necessary</span>
animation.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>

							</div>
						</template>

						<template name="pause">
							<div exportgroup="readme">

								<h1 id="pause"><code>.pause()</code></h1>
<blockquote>
  <p>The <code>animation.pause()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to pause an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.pause();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.pause()</code>.</p>
<pre><code class="hljs js language-js">animation.pause();</code></pre>

							</div>
						</template>

						<template name="play">
							<div exportgroup="readme">

								<h1 id="play"><code>.play()</code></h1>
<blockquote>
  <p>The <code>animation.play()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to play an animation. This method is promised-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">await</span> animation.play();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.play()</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, [{
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>,
}, {
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>,
}], {
    <span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>
});

animation.play().then(<span class="hljs-function"><span class="hljs-params">animation</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);

    <span class="hljs-comment">// Call other methods</span>
    animation.reverse();
});</code></pre>

							</div>
						</template>

						<template name="progress">
							<div exportgroup="readme">

								<h1 id="progress"><code>.progress()</code></h1>
<blockquote>
  <p>The <code>animation.progress()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to get the percentage progress of an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> progress = animation.progress();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>progress</code></strong>: <strong><code>Number</code></strong> - A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the animation's total timing. Here the total timing is calculated as <code>delay + duration + endDelay</code>.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Get the progress of an animation at 350ms.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, [{
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>,
}, {
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>,
}], {
    <span class="hljs-attr">delay</span>: <span class="hljs-number">100</span>, 
    <span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>,
});

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(animation.progress()); <span class="hljs-comment">// About 0.5</span>
}, <span class="hljs-number">350</span>);</code></pre>

							</div>
						</template>

						<template name="ready">
							<div exportgroup="readme">

								<h1 id="ready"><code>.ready()</code></h1>
<blockquote>
  <p>The <code>animation.ready()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to bind a handler to the 'ready' state of an animation. This is useful as there are cases where the animation is created asynchronously.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.ready(readyCallback[, failureCallback = <span class="hljs-literal">null</span>]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><code>readyCallback</code>: <code>function(waapi, timing, firstFrame, lastFrame)</code>: The function to call on ready.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>waapi</code></strong>: <strong><code>Animation</code></strong> - The underlying WAAPI <code>Animation</code> instance.</li>
<li><strong><code>timing</code></strong>: <strong><code>Object</code></strong> - The instance's timing object.</li>
<li><strong><code>firstFrame</code></strong>: <strong><code>Object</code></strong> - The animation's <em>firstFrame</em> object. Especially useful where this has to be automatically derived by Ani.</li>
<li><strong><code>lastFrame</code></strong>: <strong><code>Object</code></strong> - The animation's <em>lastFrame</em> object. Especially useful where this has to be automatically resolved by Ani.</li></ul></li>
<li><p><strong><code>failureCallback</code></strong>: <strong><code>function(errorMsg)</code></strong> - A function to call on fatal errors preventing the creation of the animation.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>errorMsg</code></strong>: <strong><code>String</code></strong> - The description of the error.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Bind a <em>ready</em> callback to an animation.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call ready()</span>
<span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, {
    <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;auto&#x27;</span>,
});

aanimationni.ready(<span class="hljs-function">(<span class="hljs-params">waapi, timing, firstFrame, lastFrame</span>) =&gt;</span> {
    <span class="hljs-comment">// Show the two keyframes</span>
    <span class="hljs-built_in">console</span>.log(firstFrame, lastFrame);
});</code></pre>

							</div>
						</template>

						<template name="reverse">
							<div exportgroup="readme">

								<h1 id="reverse"><code>.reverse()</code></h1>
<blockquote>
  <p>The <code>animation.reverse()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to reverse an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.reverse();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.reverse()</code>.</p>
<pre><code class="hljs js language-js">animation.reverse();</code></pre>

							</div>
						</template>

						<template name="seek">
							<div exportgroup="readme">

								<h1 id="seek"><code>.seek()</code></h1>
<blockquote>
  <p>The <code>animation.seek()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instance method is used to seek to a percentage point in an animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">animation.seek(point);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>point</code></strong>: <strong><code>Number</code></strong> - A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the animation's total timing. Here the total timing is calculated as <code>delay + duration + endDelay</code>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Animation</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Seek an animation to half its total duration.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Animation(el, [{
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>,
}, {
    <span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>,
}], {
    <span class="hljs-attr">delay</span>: <span class="hljs-number">100</span>, 
    <span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>,
});

<span class="hljs-comment">// Seek the animation to 350ms</span>
animation.seek(<span class="hljs-number">0.5</span>);</code></pre>

							</div>
						</template>
					</template>

					<template name="Event">
						<div exportgroup="readme">

							<h1 id="class-event-"><code>class Event {}</code></h1>
<p>Instances of this class represent a DOM event or user gesture event.</p>
<h2 id="constructor-NaN">Constructor</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> Event(target, e);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>target</code></strong>: <strong><code>Element</code></strong> - The DOM element on which the event happend.</li>
<li><strong><code>e</code></strong>: <strong><code>Event</code></strong> - The origin event object that this class will wrap. This is either a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">native browser event object</a> or a <a href="https://hammerjs.github.io/api/#event-object">Hammer.js event object</a> describing a gesture event.</li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>event.type</code></strong>: <strong><code>String</code></strong> - (Readonly) Returns the type of the origin event passed to the constructor.</li>
<li><strong><code>event.target</code></strong>: <strong><code>Element</code></strong> - (Readonly) Returns the target element passed to the constructor.</li>
<li><strong><code>event.defaultPrevented</code></strong>: <strong><code>Boolean</code></strong> - (Readonly) Tells if the instance's <code>.preventDefault()</code> method has been called.</li>
<li><strong><code>event.propagationStopped</code></strong>: <strong><code>Boolean</code></strong> - (Readonly) Tells if the instance's <code>.stopPropagation()</code> method has been called.</li>
<li><strong><code>event.promises</code></strong>: <strong><code>null|Promise</code></strong> - (Readonly) Returns a <em>Promise</em> that consolidates all promises assigned by the event handlers using the instance's <code>.promise()</code> method. Returns <code>null</code> if no Promise has been recieved.</li>
<li><strong><code>event.e</code></strong>: <strong><code>Event</code></strong> - (Readonly) Returns the origin event object passed to the constructor.</li>
</ul>
<h2 id="instance-methods">Instance Methods</h2>
<h3 id="eventpreventdefault"><code>event.preventDefault()</code></h3>
<h3 id="eventstoppropagation"><code>event.stopPropagation()</code></h3>
<h3 id="eventpromise"><code>event.promise()</code></h3>
<h3 id="eventresponse"><code>event.response()</code></h3>

						</div>
					</template>

					<template name="Listener">
						<div exportgroup="readme">

							<h1 id="class-listener-"><code>class Listener {}</code></h1>
<p>Instances of this class represent an event listener.</p>
<h2 id="constructor-NaN">Constructor</h2>
<p><em>Instances are created internally.</em></p>
<h2 id="instance-methods">Instance Methods</h2>
<h3 id="listenerdisconnect"><code>listener.disconnect()</code></h3>
<h3 id="listenerfire"><code>listener.fire()</code></h3>

						</div>
					</template>

					<div exportgroup="readme">

						<h1 id="classes">Classes</h1>
<p>Classes in this category.</p>

					</div>

					<template name="Timeline">
						<div exportgroup="readme">

							<h1 id="timeline">Timeline</h1>
<p>This class provides a convenient way to control multiple <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instances.</p>
<h2 id="constructor-NaN">Constructor</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline(animations[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>animations</code></strong>: <strong><code>Array</code></strong> - Zero or more <a href="/tooling/play-ui/docs/api/ui/classes/Animation">Animation</a> instances.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - A few parameters for the timeline. (Currently none).</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Play/pause multiple animations in one call.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> ani1 = <span class="hljs-keyword">new</span> Animation(el1, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
<span class="hljs-keyword">let</span> ani2 = <span class="hljs-keyword">new</span> Animation(el2, [{<span class="hljs-attr">width</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">width</span>:<span class="hljs-number">100</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">900</span>});

<span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline([ani1, ani2]);
timeline.pause();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
   timeline.play().then(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end; all animations!&#x27;</span>);
    });
}, <span class="hljs-number">1000</span>);</code></pre>
<h2 id="features">Features</h2>
<ul>
<li><p><strong>Runtime manipulation of timeline.</strong> <em>Timeline</em> allows you to add/remove animation instances at runtime without altering coordination and synchronization.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Fade out from current opacity level</span>
<span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline([ani1, ani2]);

<span class="hljs-comment">// Kick off</span>
timeline.play().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end; all animations!&#x27;</span>);
});

<span class="hljs-comment">// On the fly</span>
timeline.add(ani3);
timeline.remove(ani1);
<span class="hljs-comment">// Yet, our play.then() will work as expected</span></code></pre></li>
</ul>
<h2 id="methods">Methods</h2>
<p>Explore the instance methods of this class.</p>

						</div>

						<template name="add">
							<div exportgroup="readme">

								<h1 id="add"><code>.add()</code></h1>
<blockquote>
  <p>The <code>timeline.add()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to add an <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> to the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.add(animation);</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain a timeline instance and call <code>.add()</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> animation  = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});

<span class="hljs-comment">// Add</span>
timeline.add(animation);</code></pre>

							</div>
						</template>

						<template name="cancel">
							<div exportgroup="readme">

								<h1 id="cancel"><code>.cancel()</code></h1>
<blockquote>
  <p>The <code>timeline.cancel()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to cancel all animations in the timeline. If there are <em>oncancel</em> handlers, they are called. <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added after this call are canclled immediately.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.cancel(except = []);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.cancel()</code>.</p>
<pre><code class="hljs js language-js">timeline.cancel();</code></pre>

							</div>
						</template>

						<template name="clear">
							<div exportgroup="readme">

								<h1 id="clear"><code>.clear()</code></h1>
<blockquote>
  <p>The <code>timeline.clear()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to clear all animations from off the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.clear(except = []);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.clear()</code>.</p>
<pre><code class="hljs js language-js">timeline.clear();</code></pre>

							</div>
						</template>

						<template name="finish">
							<div exportgroup="readme">

								<h1 id="finish"><code>.finish()</code></h1>
<blockquote>
  <p>The <code>timeline.finish()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to finish all animations in the timeline. If there are <em>onfinish</em> handlers, they are called. <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added after this call are finished immediately.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.finish(except = []);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.finish()</code>.</p>
<pre><code class="hljs js language-js">timeline.finish();</code></pre>

							</div>
						</template>

						<template name="oncancel">
							<div exportgroup="readme">

								<h1 id="oncancel"><code>.oncancel()</code></h1>
<blockquote>
  <p>The <code>timeline.oncancel()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to bind a handler to the 'cancelled' state of all animations in the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.oncancel(callback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>callback</code></strong>: <strong><code>function(element)</code></strong> - The function to call on <em>cancel</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - The DOM element of the animation instance.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Bind an <em>oncancel</em> callback to all animations.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> animation  = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});

<span class="hljs-comment">// Add</span>
timeline.add(animation);

<span class="hljs-comment">// Bind a callback</span>
timeline.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Animation on the &#x27;</span> + el.id + <span class="hljs-string">&#x27; element cancelled!&#x27;</span>);
});

<span class="hljs-comment">// Bind another callback if necessary</span>
timeline.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Try cancel an animation</span>
animation.cancel();</code></pre>

							</div>
						</template>

						<template name="onfinish">
							<div exportgroup="readme">

								<h1 id="onfinish"><code>.onfinish()</code></h1>
<blockquote>
  <p>The <code>timeline.onfinish()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to bind a handler to the 'finished' state of all animations in the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.onfinish(callback);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>callback</code></strong>: <strong><code>function(element)</code></strong> - The function to call on <em>finish</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - The DOM element of the animation instance.</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Bind an <em>onfinish</em> callback to all animations.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> animation  = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});

<span class="hljs-comment">// Add</span>
timeline.add(animation);

<span class="hljs-comment">// Bind a callback</span>
timeline.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Animation on the &#x27;</span> + el.id + <span class="hljs-string">&#x27; element finished!&#x27;</span>);
});

<span class="hljs-comment">// Bind another callback if necessary</span>
timeline.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Try finish an animation</span>
animation.finish();</code></pre>

							</div>
						</template>

						<template name="pause">
							<div exportgroup="readme">

								<h1 id="pause"><code>.pause()</code></h1>
<blockquote>
  <p>The <code>timeline.pause()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to pause all animations in the timeline. <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added after this call are paused immediately.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.pause(except = []);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.pause()</code>.</p>
<pre><code class="hljs js language-js">timeline.pause();</code></pre>

							</div>
						</template>

						<template name="play">
							<div exportgroup="readme">

								<h1 id="play"><code>.play()</code></h1>
<blockquote>
  <p>The <code>timeline.play()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to play all animations in the timeline. <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added after this call are played immediately. This method is promise-based. The promise resolves at the time the animation with the highest timing completes. An animation's total timing withing the timeline could, in addition to its <em>delay</em>, <em>duration</em>, <em>endDelay</em> parameters, be affected by a direct play/play call, or its relative time of entering the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">await</span> timeline.play();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.play()</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline;
timeline.play().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});

<span class="hljs-comment">// Duration: 600ms</span>
timeline.add(<span class="hljs-keyword">new</span> Animation(el1, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Duration: 600ms. But htis will finish in 900ms</span>
    timeline.add(<span class="hljs-keyword">new</span> Animation(el2, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
}, <span class="hljs-number">300</span>);</code></pre>

							</div>
						</template>

						<template name="progress">
							<div exportgroup="readme">

								<h1 id="progress"><code>.progress()</code></h1>
<blockquote>
  <p>The <code>timeline.progress()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Animation</a> instance method is used to get the average percentage progress of all animations in the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> progress = timeline.progress();</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>progress</code></strong>: <strong><code>Number</code></strong> - A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the timeline's calculated timing.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Get the progress of an timeline at 450ms.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline;
timeline.play().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});

<span class="hljs-comment">// Duration: 600ms</span>
timeline.add(<span class="hljs-keyword">new</span> Animation(el1, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Duration: 600ms. But htis will finish in 900ms</span>
    timeline.add(<span class="hljs-keyword">new</span> Animation(el2, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
}, <span class="hljs-number">300</span>);

<span class="hljs-comment">// Total duration of timeline: 900ms</span>
<span class="hljs-comment">// Get the progress of an animation at 450ms.</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(timeline.progress()); <span class="hljs-comment">// About 0.5</span>
}, <span class="hljs-number">450</span>);</code></pre>

							</div>
						</template>

						<template name="remove">
							<div exportgroup="readme">

								<h1 id="remove"><code>.remove()</code></h1>
<blockquote>
  <p>The <code>timeline.remove()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to remove an <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> from the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.remove(animation);</code></pre>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain a timeline instance and call <code>.remove()</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> animation  = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});

<span class="hljs-comment">// Add</span>
timeline.add(animation);

<span class="hljs-comment">// Then remove</span>
timeline.remove(animation);</code></pre>

							</div>
						</template>

						<template name="reverse">
							<div exportgroup="readme">

								<h1 id="reverse"><code>.reverse()</code></h1>
<blockquote>
  <p>The <code>timeline.reverse()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to reverse all animations in the timeline. <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added after this call are reversed immediately. But where the last call to <code>timeline.reverse()</code> restores the timeline to its original direction, <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances added are left as-is.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.reverse(except = []);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Obtain an instance of an ongoing animation and call <code>.reverse()</code>.</p>
<pre><code class="hljs js language-js">timeline.reverse();</code></pre>

							</div>
						</template>

						<template name="seek">
							<div exportgroup="readme">

								<h1 id="seek"><code>.seek()</code></h1>
<blockquote>
  <p>The <code>timeline.seek()</code> method.</p>
</blockquote>
<p>This <a href="/tooling/play-ui/docs/api/ui/classes/Timeline">Timeline</a> instance method is used to seek to a percentage point in all animations in the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">timeline.seek(point[, except = []]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>point</code></strong>: <strong><code>Number</code></strong> - A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of an animation's total timing. Here the total timing is calculated as <code>delay + duration + endDelay</code>.</li>
<li><strong><code>except</code></strong>: <strong><code>Array</code></strong> - An optional list of <a href="/tooling/play-ui/docs/api/ui/classes/Timeline/Animation">Animation</a> instances to excempt.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The <code>Timeline</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Seek an animation to half its total duration.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> animation  = <span class="hljs-keyword">new</span> Animation(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});

<span class="hljs-comment">// Add</span>
timeline.add(animation);

<span class="hljs-comment">// Seek the timeline to half its total duration</span>
timeline.seek(<span class="hljs-number">0.5</span>);</code></pre>

							</div>
						</template>
					</template>

					<template name="UIRect">
						<div exportgroup="readme">

							<h1 id="class-uirect-"><code>class UIRect {}</code></h1>
<p>Instances of this class represent the rendered rectangle of an element in the UI. And a good amount of transformation to this <em>rect</em> is possible.</p>
<h2 id="constructor-NaN">Constructor</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> rect = <span class="hljs-keyword">new</span> UIRectect(props[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>props</code></strong>: <strong><code>Object</code></strong> - Properties with to initalize the instance. These props are set as <em>readonly</em> properties of the instance. Standard properties are: <code>left</code>, <code>top</code>, <code>bottom</code>, <code>right</code>, <code>width</code>, <code>height</code>. Any additional properties are defined as <em><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#description">non-enumerable</a></em> on the instance.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - The directives used during calculation of the given props.</li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>rect.params</code></strong>: <strong><code>Object</code></strong> - (Readonly) The original <code>params</code> object passed to the constructor.</li>
<li><strong><code>rect.offset</code></strong>: <strong><code>Object</code></strong> - (Readonly) A hash of the instance's <code>.left</code> and <code>.top</code> properties.</li>
<li><strong><code>rect.size</code></strong>: <strong><code>Object</code></strong> - (Readonly) A hash of the instance's <code>.width</code> and <code>.height</code> properties.</li>
<li><strong><code>rect[prop]</code></strong>: <strong><code>Any</code></strong> - (Readonly) Any other property (<code>prop</code>) in the original <code>props</code> object passed to the constructor.</li>
</ul>
<h2 id="static-methods">Static Methods</h2>
<h3 id="uirectcalculateelement-params--">UIRect.calculate(element[, params = {}])</h3>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>element</code></strong>: <strong><code>Element</code></strong> - A DOM element.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Directives for the method.<ul>
<li><strong><code>offsetOrigin</code></strong>: <strong><code>Any</code></strong> - This directive is used to specify the offset origin from which to calculate the <em>top/left</em> distances of the rendered rectangle for the element. Three origins can be used:<br />
<code>client</code> - offsets are calculated from the <em>top/left</em> origins of the screen. This is the default offset origin.<br />
<code>page</code> - offsets are calculated from the <em>top/left</em> origins of the page. Specify this origin by setting this directive to the keyword <code>page</code> or <code>document</code>, or to the <em>document</em> object.<br />
<code>offset</code> - offsets are calculated from the <em>top/left</em> origins of the element's <em><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent">offset parent</a></em>. Specify this origin by setting this directive to <code>true</code> or the keyword <code>offset</code>, or to an instance of the element to use as origin (must be an ancestor of the subject element).</li></ul></li>
</ul>
<p><strong>Return</strong></p>
<p><code>UIRect</code> - An instance of <em>UIRect</em>.</p>
<h2 id="instance-methods">Instance Methods</h2>
<h3 id="rectintersectionwith"><code>rect.intersectionWith()</code></h3>
<h3 id="rectunionwith"><code>rect.unionWith()</code></h3>
<h3 id="rectanglewith"><code>rect.angleWith()</code></h3>
<h3 id="rectproximitywith"><code>rect.proximityWith()</code></h3>
<h3 id="rectrotationto"><code>rect.rotationTo()</code></h3>
<h3 id="rectscaleto"><code>rect.scaleTo()</code></h3>
<h3 id="recttranslationto"><code>rect.translationTo()</code></h3>

						</div>
					</template>
				</template>

				<template name="custom-events">
					<div exportgroup="readme">

						<h1 id="custom-events">Custom Events</h1>
<p>Play UI's event system can be hooked into to provide custom event implementations. For example, its <em>tripletap</em>, <em>doubletap</em>, and <em>singletap</em> gestures are custom implementations/variations of the <em>tap</em> gesture. But, a custom event can be as simple as an alias for another event. Play UI makes everything easy!</p>
<p>To create a custom event, import the <code>CustomEvents</code> object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { CustomEvents } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { CustomEvents } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<p>To create an alias of an existing event:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Simply map the custom event name to an existing event name</span>
CustomEvents.hit = <span class="hljs-string">&#x27;tap&#x27;</span>;

<span class="hljs-comment">// Now we can bind to the &quot;hit&quot; event instead of &quot;tap&quot;</span>
$(<span class="hljs-built_in">document</span>.body).on(<span class="hljs-string">&#x27;hit&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type);
})</code></pre>
<p>To create an advanced custom event implementation, provide a class with two methods: <code>setup()</code> and <code>teardown()</code>. The <code>setup()</code> method will be called the first time the event is being bound to on the given element. This function will receive certain useful parameters, e.g. the <em>emitter</em> (being the most important). The <code>teardown()</code> method will be called the last time the event is being unbound off the element.</p>
<pre><code class="hljs js language-js">CustomEvents.tick = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-comment">// When the fisrt listenr of this event</span>
    <span class="hljs-comment">// is attached to the element, we start ticking</span>
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">el, type, emitter, hammertime</span>)</span> {
        <span class="hljs-built_in">this</span>.el = el;
        <span class="hljs-built_in">this</span>.type = type;
        <span class="hljs-built_in">this</span>.hammertime = hammertime;
        <span class="hljs-built_in">this</span>.interval_id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            emitter.call();
        }, <span class="hljs-number">100</span>);
    }

    <span class="hljs-comment">// When the last listener of this</span>
    <span class="hljs-comment">// event is removed, no need to keep ticking</span>
    <span class="hljs-function"><span class="hljs-title">teardown</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.interval_id);
    }
};

<span class="hljs-comment">// Now we can bind to the &quot;tick&quot; event</span>
$(<span class="hljs-built_in">document</span>.body).on(<span class="hljs-string">&#x27;tick&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type);
});</code></pre>

					</div>
				</template>

				<template name="off">
					<div exportgroup="readme">

						<h1 id="off"><code>.off()</code></h1>
<p>This method is used to unbind event or gesture handlers previously bound to an element using <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all listeners bound to the following event name</span>
<span class="hljs-comment">// regardless of the event handler</span>
$(el).off(eventName);

<span class="hljs-comment">// Unbind the listener bound with the following event handler  </span>
$(el).off(eventName, originalHandler);

<span class="hljs-comment">// Unbind the listener bound with the following event handler and tag </span>
$(el).off(eventName, originalHandler, {<span class="hljs-attr">tags</span>:[...originalTags]});

<span class="hljs-comment">// Unbind the listener bound with the following tag </span>
<span class="hljs-comment">// regardless of the event handler</span>
$(el).off(eventName, <span class="hljs-literal">null</span>, {<span class="hljs-attr">tags</span>:[...originalTags]});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>eventName</code></strong>: <strong><code>String</code></strong> - The event or gesture name.</li>
<li><strong><code>originalHandler</code></strong>: <strong><code>Function</code></strong> - The handler function originally used with <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a>.</li>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional parameters.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Unbind a specific listener bound to <em>doubletap</em>.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-built_in">document</span>.body).off(<span class="hljs-string">&#x27;doubletap&#x27;</span>, originalHandler);</code></pre>
<p>Unbind all listeners bound to <em>doubletap</em>.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-built_in">document</span>.body).off(<span class="hljs-string">&#x27;doubletap&#x27;</span>);</code></pre>
<hr />
<h2 id="matching-by-tags">Matching By Tags</h2>
<p>The <code>params.tags</code> parameter can be used to match listeners that were <a href="/tooling/play-ui/docs/api/ui/on#tagging-a-listener">tagged</a> by the <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a> method.</p>
<pre><code class="hljs js language-js">$(el).off(eventName, originalHandler, {<span class="hljs-attr">tags</span>:[<span class="hljs-string">&#x27;#tag&#x27;</span>]});</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.off()</code> instance method is internally based on the standalone <code>ui/off()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { off } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { off } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="on">
					<div exportgroup="readme">

						<h1 id="on"><code>.on()</code></h1>
<p>This method is used to bind event or gesture handlers to an element. This works like the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"><code>EventTarget.addEventListener()</code></a> function but adds support for user gestures and custom event implementation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> listener = $(el).on(eventName, handler[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>eventName</code></strong>: <strong><code>String</code></strong> - The event or gesture name.</p></li>
<li><p><strong><code>handler</code></strong>: <strong><code>function(event)</code></strong> - The handler function.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>event</code></strong>: <strong><code>Object</code></strong> - An <a href="/tooling/play-ui/docs/api/ui/classes/Event">Event</a> object.</li></ul></li>
<li><p><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Additional parameters.</p></li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>listener</code></strong>: <strong><code>Listener</code></strong> - An instance of <a href="/tooling/play-ui/docs/api/ui/classes/Listener">Listener</a>.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Handle gesture events.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-built_in">document</span>.body).on(<span class="hljs-string">&#x27;doubletap&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;You doubletapped me!&#x27;</span>, event.details);
});</code></pre>
<p>Try using the <a href="/tooling/play-ui/docs/api/ui/trigger"><code>trigger()</code></a> method to fire the event.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Trigger</span>
$(<span class="hljs-built_in">document</span>.body).trigger(<span class="hljs-string">&#x27;doubletap&#x27;</span>);
<span class="hljs-comment">// And we can add details</span>
$(<span class="hljs-built_in">document</span>.body).trigger(<span class="hljs-string">&#x27;doubletap&#x27;</span>, {<span class="hljs-attr">time</span>:<span class="hljs-number">0</span>});</code></pre>
<hr />
<h2 id="tagging-a-listener">Tagging a Listener</h2>
<p>The <code>params.tags</code> parameter can be used to tag a listener. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be associated with the <em>listener</em> for later use. See tags in action using the <a href="/tooling/play-ui/docs/api/ui/off#matching-by-tags"><code>.off()</code></a> method.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> listener = $(el).on(eventName, handler, {<span class="hljs-attr">tags</span>:[<span class="hljs-string">&#x27;#tag&#x27;</span>]});</code></pre>
<p>Programmatically manipulate the returned <em>listener</em> object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Synthetically trigger the listener</span>
listener.fire({
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;doubletap&#x27;</span>,
});

<span class="hljs-comment">// Disconnect the listener</span>
listener.disconnect();</code></pre>
<h2 id="gestures">Gestures</h2>
<p>PlayUI uses the <a href="https://hammerjs.github.io/">Hammer.js</a> gesture library to support the following gestures out of the box. For details of these gestures, see the <em>Hammer.js</em> documentation.</p>
<ul>
<li><strong>press</strong>: press, pressup</li>
<li><strong>rotate</strong>: rotate, rotatestart, rotatemove, rotateend, rotatecancel</li>
<li><strong>pinch</strong>: pinch, pinchstart, pinchmove, pinchend, pinchcancel, pinchin, pinchout</li>
<li><strong>pan</strong>: pan, panstart, panmove, panend, pancancel, panleft, panright, panup, pandown</li>
<li><strong>swipe</strong>: swipe, swipeleft, swiperight, swipeup, swipedown</li>
<li><strong>tap</strong>: tap, (by custom extension: tripletap, doubletap, singletap)</li>
</ul>
<p>Be sure to include Hammer.js on your page before trying to observe gestures.</p>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.on()</code> instance method is internally based on the standalone <code>ui/on()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { on } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { on } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="play">
					<div exportgroup="readme">

						<h1 id="play"><code>.play()</code></h1>
<p>This method is used to create and play an animation. This method is promise-based.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">await</span> $(el).play(effect[, timing = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>effect</code></strong>: <strong><code>Array|Object|String</code></strong> - The effect to play. See <a href="/tooling/play-ui/docs/api/ui/classes/Animation#parameters">Animation</a>.</li>
<li><strong><code>timing</code></strong>: <strong><code>Object</code></strong> - Options for the animation. See <a href="/tooling/play-ui/docs/api/ui/classes/Animation#parameters">Animation</a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>this</code></strong> - The Play UI instance.</li>
</ul>
<h3 id="usage">Usage</h3>
<p><strong>Play from Standard Keyframes.</strong> Below, we fade out an element using an array of keyframes.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);
$(el).play([{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then($el =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<p><strong>Play a CSS Transition.</strong> Below, we fade out an element by simply specifying a <em>end-state</em> keyframe. The starting keyframe for the animation is automatically derived from the element's current state.</p>
<pre><code class="hljs js language-js">$(el).play({<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then($el =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<p><strong>Play a CSS Animation Name.</strong> Below, we fade out an element using an animation defined in the document's stylesheet.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

<span class="hljs-keyword">@keyframes</span> fadeout {
  <span class="hljs-number">0%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;}
  <span class="hljs-number">100%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;}
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">$(el).play(<span class="hljs-string">&#x27;fadeout&#x27;</span>, {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then($el =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.play()</code> instance method is internally based on the standalone <code>ui/play()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { play } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { play } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="rect">
					<div exportgroup="readme">

						<h1 id="rect"><code>.rect()</code></h1>
<p>This method is used to obtain the rendered rectangle of an element in the UI for manipualtion. It is an alias of the <a href="/tooling/play-ui/docs/api/ui/classes/UIRect#uirectcalculateelement-params--">UIRect.calculate()</a> function.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> rect = $(el).rect(params = {});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>params</code></strong>: <strong><code>Object</code></strong> - Directives for the method. See <a href="/tooling/play-ui/docs/api/ui/classes/UIRect#">UIRect.calculate()</a>.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>rect</code></strong>: <strong><code>UIRect</code></strong> - An instance of <a href="/tooling/play-ui/docs/api/ui/classes/UIRect">UIRect</a>.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Get the <em>rect</em> of a button element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> rect = $(<span class="hljs-string">&#x27;button&#x27;</span>).rect();</code></pre>
<p>Manipulate the <em>rect</em>.</p>
<pre><code class="hljs js language-js"></code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.rect()</code> instance method is internally based on the standalone <code>ui/rect()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { rect } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { rect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>

				<template name="trigger">
					<div exportgroup="readme">

						<h1 id="trigger"><code>.trigger()</code></h1>
<p>This method is used to trigger event or gesture handlers previously bound to an element using <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> event = $(el).trigger(eventName[, details = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>eventName</code></strong>: <strong><code>String</code></strong> - The event or gesture name.</li>
<li><strong><code>details</code></strong>: <strong><code>Object</code></strong> - Custom data to pass to the fired event handlers.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><strong><code>event</code></strong>: <strong><code>Event</code></strong> - An instance of <a href="/tooling/play-ui/docs/api/ui/classes/Event">Event</a>.</li>
</ul>
<h3 id="usage">Usage</h3>
<p>Programmatically fire gesture handlers.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> event = $(<span class="hljs-built_in">document</span>.body).trigger(<span class="hljs-string">&#x27;doubletap&#x27;</span>, {<span class="hljs-attr">time</span>:<span class="hljs-number">0</span>});</code></pre>
<p>Inspect the returned <em>event</em> object to see how the fired listeners responded to the event.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">if</span> (event.defaultPrevented) {
    <span class="hljs-comment">// event.preventDefault() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned false</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.propagationStopped) {
    <span class="hljs-comment">// event.stopPropagation() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned false</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.promises) {
    <span class="hljs-comment">// event.promise() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned a promise</span>
    event.promises.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// When all promises resolve</span>
    }).catch(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// When any of the promises fail</span>
    });
}</code></pre>
<hr />
<h2 id="static-usage">Static Usage</h2>
<p>The <code>.trigger()</code> instance method is internally based on the standalone <code>ui/trigger()</code> function which may be used statically.</p>
<h3 id="import">Import</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> { trigger } = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> { trigger } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<h3 id="syntax-1">Syntax</h3>
<p>See <a href="/tooling/play-ui/docs/overview#use-as-descrete-utilities">the general way to use Play UI's standalone functions</a></p>

					</div>
				</template>
			</template>
		</template>

		<template name="cli">
			<div exportgroup="readme">

				<h1 id="command-line">Command Line</h1>
<p>The Play UI command-line tool.</p>

			</div>

			<template name="bundle">
				<div exportgroup="readme">

					<h1 id="play-ui-bundle">Play UI <code>bundle</code></h1>
<p>The <strong><code>playui bundle</code></strong> command is used to automatically bundle static HTML files from the filesystem into <em><a href="/tooling/oohtml/docs/getting-started/overview#html-modules">HTML Modules</a></em>.</p>
<h2 id="overview">Overview</h2>
<p>Here, each directory will represent a <em>module</em> element and the files within it will be the module's exports. We will take the following directory structure as an example:</p>
<pre><code class="hljs html language-html">project-root
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The goal is to translate the above layout into the following <em>module</em> structure and get it written to a single file that can be linked to:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;views&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><em>file: <code>./bundle.html</code></em></p>
<p>You can find a working example of <a href="/tooling/oohtml/docs/learn/examples/spa">a typical module structure</a> right at OOHTML's documentation.</p>
<p>Now, on getting the files into a single bundle, we would next link to it as a remote content for a <code>&lt;template&gt;</code> element - the actual module element - in the main document.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

  <span class="hljs-comment">&lt;!--
  Here, we link to the remote content
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-comment">&lt;!--
  Here our application router would be dynamically pointing to either &quot;home&quot; or &quot;about&quot;
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;main/views/about&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>That said, lets go on to bundle.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui bundle</code></strong></p>
</blockquote>
<p>Navigate to <code>project-root</code> and run <strong><code>playui bundle</code></strong>. Two files should be reported bundled. </p>
<p><html-import name="playui-bundle-1" template="page/tooling/play-ui/docs/cli/bundle"></html-import></p>
<p>Remote content is now ready at <code>./bundle.html</code>!</p>
<p>Now, beyond this point are so many other things we can do! And here is where a few configurations come in!</p>
<p>Run <strong><code>playui config bundler</code></strong> to walk down the options.</p>
<blockquote>
  <p>On completing the options below, the <strong><a href="/tooling/play-ui/docs/cli/config"><code>playui config</code></a></strong> command will save the configurations to a JSON file at <code>./.webqit/playui-cli/config/bundler.json</code>. Subsequent calls to <strong><code>playui bundle</code></strong> will be based on the saved configurations. And subsequent calls to <strong><code>playui config bundler</code></strong> will pull up the saved configurations for update.</p>
</blockquote>
<h3 id="options">Options</h3>
<h4 id="entry_dir"><code>[ENTRY_DIR]</code></h4>
<p>This specifies the entry point into the filesystem - the <em>source directory</em>. The default value is <code>./</code>, which resolves to the current working directory (CWD) on the terminal.</p>
<p>This is good for pointing the bundler to the actual <em>views (or equivalent)</em> folder in the project directory. E.g. <code>./views</code>. (An absolute path may also be used.)</p>
<p>To specify multiple entry directories, slot in the exact string <code>[name]</code> as a placeholder on a segment in the path. Bundler will loop through all folders at that level in the directory to resolve the placeholder and obtain a final path. Specifying <code>./views/[name]</code> as the entry directory, for example, will equate to running <strong><code>playui bundle</code></strong> on both <code>./views/about</code> and <code>./views/home</code>.</p>
<h4 id="output_file"><code>[OUTPUT_FILE]</code></h4>
<p>This specifies the file name of the output bundle. The default value is <code>./bundle.html</code>, which is resolved relative to <a href="#entry_dir"><code>[ENTRY_DIR]</code></a>.</p>
<p>This is good for directing the output bundle to the actual <em>public (or equivalent)</em> folder of the application. E.g. <code>./public/bundle.html</code>. (An absolute path may also be used.)</p>
<p>Where multiple source directories are specified in the <a href="#entry_dir"><code>[ENTRY_DIR]</code></a> option above, this option will require a <code>[name]</code> placeholder, this time, to specify a unique output file each for the source directories. Specifying <code>./public/[name].bundle.html</code> as the output file, for example, will equate to saving the output bundle of <code>./views/about</code> to <code>./public/about.bundle.html</code>, and the output bundle of <code>./views/home</code> to <code>./public/home.bundle.html</code>.</p>
<h4 id="assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></h4>
<p>This specifies the output directory for images or other assets bundled from the source directory. (See <a href="#bundling-assets">Bundling Assets</a> below.) The default value is <code>./</code>, which is resolved relative to <a href="#entry_dir"><code>[ENTRY_DIR]</code></a>, and which means assets will not be copied to any new location. If set to <em>empty</em>, the same directory as <a href="#output_file"><code>[OUTPUT_FILE]</code></a>'s is used.</p>
<p>This is good for directing assets like images to the actual place in the <em>public (or equivalent)</em> folder of the application. E.g. <code>./public/assets</code>. (An absolute path may also be used.)</p>
<p>This option supports the same <code>[name]</code> placeholder as used in the <a href="#entry_dir"><code>[ENTRY_DIR]</code></a> option, this time, to specify a unique <em>assets storage</em> directory each for the source directories. Specifying <code>./public/assets/[name]</code> as the <em>assets storage</em> path, for example, will equate to saving the assets bundled at <code>./views/about</code> to <code>./public/assets/about</code>, and the assets bundled at <code>./views/home</code> to <code>./public/assets/home</code>.</p>
<h4 id="assets_public_base"><code>[ASSETS_PUBLIC_BASE]</code></h4>
<p>This specifies the HTTP path that maps to <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> in the filesystem. The default value is <code>/</code>, which is assumed to map to the <em>public (or equivalent)</em> folder of the application. The <em><code>src</code> (or equivalent)</em> attribute of every asset bundled will be prefixed with this path.</p>
<p>This is good for aligning the public path for assets with the internal <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> path. E.g. <code>/assets</code>, where <code>[ASSETS_STORAGE_BASE]</code> had been set to <code>./public/assets</code>.</p>
<h4 id="max_data_url_size"><code>[MAX_DATA_URL_SIZE]</code></h4>
<p>This specifies the upper limit of the file size under which to inline the contents of an image file or other asset as <em><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">data URLs</a></em>. (See <a href="#bundling-assets">Bundling Assets</a> below.) The default value is <code>1024</code>, in bytes. Assets smaller than this size will be bundled with <em>data URLs</em>.</p>
<p>This is good for having small image files embed their own content instead of having them create additional HTTP requests on the page.</p>
<h4 id="loaders"><code>[LOADERS]</code></h4>
<p>This specifies an optional list of loaders for the bundling operation. (See <a href="/tooling/play-ui/docs/cli/bundle/loaders">Loaders</a>.) The default value is an empty object <code>{}</code>.</p>
<p>This is good for extending the capabilities of the bundler to custom-load certain file formats that are not natively provided for.</p>
<p>Skip where not apply. Or follow the prompt to interactively specify loaders, optionally along with their arguments or flags. The following options are presented recursively:</p>
<ul>
<li><p><strong><code>[name]</code></strong> - The path to a function, or the name of an installed npm package, that is a <a href="/tooling/play-ui/docs/cli/bundle/loaders">Play UI loader</a>. (The bundler imports loaders using the ES6 <code>import()</code> syntax.)</p>
<p>To refer to the bundler's <a href="/tooling/play-ui/docs/cli/bundle/loaders#built-ins">built-in loaders</a>, like the markdown-to-HTML loader (<a href="/tooling/play-ui/docs/cli/bundle/loaders#md-loader"><code>md-loader</code></a>), simply add the prefix <code>default:</code> to the loader's bare name. E.g. <code>default:md-loader</code>.</p></li>
<li><p><strong><code>[args]</code></strong> - Optional list of parameters (arguments/flags) for a loader - each in name/value pair.</p>
<p>Skip where not apply. Or follow the prompt to interactively specify parameters. The following options are presented recursively:</p>
<ul>
<li><strong><code>[name]</code></strong> - The name of the parameter as required by a loader. E.g. <code>flavor</code> - in the default <a href="/tooling/play-ui/docs/cli/bundle/loaders#md-loader"><code>md-loader</code></a>.</li>
<li><strong><code>[value]</code></strong> - The value of the parameter. E.g. <code>github</code> - for the <code>flavor</code> parameter above.</li></ul></li>
</ul>
<h3 id="advanced-options">Advanced Options</h3>
<h4 id="ignore_folders_by_prefix"><code>[IGNORE_FOLDERS_BY_PREFIX]</code></h4>
<p>This specifies a comma-separated list of prefixes for certain types of folders to ignore. Folders with a name that begins with any of the listed prefixes are ingnored. The default value is an array of one prefix: dot <code>.</code>.</p>
<p>This is good for excluding certain system folders or <em>dot directories</em> like <code>.git</code>. <em>Dot directories</em> are automatically excluded by the default value.</p>
<h4 id="create_outline_file"><code>[CREATE_OUTLINE_FILE]</code></h4>
<p>This specifies whether or not to generate a JSON outline of the bundle. The default value is <code>create</code>. The generated file is named after <a href="#output_file"><code>[OUTPUT_FILE]</code></a>; e.g. <code>./bundle.html.json</code>. Set to <code>create_merge</code> to merge the generated JSON outline with any previously generated one. Set to <em>empty</em> to disable outline generation.</p>
<p>This is good for programmatically traversing the module tree. Simply <code>JSON.parse()</code> the contents of <code>./bundle.html.json</code>.</p>
<h3 id="oohtml-related-options">OOHTML-Related Options</h3>
<h4 id="module_ext"><code>[MODULE_EXT]</code></h4>
<p>This specifies an extended tag name for the module element. This value will be set to the <code>is</code> attribute of the <code>&lt;template&gt;</code> elements generated by the bundler. The is empty by default.</p>
<p>This is good for automatically extending generated <code>&lt;template&gt;</code> elements. A value like <code>special-module</code> will generate <code>&lt;template is="special-module"&gt;&lt;/template&gt;</code> elements. Be sure to take into account the <code>element.template</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<h4 id="module_id_attr"><code>[MODULE_ID_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>module ID</em>. The default value is <code>name</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default module ID attribute</a> in the OOHTML spec.</p>
<p>This should generally only be changed to align with the <code>attr.moduleid</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<h4 id="export_mode"><code>[EXPORT_MODE]</code></h4>
<p>This specifies the syntax for designating the <em>module exports</em> within the generated <code>&lt;template&gt;</code> elements. The default value is <code>attribute</code> which translates to using the <code>exportgroup</code> attribute (or <a href="#export_group_attr"><code>[EXPORT_GROUP_ATTR]</code></a>) to designate <em>module exports</em>. Set to <code>element</code> to use the <code>&lt;export&gt;</code> element (or <a href="#export_element"><code>[EXPORT_ELEMENT]</code></a>) instead.  (See <a href="/tooling/oohtml/docs/spec/html-modules#convention">the two standard convetions</a>.)</p>
<h4 id="export_group_attr"><code>[EXPORT_GROUP_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>export ID</em> in <a href="#export_mode">attribute mode</a>. The default value is <code>exportgroup</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;div exportgroup="export-id"&gt;&lt;/div&gt;</code>.</p>
<p>This should generally only be changed to align with the <code>attr.exportgroup</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>attribute</code>.</p>
</blockquote>
<h4 id="export_element"><code>[EXPORT_ELEMENT]</code></h4>
<p>This specifies the tag name for designating <em>module exports</em> in <a href="#export_mode">element mode</a>. The default value is <code>export</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;export&gt; &lt;div&gt;&lt;/div&gt; &lt;/export&gt;</code></p>
<p>This should generally only be changed to align with the <code>element.export</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>element</code>.</p>
</blockquote>
<h4 id="export_id_attr"><code>[EXPORT_ID_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>export ID</em> in <a href="#export_mode">element mode</a>. The default value is <code>name</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;export name="export-id"&gt; &lt;div&gt;&lt;/div&gt; &lt;/export&gt;</code></p>
<p>This should generally only be changed to align with the <code>element.export</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>element</code>.</p>
</blockquote>
<h2 id="bundling-assets">Bundling Assets</h2>
<p>While HTML modules are created by reading the file's contents, assets, like images, are handled differently. These files are copied from their location into the <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> directory to make them accessible to HTTP requests. An appropriate HTML element that points to this new location is automatically generated as the <em>module export</em> in the bundle. This is illustrated below.</p>
<p>We have an image file at <code>project-root/assets/img</code> and we have set the <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> to <code>./public</code>, and the <a href="#output_file"><code>[OUTPUT_FILE]</code></a> option to <code>./public</code>.</p>
<pre><code class="hljs html language-html">project-root
  │
  ├-- assets
  │ ├-- img
  │   ├-- image1.png
  │
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>On running the <strong><code>playui bundle</code></strong> command, our final directory structure will be…</p>
<pre><code class="hljs html language-html">project-root
  │
  ├-- assets
  │ ├-- img
  │   ├-- image1.png
  │
  ├-- public
  │ ├-- assets
  │ │ ├-- img
  │ │   ├-- image1.png
  │ │
  │ ├-- bundle.html
  │
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>…and an <code>&lt;img&gt;</code> element pointing to the <em>public</em> location of <code>image1.png</code> is added as a <em>module export</em> to the bundle.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;assets&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;img&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;image1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/assets/img/image1.png&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;views&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p>Taking things further, it is possible to bundle small images (or other assets) with inline <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">data URLs</a>. This way, the browser won't have to load them via HTTP request. Cutting down on the number of assets to load should greatly speed up the site's load time.</p>
<p>The Bundler just needs to know under what file size to use the <em>data-URL</em> format. Set the <a href="#max_data_url_size"><code>[MAX_DATA_URL_SIZE]</code></a> option to a size measured in bytes. E.g. <code>2048</code>. Assets below this size will now be bundled in <em>data-URL</em> format.</p>
<p>In the case of <code>image1.png</code> above, the generated <em>module export</em> would look like:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;image1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/png,%89PNG%0D%0A=&quot;</span> /&gt;</span></code></pre>
<h2 id="further-reading">Further Reading</h2>

				</div>

				<template name="loaders">
					<div exportgroup="readme">

						<h1 id="loaders">Loaders</h1>
<p>Play UI loaders are packages that extend the capabilities of the OOHTML Bundler. Play UI comes with certain loaders built-in and also makes it possible to provide custom loaders.</p>
<h2 id="overview">Overview</h2>
<p>Loaders are functions that are called with each file during the bundling process. Multiple loaders are made cascaded and a loader will be expected to call the next. This makes for an awesome processing pipeline for each file being bundled. But it also requires thoughtfulness in the order in which these loaders are specified.</p>
<p>By default, the main Play UI bundler only handles <code>.html</code> files and images (<code>.ico</code>, <code>.png</code>, <code>.jpg</code>, <code>.jpeg</code>, <code>.svg</code>). Then it features built-in loaders that extend the list.</p>
<h2 id="built-ins">Built-Ins</h2>
<h3 id="md-loader"><code>md-loader</code></h3>
<p>The <code>md-loader</code> loader is used to load <code>.md</code> (markdown) files into HTML exports just the way regular HTML files are. It takes an initial step of converting the markdown content into HTML using the <a href="https://github.com/showdownjs/showdown">Showdown</a> library, then goes ahead to add it to the bundle as a <em>module export</em>. Markdown links are automatically resolved to better work as HTML links. A few other transformations are supported through arguments/flags. (Learn more about specifying arguments/flags for a loader <a href="/tooling/play-ui/docs/cli/bundle/#loaders">here</a>.)</p>
<h4 id="argumentsflags">Arguments/Flags</h4>
<p>All parameters are optional.</p>
<ul>
<li><strong><code>base_url</code></strong> - Set this to a value that will be used as the base URL for relative links. This is similar to how the <a href="/tooling/play-ui/docs/cli/bundle/#assets_public_base"><code>[ASSETS_PUBLIC_BASE]</code></a> option works.</li>
<li><strong><code>outline_generation</code></strong> - Set this to a <em>non-empty</em> value to generate a JSON outline of the page's content. The generated outline will show up in the meta data for the file in the bundle's overall <a href="/tooling/play-ui/docs/cli/bundle/#create_outline_file">JSON outline</a>.</li>
<li><strong><code>code_highlighting</code></strong> - Set this to a <em>non-empty</em> value to transform code blocks into stylable markup using the <a href="https://github.com/Bloggify/showdown-highlight">Showdown-Highlight</a> utility. The transformed code blocks are highlighted in the UI on adding any of the <a href="https://highlightjs.org/">Highlight.js</a> CSS to the page.</li>
<li><strong><code>flavor</code></strong> - This equates to any of <a href="https://github.com/showdownjs/showdown#flavors">Showdown's three flavours</a>: <code>original</code>, <code>vanilla</code>, <code>github</code>.</li>
</ul>
<h4 id="other">Other</h4>
<ul>
<li><strong>Markdown Metadata</strong> - By default, <code>md-loader</code> automatically parses any found markdown metadata (defined at the top of the document between ««« and »»» or between --- and ---) into JSON and this will show up in the meta data for the file in the bundle's overall <a href="/tooling/play-ui/docs/cli/bundle/#create_outline_file">JSON outline</a>. Below is an example metadata:</li>
</ul>
<pre><code class="hljs md language-md">  ---
  description: Page description.
  ---
  # Page Title</code></pre>
<ul>
<li><strong>Markdown Tables</strong> - The markdown table syntax is supported by default. Below is an example table:</li>
</ul>
<pre><code class="hljs md language-md">  | h1    |    h2   |      h3 |
  |:------|:-------:|--------:|
  | 100   | [<span class="hljs-string">a</span>][<span class="hljs-symbol">1</span>]  | ![<span class="hljs-string">b</span>][<span class="hljs-symbol">2</span>] |
  | <span class="hljs-emphasis">*foo*</span> | <span class="hljs-strong">**bar**</span> | ~~baz~~ |</code></pre>
<h4 id="usage">Usage</h4>
<p>The <code>md-loader</code> loader is used by specifying <code>default:md-loader</code> in the <a href="/tooling/play-ui/docs/cli/bundle/#loaders"><code>[LOADERS]</code></a> config option.</p>
<h2 id="custom-loaders">Custom Loaders</h2>
<p>Custom Loaders are easy to develop. They are basic functions that recieve the current file being processed along with a few paramters, to return a fully-formed <em>module export</em> markup.</p>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadsCSS</span>(<span class="hljs-params">resource, params, args, recieved, meta, next</span>) </span>{
  <span class="hljs-keyword">if</span> (recieved || !resource.endsWith(<span class="hljs-string">&#x27;.css&#x27;</span>)) {
      <span class="hljs-comment">// Or let the flow continue</span>
      <span class="hljs-keyword">return</span> next(recieved);
  }
  <span class="hljs-comment">// Return a module export format</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;style exportgroup=&quot;&quot;&gt;...&lt;/style&gt;&#x27;</span>;
}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>resource: String</code></strong> - The filename of the resource being processed - relative to the current working directory (CWD).</li>
<li><strong><code>params: Object</code></strong> - The <a href="/tooling/play-ui/docs/cli/bundle/#options"><code>options</code> object</a> that the Bundler was initialized with. It also has an additional property <code>indentation</code> - a number which represents how deep in the source directory the given resource is. This number is <code>0</code> at the root of the source directory.</li>
<li><strong><code>args: Object</code></strong> - The <a href="/tooling/play-ui/docs/cli/bundle/#loaders"><code>args</code> object</a> defined specifically for the loader.</li>
<li><strong><code>recieved: String</code></strong> - The output forwarded (that is, <code>next()</code>ed) by the previous loader in the list, if any.</li>
<li><strong><code>meta: Object</code></strong> - The <em>meta</em> object for the given resource. Properties can be added and they will show up in the meta data for the file in the bundle's overall <a href="/tooling/play-ui/docs/cli/bundle/#create_outline_file">JSON outline</a>.</li>
<li><strong><code>next: Function</code></strong> - A function that forwards control to the next loader in the list, if any, and if none, to the default internal loader. It accpets only one parameter, which is recieved by the next loader on its <code>recieved</code> parameter. (When any value passed this way reaches the internal loader, it is added to the bundle as-is without any further processing of the resource.)</li>
</ul>
<p><strong>Return Value</strong></p>
<p>Loaders are expected to return a valid markup string as the <em>module export</em> for the resource.</p>
<h3 id="error-handling">Error Handling</h3>
<p>Loaders may throw exceptions, they will be gracefully handled, that is, formatted and printed to the console.</p>
<h3 id="usage-1">Usage</h3>
<p>Custom loaders are used by specifying their filename in the <a href="/tooling/play-ui/docs/cli/bundle/#loaders"><code>[LOADERS]</code></a> config option. Loaders installed as an npm package are used by specifying their package name.</p>

					</div>
				</template>

				<img src="/html/tooling/play-ui/docs/cli/bundle/playui-bundle-1.png"  exportgroup="playui-bundle-1" />
			</template>

			<template name="config">
				<div exportgroup="readme">

					<h1 id="play-ui-config">Play UI <code>config</code></h1>
<p>The <strong><code>playui config</code></strong> command is used to configure other Play UI commands or a feature.</p>
<h2 id="overview">Overview</h2>
<p>The <strong><code>playui config</code></strong> command is part of thoughtful strategies to make the developer experience on the command line great. Its sole purpose is to provide an interactive way to configure flags for other commands and to persist such configurations. It is indeed painstaking and error-prone to write commands with a long list of flags each time. The <strong><code>playui config</code></strong> command will eliminate this for you.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui config &lt;command&gt;</code></strong> - where <code>&lt;command&gt;</code> is any of the other <a href="/tooling/play-ui/docs/cli">Play UI commands</a>, or the ellipsis <code>...</code>, which lets you pick from a list.</p>
</blockquote>
<p><em>Config</em> will walk you through the configuration options for the specified command and save your configurations for repeat use. (Configurations are generally saved to a JSON file in the project-relative directory: <code>./.webqit/playui-cli/config/</code>, except as otherwise stated in the documentation for a specific command.) Now, subsequent calls to <strong><code>playui config &lt;command&gt;</code></strong> will pull up the saved configurations for update. But, config files may also be updated, or even created, by hand.</p>
<p>To try, run <strong><code>playui config ...</code></strong>, pick a command from the list and follow the prompt. Be sure to consult the documentation for a command to achieve good configurations.</p>

				</div>
			</template>

			<template name="help">
				<div exportgroup="readme">

					<h1 id="play-ui-help">Play UI <code>help</code></h1>
<p>The <strong><code>playui help</code></strong> command is used to show available Play UI commands.</p>
<h2 id="overview">Overview</h2>
<p>Remembering things is hard. Run the <strong><code>playui help</code></strong> command anytime to show a list of available commands.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui help</code></strong>.</p>
</blockquote>
<p><html-import name="playui-help" template="page/tooling/play-ui/docs/cli/help"></html-import></p>
<p>Refer to the documentation of the command you want to use.</p>

				</div>

				<img src="/html/tooling/play-ui/docs/cli/help/playui-help.png"  exportgroup="playui-help" />
			</template>
		</template>

		<template name="getting-started">
			<div exportgroup="readme">

				<h1 id="getting-started">Getting Started</h1>
<p>The Play UI JavaScript library offers a succinct API for working with the DOM and UI. </p>

			</div>

			<template name="download">
				<div exportgroup="readme">

					<h1 id="download-options">Download Options</h1>
<h2 id="play-ui-javascript">Play UI JavaScript</h2>
<p>The Play UI JavaScript library can be used either from a CDN or as an npm package.</p>
<h3 id="option-1-from-a-cdn">Option 1: From a CDN</h3>
<p>Add the following script tag to your page to include the all-in-one Play UI module:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/playui-js/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>The above tag loads Play UI into a global "WebQit" object.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">window</span>.WebQit.$;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="option-2-as-an-npm-package">Option 2: As an npm Package</h3>
<p>With <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">npm available on your terminal</a>, run the following command to install Play UI:</p>
<pre><code class="hljs text language-text">$ npm i @webqit/playui-js</code></pre>
<p>Import and initialize the installed package:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import the initializer</span>
<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js&#x27;</span>;
<span class="hljs-comment">// Initialize</span>
<span class="hljs-keyword">const</span> $ = PlayUI();</code></pre>
<p>And you can selectively import Play UI's descrete parts to streamline your imports to your needs. The <a href="/tooling/play-ui/docs/api">API reference</a> has the <em>import</em> syntax for each of Play UI's functions. For example:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import a function...</span>
<span class="hljs-keyword">import</span> { htmlSync <span class="hljs-keyword">as</span> html } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/dom/index.js&#x27;</span>;

<span class="hljs-comment">// Supply an element as first argument...</span>
html(selector, <span class="hljs-string">&#x27;Play away!&#x27;</span>);</code></pre>
<p>Details are in the <a href="/tooling/play-ui/docs/getting-started/overview#use-as-descrete-utilities">Quick Start</a> guide.</p>
<h2 id="play-ui-command-line">Play UI Command Line</h2>
<p>The Play UI Command Line Interface is available as an npm package.</p>
<p>With <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">npm available on your terminal</a>, run the following command to install Play UI CLI as a <em>dev dependency</em> to your project:</p>
<pre><code class="hljs text language-text">$ npm i -g @webqit/playui-cli --save-dev</code></pre>
<p>The <code>-g</code> flag makes it a global installation. It makes the <code>playui</code> command available from any location on your terminal. Omit this flag to install Play UI CLI to just your project directory.</p>
<p>To test, run <a href="/tooling/play-ui/docs/cli/help"><code>playui help</code></a>; an overview of available commands will be shown.</p>
<h2 id="next-steps">Next Steps</h2>
<p>The <a href="/tooling/play-ui/docs/api">API Reference</a> or the <a href="/tooling/play-ui/docs/cli">Command Line Reference</a>.</p>

				</div>
			</template>

			<template name="overview">
				<div exportgroup="readme">

					<h1 id="overview">Overview</h1>
<p>Play UI is a family of tools that brings a <em>utility-based</em> approach and wholistic experience to UI development. This means: full UI authoring capabilities in the liberty and combinational power of standalone functionalities! Take an overview.</p>
<ul>
<li><a href="#play-ui-javascript">Play UI JavaScript</a></li>
<li><a href="#play-ui-command-line">Play UI Command Line</a></li>
</ul>
<blockquote>
  <p>Although they share a family name, these are really independent libraries.</p>
</blockquote>
<h2 id="play-ui-javascript">Play UI JavaScript</h2>
<p>Play UI JavaScript is a resilient, jQuery-inspired, DOM and UI abstraction library. It offers simple, but powerful, JavaScript functions that do a good job at interacting with the DOM and UI, following the most-performant way. And it's a succint API surface you'll love! (<a href="/tooling/play-ui/docs/api/dom/html"><code>.html()</code></a>, <a href="/tooling/play-ui/docs/api/ui/play"><code>.play()</code></a>, <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a>, <a href="/tooling/play-ui/docs/api/ui/off"><code>.off()</code></a>, etc.)</p>
<p>Play UI JavaScript is designed to meet a wide range of usage styles.</p>
<h3 id="use-as-you-would-jqueryhttpsjquerycom">Use as You Would <a href="https://jquery.com">jQuery</a></h3>
<p><a href="/tooling/play-ui/docs/getting-started/download#play-ui-javascript">Include Play UI</a> on any page and use as you would jQuery. Play UI looks and feels just like it!</p>
<p>Simply obtain the <em>constructable Play UI function</em> (<code>$</code>) as shown below.</p>
<p><em>If Play UI was loaded via a script tag:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The constructable function would be available in a global WebQit object</span>
<span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">window</span>.WebQit.$;</code></pre>
<p><em>If Play UI was installed as a package:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// We would first call the initializer to obtain the constructable function</span>
<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js&#x27;</span>;
<span class="hljs-keyword">const</span> $ = PlayUI();</code></pre>
<p>Construct instances with the <code>new</code> operator or by calling the function statically.</p>
<p><em>With the new operator:</em></p>
<pre><code class="hljs js language-js">(<span class="hljs-keyword">new</span> $(selector)).html(<span class="hljs-string">&#x27;Some fun!&#x27;</span>);</code></pre>
<p><em>Statically:</em></p>
<pre><code class="hljs js language-js">$(selector).html(<span class="hljs-string">&#x27;Some fun!&#x27;</span>);</code></pre>
<p>Now, while total parity with jQuery's design isn't the goal, there exists good similarity: <a href="/tooling/play-ui/docs/api/dom/html"><code>.html()</code></a>, <a href="/tooling/play-ui/docs/api/dom/append"><code>.append()</code></a>, <a href="/tooling/play-ui/docs/api/dom/prepend"><code>.prepend()</code></a>, <a href="/tooling/play-ui/docs/api/dom/attr"><code>.attr()</code></a>, <a href="/tooling/play-ui/docs/api/css/css"><code>.css()</code></a>, <a href="/tooling/play-ui/docs/api/app/data"><code>.data()</code></a>, <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a>, <a href="/tooling/play-ui/docs/api/ui/off"><code>.off()</code></a>, <a href="/tooling/play-ui/docs/api/ui/trigger"><code>.trigger()</code></a>.</p>
<h3 id="use-with-server-side-dom-instances">Use With Server-Side DOM Instances</h3>
<p>Use Play UI on the server with server-side <em>DOM</em> instances, such as the type provided by the <a href="https://github.com/jsdom/jsdom">jsdom</a> library. (Think cases like server-side rendering, web crawling, or just server-side DOM manipulation.) Here is how that could look.</p>
<p><em>Create a <code>window</code> object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Utilities we&#x27;ll need</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-comment">// Import jsdom</span>
<span class="hljs-keyword">import</span> jsdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jsdom&#x27;</span>;

<span class="hljs-comment">// Read the HTML document file from the server</span>
<span class="hljs-keyword">const</span> documentFile = fs.readFileSync(path.resolve(<span class="hljs-string">&#x27;./index.html&#x27;</span>));
<span class="hljs-comment">// Instantiate jsdom so we can obtain the &quot;window&quot; for building Play UI</span>
<span class="hljs-comment">// Detailed instruction on setting up jsdom is available in the jsdom docs</span>
<span class="hljs-keyword">const</span> JSDOM = <span class="hljs-keyword">new</span> jsdom.JSDOM(documentFile.toString());
<span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = JSDOM.window;</code></pre>
<p><em>Initialize Play UI with the window object passed in as its <code>this</code> context. (Note the <code>PlayUI.call()</code> syntax.):</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import Play UI</span>
<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js&#x27;</span>;
<span class="hljs-comment">// Initialize</span>
<span class="hljs-keyword">const</span> $ = PlayUI.call(<span class="hljs-built_in">window</span>);
<span class="hljs-comment">// Query...</span>
$(selector).append(<span class="hljs-string">&#x27;Ready!&#x27;</span>);</code></pre>
<p>The per-window initialization approach makes it possible to have Play UI running in multiple <em>window</em> instances, if we need to, without getting weird behaviours.</p>
<p><em>Tie Play UI to multiple window instances:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> $ = PlayUI.call(window_1);
$(<span class="hljs-string">&#x27;.some-element-in-document-1&#x27;</span>).append(<span class="hljs-string">&#x27;This is for you!&#x27;</span>);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> $$ = PlayUI.call(window_2);
$$(<span class="hljs-string">&#x27;.some-element-in-document-2&#x27;</span>).append(<span class="hljs-string">&#x27;This is for you!&#x27;</span>);</code></pre>
<h3 id="use-as-descrete-utilities">Use as Descrete Utilities</h3>
<p>Play UI's instance methods are internally based on certain core standalone functions which may be imported and used individually. The <a href="/tooling/play-ui/docs/api/ui/on"><code>.on()</code></a> instance method, for example, is based on the standalone <a href="/tooling/play-ui/docs/api/ui/on#static-usage"><code>$.ui.on()</code></a> function.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> ( on ) = $.ui;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> ( on ) <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js/src/ui/index.js&#x27;</span>;</code></pre>
<p><em>Standalone functions have their import syntax documented alongside their instance counterpart.</em></p>
<p>Generally, these standalone functions work the same way as their instance counterpart, except that they initially take an <em>element selector</em> as their first argument - where <em>element selector</em> is any of the input types accepted by the initializer <code>$()</code> function.</p>
<p><em>Compare:</em></p>
<pre><code class="hljs js language-js">$(selector).on(<span class="hljs-string">&#x27;swipeleft&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// Handle swipe gesture</span>
});</code></pre>
<pre><code class="hljs js language-js">on(selector, <span class="hljs-string">&#x27;swipeleft&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// Handle swipe gesture</span>
});</code></pre>
<p>If you were to run your code in a <em>window</em> context other than the global browser window, you could use the <code>&lt;Function&gt;.call()</code> syntax to pass in the <em>window</em> object as the <code>this</code> context for the function.</p>
<pre><code class="hljs js language-js">on.call(<span class="hljs-built_in">window</span>, selector, <span class="hljs-string">&#x27;swipeleft&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// Handle swipe gesture</span>
});</code></pre>
<p>However, functions obtained from the already initialized Play UI object <code>$</code> automatically inherit the <em>window</em> of the Play UI object <code>$</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import Play UI</span>
<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/playui-js&#x27;</span>;
<span class="hljs-comment">// Initialize</span>
<span class="hljs-keyword">const</span> $ = PlayUI.call(<span class="hljs-built_in">window</span>);

<span class="hljs-comment">// Worry no more about a window object</span>
$.ui.on(selector, <span class="hljs-string">&#x27;swipeleft&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// Handle swipe gesture</span>
});</code></pre>
<p><em>Note that functions that are normally chainable as instance methods are not chainable when used statically. But these functions will return whatever was the <code>this</code> context passed in using <code>&lt;Function&gt;.call()</code>.</em></p>
<h3 id="meet-async-ui">Meet Async UI</h3>
<p>Surgically updating the UI is generally a costly operation for browsers. It happens when we write to the DOM and read from it in quick succession in a rendering cycle - causing document reflows, or better put, forced synchronous layout. (But a common word is <em>layout thrashing</em>.) This is covered in detail in <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">this article on Web Fundamentals</a>.</p>
<p>Play UI meets this challenge with a simple timing strategy that keeps UI manipulation in sync with the browser's rendering cycle. To do this, DOM operations are internally held in read/write queues, then executed in read/write batches within each rendering cycle, eliminating the forced synchronous layout problem. This is what happens under the hood with all of the Play UI functions that have the <em>Async</em> suffix; e.g <a href="/tooling/play-ui/docs/api/dom/htmlAsync"><code>htmlAsync()</code></a>. The asynchronous nature of these functions bring them under the term <em>Async UI</em>.</p>
<p>The order of execution of the code below demonstrates the asynchronous nature of these functions.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set content</span>
$(<span class="hljs-built_in">document</span>.body).htmlAsync(<span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: write operation 1&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
$(<span class="hljs-built_in">document</span>.body).htmlAsync().then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: read operation 1&#x27;</span>);
});

<span class="hljs-comment">// Set content</span>
$(<span class="hljs-built_in">document</span>.body).htmlAsync(<span class="hljs-string">&#x27;Hi again&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: write operation 2&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
$(<span class="hljs-built_in">document</span>.body).htmlAsync().then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: read operation 2&#x27;</span>);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Completed: read operation <span class="hljs-number">1</span>
<span class="hljs-attr">Completed</span>: read operation <span class="hljs-number">2</span>
<span class="hljs-attr">Completed</span>: write operation <span class="hljs-number">1</span>
<span class="hljs-attr">Completed</span>: write operation <span class="hljs-number">2</span></code></pre>
<p>Notice that <em>read</em> operations are executed first, then <em>write</em> operations.</p>
<p>Where the order of execution matters, subsequent code could be moved into the <code>then()</code> block each of the <em>async</em> functions.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set content</span>
$(<span class="hljs-built_in">document</span>.body).htmlAsync(<span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: write operation 1&#x27;</span>);
    <span class="hljs-comment">// Get content</span>
    $(<span class="hljs-built_in">document</span>.body).htmlAsync().then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: read operation 1&#x27;</span>);
    });
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Completed: write operation <span class="hljs-number">1</span>
<span class="hljs-attr">Completed</span>: read operation <span class="hljs-number">1</span></code></pre>
<p>Now, where immediate DOM manipulation is still a necessity, the <em>Sync</em> counterpart of the functions above will be just as good.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set content</span>
$(<span class="hljs-built_in">document</span>.body).htmlSync(<span class="hljs-string">&#x27;Hi&#x27;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: write operation 1&#x27;</span>);
<span class="hljs-comment">// Get content</span>
$(<span class="hljs-built_in">document</span>.body).htmlSync();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: read operation 1&#x27;</span>);

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Completed: write operation <span class="hljs-number">1</span>
<span class="hljs-attr">Completed</span>: read operation <span class="hljs-number">1</span></code></pre>
<p>Note that the <em>Sync</em> option is what is implied where no suffix is explicitly used in the function name.</p>
<pre><code class="hljs js language-js">$(<span class="hljs-built_in">document</span>.body).html(<span class="hljs-string">&#x27;Hi&#x27;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Completed: write operation 1&#x27;</span>);</code></pre>
<h2 id="play-ui-command-line">Play UI Command Line</h2>
<p>Play UI Command Line is a utility that lets you move certain aspects of UI authoring to a <em>build process</em>. It offers the automation that allows you to hand-author your UI in absolute free-form mode and then have everything automatically come to shape. And it's an experience at the command line you'll love!</p>
<p>Follow the <a href="/tooling/play-ui/docs/getting-started/download#play-ui-command-line">installation guide</a> to install the Play UI CLI.</p>
<h3 id="html-modules-bundling">HTML Modules Bundling</h3>
<p>Supercharge your UI templating! Author your HTML templates as standalone HTML files and automatically bundle them from the filesystem into shippable <a href="/tooling/oohtml/docs/getting-started/overview#html-modules">HTML modules</a>.</p>
<p>Command: <a href="/tooling/play-ui/docs/cli/bundle"><code>playui bundle</code></a>.</p>
<h3 id="subscript-to-wc-compilation">Subscript-to-WC Compilation</h3>
<p>Taking the liberty with <a href="/tooling/oohtml/docs/getting-started/overview#subscript">Subscript</a>? There's a way to have <em>Subscript</em> come off as Web Components - to give you the best of both worlds, without the difficulty of the latter!</p>
<p>Command: <em>comming soon.</em></p>
<h3 id="html-to-css-aggregation">HTML-to-CSS Aggregation</h3>
<p>Take the process out of writing CSS! Instead of having to have every class already defined in CSS before using in HTML, try a process that automatically writes your CSS classes to file from looking in your HTML!</p>
<p>Command: <em>comming soon.</em></p>
<h2 id="next-steps">Next Steps</h2>
<p>The <a href="/tooling/play-ui/docs/getting-started/download">download options</a>.</p>

				</div>
			</template>
		</template>
	</template>

	
