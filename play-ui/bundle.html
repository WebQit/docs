
	

	<template name="docs">
		<div exportgroup="readme">

			<h1 id="play-ui">Play UI</h1>
<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/play-ui" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/play-ui.svg" alt="NPM version" /></a></span><br />
<span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/play-ui" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/play-ui.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<p><a href="https://github.com/webqit/play-ui">Play UI</a> is the resilient, jQuery-inspired DOM and UI abstraction library, and a modern CSS framework. Play UI is everything for the UI: layout and styling, geometry and animations, events and getures, and more.</p>
<ul>
<li><a href="/tooling/play-ui/docs/js">Play UI JavaScript</a></li>
<li><a href="/tooling/play-ui/docs/css">Play UI CSS</a></li>
</ul>

		</div>

		<template name="css">
			<div exportgroup="readme">

				<h1 id="play-ui-css">Play UI CSS</h1>
<ul>
<li><a href="/tooling/play-ui/docs/css/packages">Packages</a><ul>
<li><a href="/tooling/play-ui/docs/css/packages/play-css">Play CSS</a></li>
<li><a href="/tooling/play-ui/docs/css/packages/plot-css">Plot CSS</a></li>
<li><a href="/tooling/play-ui/docs/css/packages/vivid-css">Vivid CSS</a></li></ul></li>
</ul>

			</div>

			<template name="packages">
				<div exportgroup="readme">

					<h1 id="packages">Packages</h1>
<ul>
<li><a href="/tooling/play-ui/docs/css/packages/packages/play-css">Play CSS</a></li>
<li><a href="/tooling/play-ui/docs/css/packages/packages/plot-css">Plot CSS</a></li>
<li><a href="/tooling/play-ui/docs/css/packages/packages/vivid-css">Vivid CSS</a></li>
</ul>

				</div>

				<template name="play-css">
					<div exportgroup="readme">

						<h1 id="play-css">Play CSS</h1>

					</div>
				</template>

				<template name="plot-css">
					<div exportgroup="readme">

						<h1 id="plot-css">Plot CSS</h1>

					</div>
				</template>

				<template name="vivid-css">
					<div exportgroup="readme">

						<h1 id="vivid-css">Vivid CSS</h1>

					</div>
				</template>
			</template>
		</template>

		<template name="js">
			<div exportgroup="readme">

				<h1 id="play-ui-javascript">Play UI JavaScript</h1>
<ul>
<li><a href="/tooling/play-ui/docs/js/installation">Installation Guide</a></li>
<li><a href="/tooling/play-ui/docs/js/api">API Reference</a></li>
<li><a href="/tooling/play-ui/docs/js/packages">Packages</a><ul>
<li><a href="/tooling/play-ui/docs/js/packages/play-collapsible">Play Collapsible</a></li>
<li><a href="/tooling/play-ui/docs/js/packages/play-icon">Play Icon</a></li>
<li><a href="/tooling/play-ui/docs/js/packages/play-sequence">Play Sequence</a></li></ul></li>
</ul>

			</div>

			<template name="api">
				<div exportgroup="readme">

					<h1 id="api-reference">API Reference</h1>
<h2 id="individual-functions-documentation">Individual Functions Documentation</h2>
<p>Play UI is designed as a collection of standalone functions organized in the following categories.</p>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/dom">The DOM</a> - DOM manipulation utilities.</li>
<li><a href="/tooling/play-ui/docs/js/api/css">CSS</a> - CSS-processing utilities.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation">Animation</a> - Animation utilities.</li>
<li><a href="/tooling/play-ui/docs/js/api/interaction">Interaction</a> - Utilities for binding events and gestures.</li>
<li><a href="/tooling/play-ui/docs/js/api/ui">The UI</a> - Utilities for manipulating the rendered UI.</li>
</ul>
<h2 id="constructible-build-documentation">Constructible Build Documentation</h2>
<p>Play UI is also implemented as a <em>constructible function</em> (like the jQuery function <code>$</code>). An instance can be created by using the <code>new</code> operator or by calling the function statically.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import PlayUI</span>
<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui&#x27;</span>;
<span class="hljs-comment">// Or, if loaded via a script tag...</span>
<span class="hljs-keyword">const</span> PlayUI = <span class="hljs-built_in">window</span>.WQ.PlayUI;

<span class="hljs-comment">// Obtain the constructible function</span>
<span class="hljs-keyword">const</span> $ = PlayUI();

<span class="hljs-comment">// Create an instance with the new operator</span>
<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> $(element);
<span class="hljs-comment">// Or by calling the function statically</span>
<span class="hljs-keyword">let</span> instance = $(element);</code></pre>
<p>Instances of Play UI are built from the same Play UI utility functions above. Each instance method thus has the same function definition as its corresponding utility function.</p>
<p>The <code>.htmlSync()</code> instance method, for example, is based on the utility function at <code>./src/dom/htmlSync.js</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The .htmlSync() instance method</span>
<span class="hljs-keyword">let</span> instance = $(element).htmlSync(content);

<span class="hljs-comment">// --------------------------</span>

<span class="hljs-comment">// The actual standalone htmlSync() function</span>
<span class="hljs-keyword">import</span> htmlSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./src/dom/htmlSync.js&#x27;</span>;
htmlSync(element, content);</code></pre>
<p>Most instance methods, like the one above, return the Play UI instance itself for easy method chaining. The <em>async</em> counterpart of these methods would return a promise that resolves to the Play UI .</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The .htmlAsync() instance method</span>
$(element).htmlAsync(content).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// .somethingElse()</span>
});
<span class="hljs-comment">// Or within an async function</span>
<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">await</span> $(element).htmlAsync(content);

<span class="hljs-comment">// --------------------------</span>

<span class="hljs-comment">// The actual standalone htmlAsync() function</span>
<span class="hljs-keyword">import</span> htmlAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./src/dom/htmlAsync.js&#x27;</span>;
htmlAsync(element, content).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// somethingElse(element)</span>
});
<span class="hljs-comment">// Or within an async function</span>
<span class="hljs-keyword">await</span> htmlAsync(element, content);</code></pre>
<h3 id="dom-manipulation-methods">DOM Manipulation Methods</h3>
<p>DOM manipulation methods. The most of these methods come in a <em>sync</em> and <em>async</em> flavour, and a third unsiffixed flavour that is an alias to the <em>async</em> method.</p>
<h4 id="htmlasync"><code>.htmlAsync()</code></h4>
<p>This method <em>asynchronously</em> sets or gets the HTML content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/htmlasync"><code>dom/htmlAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> sets or gets the HTML content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/htmlasync"><code>dom/htmlAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the HTML content, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).htmlAsync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Get the HTML content, log it to the console when available</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).htmlAsync().then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(content);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/htmlasync"><code>dom/htmlAsync()</code></a> for details.</p>
<h4 id="htmlsync"><code>.htmlSync()</code></h4>
<p>This method <em>synchronously</em> sets or gets the HTML content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/htmlsync"><code>dom/htmlSync()</code></a> function.</p>
<p>This method <em>synchronously</em> sets or gets the HTML content for the current matched element. It uses the <a href="https://github.com/web-native/docs/tree/201e05f348ffbec3ef9e613f36713ffdc10badc9/play-ui/api/dom/htmlsync"><code>dom/htmlSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the HTML content</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).htmlSync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>);

<span class="hljs-comment">// Get the HTML content, log it to the console</span>
<span class="hljs-keyword">let</span> content = $(<span class="hljs-string">&#x27;#el&#x27;</span>).htmlSync();
<span class="hljs-built_in">console</span>.log(content);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/htmlsync"><code>dom/htmlSync()</code></a> for details.</p>
<h4 id="html"><code>.html()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instancehtmlasync"><code>.htmlAsync()</code></a> method.</p>
<h4 id="textasync"><code>.textAsync()</code></h4>
<p>This method <em>asynchronously</em> sets or gets the text content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/textasync"><code>dom/textAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> sets or gets the text content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/textasync"><code>dom/textAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the text content, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).textAsync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Get the text content, log it to the console when available</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).textAsync().then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(content);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/textasync"><code>dom/textAsync()</code></a> for details.</p>
<h4 id="textsync"><code>.textSync()</code></h4>
<p>This method <em>synchronously</em> sets or gets the text content for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/textsync"><code>dom/textSync()</code></a> function.</p>
<p>This method <em>synchronously</em> sets or gets the text content for the current matched element. It uses the <a href="https://github.com/web-native/docs/tree/201e05f348ffbec3ef9e613f36713ffdc10badc9/play-ui/api/dom/textsync"><code>dom/textSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the text content</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).textSync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>);

<span class="hljs-comment">// Get the text content, log it to the console</span>
<span class="hljs-keyword">let</span> content = $(<span class="hljs-string">&#x27;#el&#x27;</span>).textSync();
<span class="hljs-built_in">console</span>.log(content);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/textsync"><code>dom/textSync()</code></a> for details.</p>
<h4 id="text"><code>.text()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instancetextasync"><code>.textAsync()</code></a> method.</p>
<h4 id="appendasync"><code>.appendAsync()</code></h4>
<p>This method <em>asynchronously</em> appends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/appendasync"><code>dom/appendAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> appends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/appendasync"><code>dom/appendAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Append content, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).appendAsync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/appendasync"><code>dom/appendAsync()</code></a> for details.</p>
<h4 id="appendsync"><code>.appendSync()</code></h4>
<p>This method <em>synchronously</em> appends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/appendsync"><code>dom/appendSync()</code></a> function.</p>
<p>This method <em>synchronously</em> appends text content to the current matched element. It uses the <a href="https://github.com/web-native/docs/tree/201e05f348ffbec3ef9e613f36713ffdc10badc9/play-ui/api/dom/appendsync"><code>dom/appendSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Append content</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).appendSync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/appendsync"><code>dom/appendSync()</code></a> for details.</p>
<h4 id="append"><code>.append()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instanceappendasync"><code>.appendAsync()</code></a> method.</p>
<h4 id="prependasync"><code>.prependAsync()</code></h4>
<p>This method <em>asynchronously</em> prepends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/prependasync"><code>dom/prependAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> prepends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/prependasync"><code>dom/prependAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).prependAsync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/prependasync"><code>dom/prependAsync()</code></a> for details.</p>
<h4 id="prependsync"><code>.prependSync()</code></h4>
<p>This method <em>synchronously</em> prepends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/prependsync"><code>dom/prependSync()</code></a> function.</p>
<p>This method <em>synchronously</em> prepends text content to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/prependsync"><code>dom/prependSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).prependSync(<span class="hljs-string">&#x27;Hello player!&#x27;</span>);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/prependsync"><code>dom/prependSync()</code></a> for details.</p>
<h4 id="prepend"><code>.prepend()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instanceprependasync"><code>.prependAsync()</code></a> method.</p>
<h4 id="attrasync"><code>.attrAsync()</code></h4>
<p>This method <em>asynchronously</em> sets or gets an attribute for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>dom/attrAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> sets or gets an attribute for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>dom/attrAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set an attribute, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).attrAsync(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Get an attribute, log it to the console when available</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).attrAsync(<span class="hljs-string">&#x27;name&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>dom/attrAsync()</code></a> for details.</p>
<h4 id="attrsync"><code>.attrSync()</code></h4>
<p>This method <em>synchronously</em> sets or gets an attribute for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>dom/attrSync()</code></a> function.</p>
<p>This method <em>synchronously</em> sets or gets an attribute for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>dom/attrSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set an attribute</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).attrSync(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);

<span class="hljs-comment">// Get an attribute, log it to the console</span>
<span class="hljs-keyword">let</span> value = $(<span class="hljs-string">&#x27;#el&#x27;</span>).attrSync(<span class="hljs-string">&#x27;name&#x27;</span>);
<span class="hljs-built_in">console</span>.log(value);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>dom/attrSync()</code></a> for details.</p>
<h4 id="attr"><code>.attr()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instanceattrasync"><code>.attrAsync()</code></a> method.</p>
<h4 id="classasync"><code>.classAsync()</code></h4>
<p>This method is used to <em>asynchronously</em> set/unset the <em>class</em> attribute or add/remove entries on the <em>class</em> list for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/classasync"><code>dom/classAsync()</code></a> function.</p>
<p>This method is used to <em>asynchronously</em> set/unset the <em>class</em> attribute or add/remove entries on the <em>class</em> list for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/classasync"><code>dom/classAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Add a class, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).classAsync(<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Remove a class</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).classAsync(<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-literal">false</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/classasync"><code>dom/classAsync()</code></a> for details.</p>
<h4 id="classsync"><code>.classSync()</code></h4>
<p>This method is used to <em>synchronously</em> set/unset the <em>class</em> attribute or add/remove entries on the <em>class</em> list for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/classsync"><code>dom/classSync()</code></a> function.</p>
<p>This method is used to <em>synchronously</em> set/unset the <em>class</em> attribute or add/remove entries on the <em>class</em> list for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/classsync"><code>dom/classSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Add a class</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).classAsync(<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Remove a class</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).classAsync(<span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-literal">false</span>);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/classsync"><code>dom/classSync()</code></a> for details.</p>
<h4 id="class"><code>.class()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instanceclassasync"><code>.classAsync()</code></a> method.</p>
<h3 id="css-processing-methods">CSS-Processing Methods</h3>
<p>CSS-processing methods. A few of these methods come in a <em>sync</em> and <em>async</em> flavour, and a third unsiffixed flavour that is an alias to the <em>async</em> method.</p>
<h4 id="cssasync"><code>.cssAsync()</code></h4>
<p>This method <em>asynchronously</em> sets or gets CSS rules for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/css/cssasync"><code>css/cssAsync()</code></a> function.</p>
<p>This method <em>asynchronously</em> sets or gets CSS rules for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/css/cssasync"><code>css/cssAsync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a CSS rule, do something else afterward</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).cssAsync(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});

<span class="hljs-comment">// Get a CSS rule, log it to the console when available</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).cssAsync(<span class="hljs-string">&#x27;color&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/css/cssasync"><code>css/cssAsync()</code></a> for details.</p>
<h4 id="csssync"><code>.cssSync()</code></h4>
<p>This method <em>synchronously</em> sets or gets CSS rules for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/css/csssync"><code>css/cssSync()</code></a> function.</p>
<p>This method <em>synchronously</em> sets or gets CSS rules for the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/css/csssync"><code>css/cssSync()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a CSS rule</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssSync(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>);

<span class="hljs-comment">// Get a CSS rule, log it to the console</span>
<span class="hljs-keyword">let</span> value = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssSync(<span class="hljs-string">&#x27;color&#x27;</span>);
<span class="hljs-built_in">console</span>.log(value);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/css/csssync"><code>css/cssSync()</code></a> for details.</p>
<h4 id="css"><code>.css()</code></h4>
<p>This is an alias of the <a href="/tooling/play-ui/docs/js/api/#instancecssasync"><code>.cssAsync()</code></a> method.</p>
<h4 id="cssinline"><code>.cssInline()</code></h4>
<p>This method returns one or more style properties from the current matched element's style attribute. It uses the <a href="/tooling/play-ui/docs/js/api/css/readinline"><code>css/readInline()</code></a> function.</p>
<p>This method returns one or more style properties from the current matched element's style attribute. It uses the <a href="/tooling/play-ui/docs/js/api/css/readinline"><code>css/readInline()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Read an inline CSS rule</span>
<span class="hljs-keyword">let</span> value = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssInline(<span class="hljs-string">&#x27;color&#x27;</span>);
<span class="hljs-built_in">console</span>.log(value);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/css/readinline"><code>css/readInline()</code></a> for details.</p>
<h4 id="cssstylesheet"><code>.cssStylesheet()</code></h4>
<p>This method returns one or more style properties associated with the current matched element accross the document's stylesheets. It uses the <a href="/tooling/play-ui/docs/js/api/css/readstylesheet"><code>css/readStylesheet()</code></a> function.</p>
<p>This method returns one or more style properties associated with the current matched element accross the document's stylesheets. It uses the <a href="/tooling/play-ui/docs/js/api/css/readstylesheet"><code>css/readStylesheet()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Read a CSS rule from stylesheet</span>
<span class="hljs-keyword">let</span> value = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssStylesheet(<span class="hljs-string">&#x27;color&#x27;</span>);
<span class="hljs-built_in">console</span>.log(value);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/css/readstylesheet"><code>css/readStylesheet()</code></a> for details.</p>
<h4 id="csstransaction"><code>.cssTransaction()</code></h4>
<p>This method establishes a CSS operation on the current matched element that can be rolledback safely. It uses the <a href="/tooling/play-ui/docs/js/api/css/transaction"><code>css/transaction()</code></a> function.</p>
<p>This method establishes a CSS operation on the current matched element that can be rolledback safely. It uses the <a href="/tooling/play-ui/docs/js/api/css/transaction"><code>css/transaction()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtaine a Transaction instance</span>
<span class="hljs-keyword">let</span> transaction = $(<span class="hljs-string">&#x27;#el&#x27;</span>).cssTransaction(<span class="hljs-string">&#x27;color&#x27;</span>);

<span class="hljs-comment">// Create a savepoint - savepoint1</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transaction.save();

<span class="hljs-comment">// Restyle the element</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).css(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>);

<span class="hljs-comment">// Rollback to anypoint after some time</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transaction.rollback(<span class="hljs-number">0</span>);
}, <span class="hljs-number">2000</span>);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/css/transaction"><code>css/transaction()</code></a> for details.</p>
<h3 id="animation-methods">Animation Methods</h3>
<p>Methods for animation.</p>
<h4 id="play"><code>.play()</code></h4>
<p>This method creates and play an animation on the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/animation/play"><code>animation/play()</code></a> function.</p>
<p>This method creates and play an animation on the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/animation/play"><code>animation/play()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Play fadeout</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).play([{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/animation/play"><code>animation/play()</code></a> for details.</p>
<h3 id="event-methods">Event Methods</h3>
<p>Methods for binding events and gestures.</p>
<h4 id="on"><code>.on()</code></h4>
<p>This method binds an event/gesture handler to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/on"><code>interaction/on()</code></a> function.</p>
<p>This method binds an event/gesture handler to the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/on"><code>interaction/on()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Bind a &quot;doubletap&quot; gesture handler</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).on(<span class="hljs-string">&#x27;doubletap&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    alert(<span class="hljs-string">&#x27;You doubletapped me!&#x27;</span>);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/interaction/on"><code>interaction/on()</code></a> for details.</p>
<h4 id="off"><code>.off()</code></h4>
<p>This method unbinds event/gesture handlers oreviously bound using the <a href="#instanceon"><code>.on()</code></a> method. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/off"><code>interaction/off()</code></a> function.</p>
<p>This method unbinds event/gesture handlers oreviously bound using the <a href="./#instanceon"><code>.on()</code></a> method. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/off"><code>interaction/off()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Unbind &quot;doubletap&quot; gesture handlers</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).off(<span class="hljs-string">&#x27;doubletap&#x27;</span>;</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/interaction/off"><code>interaction/off()</code></a> for details.</p>
<h4 id="trigger"><code>.trigger()</code></h4>
<p>This method triggers event/gesture handlers oreviously bound using the <a href="#instanceon"><code>.on()</code></a> method. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/trigger"><code>interaction/trigger()</code></a> function.</p>
<p>This method triggers event/gesture handlers oreviously bound using the <a href="./#instanceon"><code>.on()</code></a> method. It uses the <a href="/tooling/play-ui/docs/js/api/interaction/trigger"><code>interaction/trigger()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Unbind &quot;doubletap&quot; gesture handlers</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).trigger(<span class="hljs-string">&#x27;doubletap&#x27;</span>;</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/interaction/trigger"><code>interaction/trigger()</code></a> for details.</p>
<h3 id="other-methods">Other Methods</h3>
<p>Methods on cross-cutting concerns.</p>
<h4 id="data"><code>.data()</code></h4>
<p>This method sets or gets custom data/values associated with the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/data"><code>dom/data()</code></a> function.</p>
<p>This method sets or gets custom data/values associated with the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/data"><code>dom/data()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a value</span>
<span class="hljs-keyword">let</span> instance = $(<span class="hljs-string">&#x27;#el&#x27;</span>).data(<span class="hljs-string">&#x27;key&#x27;</span>, value);

<span class="hljs-comment">// Get a value</span>
<span class="hljs-keyword">let</span> value = $(<span class="hljs-string">&#x27;#el&#x27;</span>).data(<span class="hljs-string">&#x27;key&#x27;</span>);
<span class="hljs-built_in">console</span>.log(value);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/data"><code>dom/data()</code></a> for details.</p>
<h3 id="observers">Observers</h3>
<p>Observer APIs.</p>
<h4 id="onconnected"><code>.onconnected()</code></h4>
<p>This method observes when the current matched element is added to the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/connectedcallback"><code>dom/connectedCallback()</code></a> function.</p>
<p>This method observes when the current matched element is added to the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/connectedcallback"><code>dom/connectedCallback()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Observe &quot;onconnected&quot;</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).onconnected(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am now connected to the DOM!&#x27;</span>);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/connectedcallback"><code>dom/connectedCallback()</code></a> for details.</p>
<h4 id="ondisonconnected"><code>.ondisonconnected()</code></h4>
<p>This method observes when the current matched element is removed from the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/disconnectedcallback"><code>dom/disonconnectedCallback()</code></a> function.</p>
<p>This method observes when the current matched element is removed from the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/disconnectedcallback"><code>dom/disonconnectedCallback()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Observe &quot;ondisonconnected&quot;</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).ondisonconnected(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am now disconnected from the DOM!&#x27;</span>);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/disconnectedcallback"><code>dom/disconnectedCallback()</code></a> for details.</p>
<h4 id="onmutated"><code>.onmutated()</code></h4>
<p>This method observes when the current matched element is added to, or removed from the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>dom/mutationCallback()</code></a> function.</p>
<p>This method observes when the current matched element is added to, or removed from the document or given context. It uses the <a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>dom/mutationCallback()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Observe &quot;onmutated&quot;</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).onmutated(<span class="hljs-function"><span class="hljs-params">connectedState</span> =&gt;</span> {
    <span class="hljs-comment">// If connectedState === 1, connected else if connectedState === 0, disconnected</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am now &#x27;</span> + (connectedState ? <span class="hljs-string">&#x27;connected to&#x27;</span> : <span class="hljs-string">&#x27;disconnected from&#x27;</span>) + <span class="hljs-string">&#x27; the DOM!&#x27;</span>);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>dom/mutationCallback()</code></a> for details.</p>
<h4 id="onattrchange"><code>.onattrchange()</code></h4>
<p>This method observes changes on attributes of the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrchangecallback"><code>dom/attrChangeCallback()</code></a> function.</p>
<p>This method observes changes on attributes of the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/dom/attrchangecallback"><code>dom/attrChangeCallback()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Observe &quot;onattrchange&quot;</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).onattrchange(<span class="hljs-function"><span class="hljs-params">changes</span> =&gt;</span> {
    changes.forEach(<span class="hljs-function"><span class="hljs-params">change</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(change);
    });
}, <span class="hljs-string">&#x27;attrName&#x27;</span>);</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/attrchangecallback"><code>dom/attrChangeCallback()</code></a> for details.</p>
<h4 id="onresize"><code>.onresize()</code></h4>
<p>This method observes changes on the size of the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/ui/resizecallback"><code>ui/resizeCallback()</code></a> function.</p>
<p>This method observes changes on the size of the current matched element. It uses the <a href="/tooling/play-ui/docs/js/api/ui/resizecallback"><code>ui/resizeCallback()</code></a> function.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Observe &quot;onresize&quot;</span>
$(<span class="hljs-string">&#x27;#el&#x27;</span>).onresize(<span class="hljs-function"><span class="hljs-params">newSize</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(newSize);
});</code></pre>
<p>See <a href="/tooling/play-ui/docs/js/api/ui/resizecallback"><code>ui/resizeCallback()</code></a> for details.</p>

				</div>

				<template name="animation">
					<template name="Ani">
						<div exportgroup="readme">

							<h1 id="the-ani-class">The Ani Class</h1>
<p>This class provides an intuitive way to use the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">Web Animations API (WAAPI)</a>.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> Ani <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/ani/Ani.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> animation = <span class="hljs-keyword">new</span> Ani(el, effect[, timing = {}]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The subject DOM element.</li>
<li><code>effect</code> - <code>Array|Object|String</code>: The effect to play. This could be a standard keyframes array, a CSS object or a stylesheet-based animation name.</li>
<li><code>timing</code> - <code>Object</code>: Options for the animation.<ul>
<li><code>duration</code> - <code>Number</code>: The animation's duration in milliseconds.</li>
<li><code>fill</code> - <code>String</code>: The element's final state on finish; one of <code>none</code> (default), <code>forwards</code>, <code>both</code>.</li>
<li><code>delay</code> - <code>Number</code>: The animation's delay in milliseconds before playing.</li>
<li><code>endDelay</code> - <code>Number</code>: The animation's delay in milliseconds after playing.</li>
<li><code>direction</code> - <code>String</code>: The animation's direction; one of <code>normal</code> (default), <code>reverse</code>, <code>alternate</code>, <code>alternate-reverse</code>.</li>
<li><code>easing</code> - <code>String</code>: The rate of the animation's change over time; one of <code>linear</code> (default), <code>ease</code>, <code>ease-in</code>, <code>ease-out</code>, <code>ease-in-out</code>, or a custom <code>cubic-bezier</code> value like <code>cubic-bezier(0.42, 0, 0.58, 1)</code>.</li>
<li><code>iterations</code> - <code>Number</code>: The number of times the animation should repeat.</li>
<li><code>iterationStart</code> - <code>Number</code>: At what point in the iteration the animation should start.</li>
<li><code>cancelForCss</code> - <code>Boolean</code>: (Specific to Ani) Whether to cancel the animation on finish for subsequent CSS rules on the element to take effect. By default, properties animated with WAAPI cannot be modified with CSS.</li></ul></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
ani.play().then(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<h2 id="features">Features</h2>
<p>Ani provides the following rich set of features over WAAPI:</p>
<ul>
<li><p><strong>Support for single-frame keyframes.</strong> <em>Ani</em> will automatically derive the animation's first frame from the element's current state.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Fade out from current opacity level</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>}, timing);</code></pre></li>
<li><p><strong>Support for CSS keyframes.</strong> <em>Ani</em> can play animations defined in the document's stylesheets. Just mention an animation name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

<span class="hljs-keyword">@keyframes</span> fadeout {
<span class="hljs-number">0%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;}
<span class="hljs-number">100%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;}
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Play the animation from stylesheet</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, <span class="hljs-string">&#x27;fadeout&#x27;</span>, timing);</code></pre></li>
<li><p><strong>Support for <em>auto</em> height and width.</strong> <em>Ani</em> accepts and automacally computes the keyword <em>auto</em> for the width and height properties.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:0px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Expand to the element&#x27;s real size at &quot;auto&quot;</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;auto&#x27;</span>}, timing);</code></pre></li>
<li><p><strong>Automatic units for unit-based CSS properties.</strong> <em>Ani</em> will automacally suffix numeric values with <code>px</code> for properties like <code>top</code> that don't go without units.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Help add &quot;px&quot; to the value for width</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">width</span>: <span class="hljs-number">50</span>}, timing);</code></pre></li>
<li><p><strong>Support for shortform rules.</strong> <em>Ani</em> will accept an object or array for the following shortforms: inset, margin, padding.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Destructure the following object into their individual properties</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">inset</span>: {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">100</span>}}, timing);
<span class="hljs-comment">// Here we actually mean </span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">100</span>}, timing);
<span class="hljs-comment">// ---------------</span>
<span class="hljs-comment">// Destructure the following array into their individual properties</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">inset</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">75</span>, <span class="hljs-number">125</span>,]}, timing);
<span class="hljs-comment">// Here we actually mean </span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">75</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">125</span>}, timing);
<span class="hljs-comment">// All shortforms go in this order: top, right, bottom, left</span></code></pre></li>
<li><p><strong>Sensible default timing parameters.</strong> <em>Ani</em> will automatically create sensible values for the animation timing where not defined.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timing object has the following defaults</span>
{
    <span class="hljs-attr">duration</span>: <span class="hljs-number">400</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">&#x27;both&#x27;</span>,
}</code></pre></li>
<li><p><strong>Other usefull methods.</strong> See below.</p></li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/ready"><code>.ready()</code></a> - Accepts a callback that runs when the animation is created and ready.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/onfinish"><code>.onfinish()</code></a> - Accepts a callback that runs when the animation is completed.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/oncancel"><code>.oncancel()</code></a> - Accepts a callback that runs when the animation is cancelled.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/progress"><code>.progress()</code></a> - Returns the animation's percentage progress at any point during the animation.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/seek"><code>.seek()</code></a> - Seeks to a specific percentage of playback.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/reverse"><code>.reverse()</code></a> - Reverses the animation playback.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/play"><code>.play()</code></a> - Plays the animation and returns a promise that resolves when the animation completes.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/pause"><code>.pause()</code></a> - Pauses the animation.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/finish"><code>.finish()</code></a> - Forces the animation to the finished state.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani/cancel"><code>.cancel()</code></a> - Cancels the animation.</li>
</ul>

						</div>

						<template name="cancel">
							<div exportgroup="readme">

								<h1 id="cancel"><code>.cancel()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method cancels the animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call cancel()</span>
ani.cancel();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Ani</code> - The <code>ani</code> instance.</li>
</ul>

							</div>
						</template>

						<template name="finish">
							<div exportgroup="readme">

								<h1 id="finish"><code>.finish()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method forces the animation to the finished state.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call finish()</span>
ani.finish();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Ani</code> - The <code>ani</code> instance.</li>
</ul>

							</div>
						</template>

						<template name="oncancel">
							<div exportgroup="readme">

								<h1 id="oncancel"><code>.oncancel()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani/oncancel/..">Ani</a> instance method accepts a callback to call when the animation is cancelled for any reason. This is different from WAAPI's <code>oncancel</code> instance property. Unlike that property that makes room for only one callback function, Ani's <code>oncancel()</code> method can be called any number of times with a callback.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call oncancel()</span>
ani.oncancel(callback);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>callback</code> - <code>Function</code>: The function to call on cancel. This function receives the following parameters:<ul>
<li><code>el</code> - <code>HTMLElement</code>: The underlying DOM element playing the animation.</li></ul></li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>});
<span class="hljs-comment">// Bind a callback</span>
ani.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;An animation on the &#x27;</span> + el.id + <span class="hljs-string">&#x27; element just got oncancelled!&#x27;</span>);
});
<span class="hljs-comment">// Bind another callback</span>
ani.oncancel(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-comment">// Do something else</span>
});</code></pre>

							</div>
						</template>

						<template name="onfinish">
							<div exportgroup="readme">

								<h1 id="onfinish"><code>.onfinish()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani/onfinish/..">Ani</a> instance method accepts a callback to call when the animation finishes. This is different from WAAPI's <code>onfinish</code> instance property. Unlike that property that makes room for only one callback function, Ani's <code>onfinish()</code> method can be called any number of times with a callback.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call onfinish()</span>
ani.onfinish(callback);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>callback</code> - <code>Function</code>: The function to call on finish. This function receives the following parameters:<ul>
<li><code>el</code> - <code>HTMLElement</code>: The underlying DOM element playing the animation.</li></ul></li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>});
<span class="hljs-comment">// Bind a callback</span>
ani.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The &#x27;</span> + el.id + <span class="hljs-string">&#x27; element just completed an animation!&#x27;</span>);
});
<span class="hljs-comment">// Bind another callback</span>
ani.onfinish(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    el.remove();
});</code></pre>

							</div>
						</template>

						<template name="pause">
							<div exportgroup="readme">

								<h1 id="pause"><code>.pause()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method pauses the animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call pause()</span>
ani.pause();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Ani</code> - The <code>ani</code> instance.</li>
</ul>

							</div>
						</template>

						<template name="play">
							<div exportgroup="readme">

								<h1 id="play"><code>.play()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani/play/..">Ani</a> instance method plays the animation. Unlike the WAAPI's <code>play()</code> instance method, this method returns a promise.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call play()</span>
ani.play();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Promise</code> - A promise that resolves when the animation completes. The <code>ani</code> instance is returned on resolve.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
ani.play().then(<span class="hljs-function"><span class="hljs-params">ani</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
    <span class="hljs-comment">// Call other methods</span>
    ani.reverse();
});</code></pre>

							</div>
						</template>

						<template name="progress">
							<div exportgroup="readme">

								<h1 id="progress"><code>.progress()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method returns the animation's percentage progress as a number.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call progress()</span>
<span class="hljs-keyword">let</span> progress = ani.progress();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Number</code>: A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the animation's total timing. Here the total timing is calculated as <code>delay + duration + endDelay</code>.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">delay</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
<span class="hljs-comment">// Get the progress at 350ms</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(ani.progress()); <span class="hljs-comment">// About 0.5</span>
}, <span class="hljs-number">350</span>);</code></pre>

							</div>
						</template>

						<template name="ready">
							<div exportgroup="readme">

								<h1 id="ready"><code>.ready()</code></h1>
<p>This <a href="..">Ani</a> instance method accepts a callback to call when the animation is created and ready to play. This is useful as there are cases where the animation is created asynchronously as a performance strategy. For example, when the keyword <code>auto</code> is used for the <em>height</em> or <em>width</em> property, Ani will first resolve those to actual values before creating the actual animation. This happens asynchronously by queueing the operation in <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call ready()</span>
ani.ready(readyCallback[, failureCallback = <span class="hljs-literal">null</span>]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>readyCallback</code> - <code>Function</code>: The function to call on ready. This function receives the following parameters:<ul>
<li><code>waapi</code> - <code>Animation</code>: The underlying WAAPI <code>Animation</code> instance.</li>
<li><code>timing</code> - <code>Object</code>: The instance's timing object.</li>
<li><code>firstFrame</code> - <code>Object</code>: The animation's <em>firstFrame</em> object. Especially useful where this has to be automatically derived by Ani.</li>
<li><code>lastFrame</code> - <code>Object</code>: The animation's <em>lastFrame</em> object. Especially useful where this has to be automatically resolved by Ani.</li></ul></li>
<li><code>failureCallback</code> - <code>Function</code>: A function to call on fatal errors preventing the creation of the animation. This function receives the following parameters:<ul>
<li><code>errorMsg</code> - <code>String</code>: The description of the error.</li></ul></li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:0px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call ready()</span>
<span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;auto&#x27;</span>});
ani.ready(<span class="hljs-function">(<span class="hljs-params">waapi, timing, firstFrame, lastFrame</span>) =&gt;</span> {
    <span class="hljs-comment">// Show the two keyframes</span>
    <span class="hljs-built_in">console</span>.log(firstFrame, lastFrame);
});</code></pre>

							</div>
						</template>

						<template name="reverse">
							<div exportgroup="readme">

								<h1 id="reverse"><code>.reverse()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method reverses the animation direction.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call reverse()</span>
ani.reverse();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Ani</code> - The <code>ani</code> instance.</li>
</ul>

							</div>
						</template>

						<template name="seek">
							<div exportgroup="readme">

								<h1 id="seek"><code>.seek()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instance method seeks to a percentage point in the animation's timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call seek()</span>
ani.seek(to);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>to</code> - <code>Number</code>: A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the animation's total timing. Here the total timing is calculated as <code>delay + duration + endDelay</code>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>Ani</code> - The <code>ani</code> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> ani = <span class="hljs-keyword">new</span> Ani(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">delay</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
<span class="hljs-comment">// The following will seek the animation to 350ms</span>
ani.seek(<span class="hljs-number">0.5</span>);</code></pre>

							</div>
						</template>
					</template>

					<div exportgroup="readme">

						<h1 id="animation">Animation</h1>
<p>The set of DOM APIs for playing animations and controlling timelines.</p>
<p>Modules in this set can be imported individually or collectively.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Import all modules</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ANI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/index.js&#x27;</span>;
<span class="hljs-keyword">let</span> play = ANI.play;

<span class="hljs-comment">// Import a module</span>
<span class="hljs-keyword">import</span> play <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/play.js&#x27;</span>;</code></pre>
<h2 id="api">API</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/animation/play"><code>Animation/play()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Ani">Animation/Ani</a></li>
<li><a href="/tooling/play-ui/docs/js/api/animation/timeline/">Animation/Timeline</a></li>
</ul>

					</div>

					<template name="Timeline">
						<div exportgroup="readme">

							<h1 id="the-timeline-class">The Timeline Class</h1>
<p>This class provides a convenient way to control multiple animation (<a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instances.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> Timeline <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/ani/Timeline.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline(animations[, params = {}]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>animations</code> - <code>Array</code>: Zero or more <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> instances.</li>
<li><code>params</code> - <code>Object</code>: A few parameters for the timeline. (Currently none).</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Play/pause multiple animations in one call.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> Ani <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/ani/Ani.js&#x27;</span>;

<span class="hljs-keyword">let</span> ani1 = <span class="hljs-keyword">new</span> Ani(el1, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>});
<span class="hljs-keyword">let</span> ani2 = <span class="hljs-keyword">new</span> Ani(el2, [{<span class="hljs-attr">width</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">width</span>:<span class="hljs-number">100</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">900</span>});

<span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline([ani1, ani2]);
timeline.pause();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
   timeline.play().then(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end; all animations!&#x27;</span>);
    });
}, <span class="hljs-number">1000</span>);</code></pre>
<h2 id="features">Features</h2>
<ul>
<li><strong>Runtime manipulation of timeline.</strong> <em>Timeline</em> allows you to add/remove animation instances at runtime without altering coordination and synchronization.<br />
<code>js
// Fade out from current opacity level
let timeline = new Timeline([ani1, ani2]);
// Kick off
timeline.play().then(() =&gt; {
    console.log('The end; all animations!');
});
// On the fly
timeline.add(ani3);
timeline.remove(ani1);
// Yet, our play.then() will work as expected
</code></li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/add"><code>.add()</code></a> - Adds a new <em>Ani</em> instance to the timeline.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/remove"><code>.remove()</code></a> - Removes an <em>Ani</em> instance from the timeline.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/onfinish"><code>.onfinish()</code></a> - Accepts a callback that runs when all animations are completed.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/oncancel"><code>.oncancel()</code></a> - Accepts a callback that runs when any of the animations is cancelled.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/progress"><code>.progress()</code></a> - Returns the average percentage progress over all animations at any point during the animation.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/seek"><code>.seek()</code></a> - Seeks each animation to the specific percentage of playback.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/reverse"><code>.reverse()</code></a> - Toggles the playback direction for all animations. Animations added after this call are either reversed automatically or left as-is, depending on whether the last call to <code>.reverse()</code> implied <em>new reverse</em> or <em>reverse to original direction</em>.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/play"><code>.play()</code></a> - Plays all animations and returns a promise that resolves when the animations complete. Animations added after this call are played automatically.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/pause"><code>.pause()</code></a> - Pauses all animations. Animations added after this call are paused automatically.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/finish"><code>.finish()</code></a> - Forces all animations to their finished state. Animations added after this call are forced to finish automatically.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/cancel"><code>.cancel()</code></a> - Cancels all animations. Animations added after this call are canclled automatically.</li>
<li><a href="/tooling/play-ui/docs/js/api/animation/Timeline/clear"><code>.clear()</code></a> - Clears the timeline of all animations. </li>
</ul>

						</div>

						<template name="add">
							<div exportgroup="readme">

								<h1 id="add"><code>.add()</code></h1>
<p>This <a href="..">Timeline</a> instance method adds a new <a href="/tooling/play-ui/docs/js/api/animation/Ani">animation</a> instance to the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call add()</span>
timeline.add(ani);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>ani</code> - <code>Ani</code>: An instance of <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline;
<span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> ani  = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});
<span class="hljs-comment">// Add</span>
timeline.add(ani);</code></pre>

							</div>
						</template>

						<template name="cancel">
							<div exportgroup="readme">

								<h1 id="cancel"><code>.cancel()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method cancels all animations. Animations added after this call are canclled automatically.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call cancel()</span>
timeline.cancel(except = []);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="clear">
							<div exportgroup="readme">

								<h1 id="clear"><code>.clear()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method clears the timeline of all animations. </p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call clear()</span>
timeline.clear(except = []);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="finish">
							<div exportgroup="readme">

								<h1 id="finish"><code>.finish()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method forces all animations to their finished state. Animations added after this call are forced to finish automatically.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call finish()</span>
timeline.finish(except = []);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="oncancel">
							<div exportgroup="readme">

								<h1 id="oncancel"><code>.oncancel()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method accepts a callback to call when any of the animations is canclled.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call oncancel()</span>
ani.oncancel(callback);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>callback</code> - <code>Function</code>: The function to call on finish. This function receives no parameters:</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="onfinish">
							<div exportgroup="readme">

								<h1 id="onfinish"><code>.onfinish()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method accepts a callback to call when the animation with the highest timing completes.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call onfinish()</span>
ani.onfinish(callback);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>callback</code> - <code>Function</code>: The function to call on finish. This function receives no parameters:</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline;
timeline.onfinish().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});
<span class="hljs-comment">// Duration: 600ms</span>
timeline.add(<span class="hljs-keyword">new</span> Ani(el1, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Duration: 400ms. But htis will finish last in the timeline</span>
    timeline.add(<span class="hljs-keyword">new</span> Ani(el2, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
}, <span class="hljs-number">300</span>);</code></pre>

							</div>
						</template>

						<template name="pause">
							<div exportgroup="readme">

								<h1 id="pause"><code>.pause()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method pauses all animations. Animations added after this call are paused automatically.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call pause()</span>
timeline.pause(except = []);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="play">
							<div exportgroup="readme">

								<h1 id="play"><code>.play()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method plays all animations and returns a <em>Promise</em>. Animations added after this call are played automatically.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call play()</span>
timeline.play();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Promise</code> - A Promise that resolves when the animation with the highest timing completes. An animation's total timing withing the timeline could, in addition to its <em>delay</em>, <em>duration</em>, <em>endDelay</em> parameters, be affected by a direct pause/play call, or its relative time of entering the timeline.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> timeline = <span class="hljs-keyword">new</span> Timeline;
timeline.play().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});
<span class="hljs-comment">// Duration: 600ms</span>
timeline.add(<span class="hljs-keyword">new</span> Ani(el1, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Duration: 400ms. But htis will finish last in the timeline</span>
    timeline.add(<span class="hljs-keyword">new</span> Ani(el2, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>: <span class="hljs-number">600</span>}));
}, <span class="hljs-number">300</span>);</code></pre>

							</div>
						</template>

						<template name="progress">
							<div exportgroup="readme">

								<h1 id="progress"><code>.progress()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method returns the average percentage progress over all animations at any point during the animation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call progress()</span>
timeline.progress();</code></pre>
<h3 id="parameters">Parameters</h3>
<p><em>None</em></p>
<h3 id="return">Return</h3>
<ul>
<li><code>Number</code>: A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of the timeline's average progress. Compare the <em>Ani</em> instance's <a href="/tooling/play-ui/docs/js/api/animation/Ani/progress"><code>progress()</code></a> method.</li>
</ul>

							</div>
						</template>

						<template name="remove">
							<div exportgroup="readme">

								<h1 id="remove"><code>.remove()</code></h1>
<p>This <a href="..">Timeline</a> instance method removes an <a href="/tooling/play-ui/docs/js/api/animation/Ani">animation</a> instance from the timeline.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a Timeline instance and call remove()</span>
timeline.remove(ani);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>ani</code> - <code>Ani</code>: An instance of <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The animation instance</span>
<span class="hljs-keyword">let</span> ani  = <span class="hljs-keyword">new</span> Ani(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>});
<span class="hljs-comment">// The timeline</span>
<span class="hljs-keyword">let</span> timeline  = <span class="hljs-keyword">new</span> Timeline([ani]);

<span class="hljs-comment">// Add</span>
timeline.remove(ani);</code></pre>

							</div>
						</template>

						<template name="reverse">
							<div exportgroup="readme">

								<h1 id="reverse"><code>.reverse()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline/reverse/..">Timeline</a> instance method toggles the playback direction for all animations. Animations added after this call are either reversed automatically or left as-is, depending on whether the last call to <code>reverse()</code> implied <em>new reverse</em> or <em>reverse to original direction</em>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call reverse()</span>
timeline.reverse(excepr = []);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>

						<template name="seek">
							<div exportgroup="readme">

								<h1 id="seek"><code>.seek()</code></h1>
<p>This <a href="/tooling/play-ui/docs/js/api/animation/Timeline">Timeline</a> instance method seeks each animation to the specific percentage of playback.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain an Ani instance and call seek()</span>
timeline.seek(to[, except = []]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>to</code> - <code>Number</code>: A number between <code>0</code> and <code>1</code>, representing 0% and 100% respectively, of each animation's total timing. Compare the <em>Ani</em> instance's <a href="/tooling/play-ui/docs/js/api/animation/Ani/seek"><code>seek()</code></a> method.</li>
<li><code>except</code> - <code>Array</code>: An optional list of <em>Ani</em> objects to excempt.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>undefined</code></li>
</ul>

							</div>
						</template>
					</template>

					<template name="play">
						<div exportgroup="readme">

							<h1 id="animationplay"><code>Animation/play()</code></h1>
<p>This function creates and play an animation. It is a convenient way to use the PlayUI's <a href="/tooling/play-ui/docs/js/api/animation/Ani">Ani</a> class.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> play <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/play.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = play(el, effect[, timing = {}]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>effect</code> - <code>Array|Object|String</code>: The effect to play. This could be a standard keyframes array, a CSS object or a stylesheet-based animation name.</li>
<li><code>timing</code> - <code>Object</code>: Options for the animation. See <a href="/tooling/play-ui/docs/js/api/animation/Ani#parameters">Ani</a>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>Promise</code> - A promise that resolves when the animation finishes.</li>
</ul>
<h2 id="usage">Usage</h2>
<h3 id="play-from-standard-keyframes">Play from Standard Keyframes</h3>
<p>Below, we fade out an element with keyframes.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);
play(el, [{<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>}, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}], {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
});</code></pre>
<h3 id="play-a-css-transition">Play a CSS Transition</h3>
<p>Below, we fade out an element by simply specifying a end-state keyframe and letting Ani derive the starting keyframe from the element's current state.</p>
<pre><code class="hljs javascript language-javascript">play(el, {<span class="hljs-attr">opacity</span>:<span class="hljs-number">0</span>}, {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
})</code></pre>
<h3 id="play-a-css-animation-name">Play a CSS Animation Name</h3>
<p>Below, we fade out an element with an animation keyframes defined in the document's stylesheet.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

<span class="hljs-keyword">@keyframes</span> fadeout {
  <span class="hljs-number">0%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;}
  <span class="hljs-number">100%</span> { <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;}
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript">play(el, <span class="hljs-string">&#x27;fadeout&#x27;</span>, {<span class="hljs-attr">duration</span>:<span class="hljs-number">600</span>}).then(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The end!&#x27;</span>);
})</code></pre>

						</div>
					</template>
				</template>

				<template name="css">
					<div exportgroup="readme">

						<h1 id="css">CSS</h1>
<p>The set of DOM APIs for working with CSS.</p>
<p>Modules in this set can be imported individually or collectively.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Import all modules</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> CSS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/index.js&#x27;</span>;
<span class="hljs-keyword">let</span> cssAsync = CSS.cssAsync;

<span class="hljs-comment">// Import a module</span>
<span class="hljs-keyword">import</span> cssAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/cssAsync.js&#x27;</span>;</code></pre>
<h2 id="api">API</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/css/csssync"><code>CSS/cssSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/cssasync"><code>CSS/cssAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/readsync"><code>CSS/readSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/readasync"><code>CSS/readAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/writesync"><code>CSS/writeSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/writeasync"><code>CSS/writeAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/readrendering"><code>CSS/readRendering()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/readinline"><code>CSS/readInline()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/readstylesheet"><code>CSS/readStylesheet()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/css/transaction"><code>CSS/transaction()</code></a></li>
<li>[CSS/TransformRule](TransformRule</li>
</ul>

					</div>

					<template name="TransformRule">
						<div exportgroup="readme">

							<h1 id="the-transformrule-class">The TransformRule Class</h1>
<p>This class is used for parsing and stringifying the CSS transform rule.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> TransformRule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/TransformRule.js&#x27;</span>;</code></pre>
<h2 id="transformruleparse"><code>TransformRule.parse()</code></h2>
<p>This function parses and returns the element's computed transform rule as an object tree.</p>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parse(rule);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>rule</code> - <code>String</code>: A CSS transform rule.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>TransformRule</code> - The parsed transform rule.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">3</span>);
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRule = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>).style.transform;

<span class="hljs-comment">// Set attribute</span>
<span class="hljs-keyword">let</span> transformRuleObject = TransformRule.parse(transformRule);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject);
<span class="hljs-comment">/**
{
    translate: [30, 40],
    sclae: 3,
}
*/</span>

<span class="hljs-comment">//Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// translate(30, 40) scale(3)</span></code></pre>
<p>We can also create a CSS transfrom rule from an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> transformRuleObject = <span class="hljs-keyword">new</span> TransformRule({
    <span class="hljs-attr">translate</span>: [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>],
    <span class="hljs-attr">sclae</span>: <span class="hljs-number">3</span>,
});

<span class="hljs-comment">//Convert to string</span>
<span class="hljs-built_in">console</span>.log(transformRuleObject.toString());
<span class="hljs-comment">// translate(30, 40) scale(3)</span></code></pre>

						</div>
					</template>

					<template name="cssasync">
						<div exportgroup="readme">

							<h1 id="csscssasync">CSS/cssAsync()</h1>
<p>This function sets or returns one or more style properties for the given element. It is a convenient alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/csssync"><code>cssSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>cssAsync()</code> is a promised-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> cssAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/cssAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
<span class="hljs-keyword">let</span> promise = cssAsync(el, ...args);</code></pre>
<h3 id="gt-setunset-inline-styles">&gt; Set/Unset Inline Styles</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single inline property</span>
<span class="hljs-keyword">let</span> promise = cssAsync(el, name, value);
<span class="hljs-comment">// Unset a single inline property</span>
<span class="hljs-keyword">let</span> promise = cssAsync(el, name, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-comment">// Set multiple single inline properties</span>
<span class="hljs-keyword">let</span> promise = cssAsync(el, {
    <span class="hljs-attr">name</span>: value,
});
<span class="hljs-comment">// Unset multiple single inline properties</span>
<span class="hljs-keyword">let</span> promise = cssAsync(el, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The CSS property to set or unset.</li>
<li><code>value</code> - <code>String|Number</code>: The property value to set. When an empty string <code>''</code>, the property is unset from the element's inline CSS.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-get-computed-properties">&gt; Get Computed Properties</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Get a single computed property</span>
cssSync(el, name[, pseudo = <span class="hljs-literal">null</span>]).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with value</span>
});

<span class="hljs-comment">// Get a multiple computed properties</span>
cssSync(el, [name][, pseudo = <span class="hljs-literal">null</span>]).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with values</span>
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String|Array</code>: The CSS property or list of properties to read. When an array, values are returnd as an object.</li>
<li><code>pseudo</code> - <code>String</code>: An optional specifier to read from the element's <code>before</code> or <code>after</code> pseudo elements.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The computed CSS values are returned when the promise resolves. The resolved return type is the same return type at <a href="/tooling/play-ui/docs/js/api/css/csssync#return-1"><code>cssSync() - Return</code></a>.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el&quot;</span> style=<span class="hljs-string">&quot;transform:translate(30, 40); color:red&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
cssSync(el, [<span class="hljs-string">&#x27;transform&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
    <span class="hljs-comment">// Show</span>
    <span class="hljs-built_in">console</span>.log(values);
    <span class="hljs-comment">/**
    {
        transform: {
            translate: [30, 40],
        },
        color: &quot;red&quot;,
    }
    */</span>

    <span class="hljs-comment">// Stringify transform</span>
    <span class="hljs-built_in">console</span>.log(values.transform + <span class="hljs-string">&#x27;&#x27;</span>);
    <span class="hljs-comment">// translate(30, 40)</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>cssAsync()</code> are internally batched to an appropriate queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Change color from red to blue</span>
cssAsync(article, <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Color is now blue&#x27;</span>);
});

<span class="hljs-comment">// Read the current color</span>
cssAsync(article, <span class="hljs-string">&#x27;color&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current color: &#x27;</span> + value);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Current color: red
Color is now blue</code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Change color from red to blue</span>
cssAsync(article, <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Color is now blue&#x27;</span>);
    <span class="hljs-comment">// Read the current color</span>
    cssAsync(article, <span class="hljs-string">&#x27;color&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current color: &#x27;</span> + value);
    });
});
<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Color is now blue
Current color: blue</code></pre>

						</div>
					</template>

					<template name="csssync">
						<div exportgroup="readme">

							<h1 id="csscsssync">CSS/cssSync()</h1>
<p>This function sets or returns one or more style properties for the given element. It is a convenient alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/cssasync"><code>cssAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>cssSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> cssSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/cssSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
cssSync(el, ...args);</code></pre>
<h3 id="gt-setunset-inline-styles">&gt; Set/Unset Inline Styles</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single inline property</span>
<span class="hljs-keyword">let</span> el = cssSync(el, name, value);
<span class="hljs-comment">// Unset a single inline property</span>
<span class="hljs-keyword">let</span> el = cssSync(el, name, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-comment">// Set multiple inline properties</span>
<span class="hljs-keyword">let</span> el = cssSync(el, {
    <span class="hljs-attr">name</span>: value,
});
<span class="hljs-comment">// Unset multiple inline properties</span>
<span class="hljs-keyword">let</span> el = cssSync(el, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The CSS property to set or unset.</li>
<li><code>value</code> - <code>String|Number</code>: The property value to set. When an empty string <code>''</code>, the property is unset from the element's inline CSS.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-get-computed-properties">&gt; Get Computed Properties</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Get a single computed property</span>
<span class="hljs-keyword">let</span> value = cssSync(el, name[, pseudo = <span class="hljs-literal">null</span>]);

<span class="hljs-comment">// Get a multiple computed properties</span>
<span class="hljs-keyword">let</span> values = cssSync(el, [name][, pseudo = <span class="hljs-literal">null</span>]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String|Array</code>: The CSS property or list of properties to read. When an array, values are returnd as an object.</li>
<li><code>pseudo</code> - <code>String</code>: An optional specifier to read from the element's <code>before</code> or <code>after</code> pseudo elements.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>String|Number|Object</code> - The value for a single property. An object is returned specially for the <code>transform</code> rule. This object is easily stringifiable with its <code>toString()</code> method.</li>
<li><code>Object</code> - The values for multiple properties.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el&quot;</span> style=<span class="hljs-string">&quot;transform:translate(30, 40); color:red&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
<span class="hljs-keyword">let</span> values = cssSync(el, [<span class="hljs-string">&#x27;transform&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(values);
<span class="hljs-comment">/**
{
    transform: {
        translate: [30, 40],
    },
    color: &quot;red&quot;,
}
*/</span>

<span class="hljs-comment">// Stringify transform</span>
<span class="hljs-built_in">console</span>.log(values.transform + <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// translate(30, 40)</span></code></pre>

						</div>
					</template>

					<template name="readasync">
						<div exportgroup="readme">

							<h1 id="cssreadasync">CSS/readAsync()</h1>
<p>This function returns one or more style properties for the given element. It is a convenient alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/readsync"><code>readSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>readAsync()</code> is a promised-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> readAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/readAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<p>See <a href="/tooling/play-ui/docs/js/api/css/cssasync#greater-than-get-computed-properties"><code>cssAsync() - Get Computed Properties</code></a></p>

						</div>
					</template>

					<template name="readinline">
						<div exportgroup="readme">

							<h1 id="cssreadinline">CSS/readInline()</h1>
<p>This function returns one or more style properties from the given element's style attribute. These are properties that might have been defined statically or dynamically via JavaScript and are different from the element's computed style.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> readInline <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/readInline.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Get a single inline property</span>
<span class="hljs-keyword">let</span> value = readInline(el, name);

<span class="hljs-comment">// Get a multiple inline properties</span>
<span class="hljs-keyword">let</span> values = readInline(el, [name]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String|Array</code>: The CSS property or list of properties to read. When an array, values are returnd as an object.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>String|Number</code> - The value for a single property.</li>
<li><code>Object</code> - The values for multiple properties.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background-color</span>: yellow;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
<span class="hljs-keyword">let</span> values = readInline(el, [<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(values);
<span class="hljs-comment">/**
{
    backgroundColor: undefined,
    color: &quot;red&quot;,
}
*/</span></code></pre>

						</div>
					</template>

					<template name="readstylesheet">
						<div exportgroup="readme">

							<h1 id="cssreadstylesheet">CSS/readStylesheet()</h1>
<p>This function returns one or more style properties associated with the given element accross the document's stylesheets. These are properties that have been defined statically and are different from the element's computed style.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> readStylesheet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/readStylesheet.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Get a single inline property</span>
<span class="hljs-keyword">let</span> value = readStylesheet(el, name);

<span class="hljs-comment">// Get a multiple inline properties</span>
<span class="hljs-keyword">let</span> values = readStylesheet(el, [name]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String|Array</code>: The CSS property or list of properties to read. When an array, values are returnd as an object.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>String|Number</code> - The value for a single property.</li>
<li><code>Object</code> - The values for multiple properties.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background-color</span>: yellow;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
<span class="hljs-keyword">let</span> values = readStylesheet(el, [<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]);

<span class="hljs-comment">// Show</span>
<span class="hljs-built_in">console</span>.log(values);
<span class="hljs-comment">/**
{
    backgroundColor: &quot;yellow&quot;,
    color: undefined,
}
*/</span></code></pre>

						</div>
					</template>

					<template name="readsync">
						<div exportgroup="readme">

							<h1 id="cssreadsync">CSS/readSync()</h1>
<p>This function returns one or more style properties for the given element. It is a convenient alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/readasync"><code>readAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>readSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> readSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/readSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<p>See <a href="/tooling/play-ui/docs/js/api/css/csssync#greater-than-get-computed-properties"><code>cssSync() - Get Computed Properties</code></a></p>

						</div>
					</template>

					<template name="transaction">
						<div exportgroup="readme">

							<h1 id="csstransaction"><code>CSS/transaction()</code></h1>
<p>This function establishes a CSS operation on the given element that can be rolledback safely. It is a convenient way to use the PlayUI's <a href="/tooling/play-ui/docs/js/api/css/transaction/transaction">Transaction</a> class.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> transaction <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/transaction.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Single property transaction</span>
<span class="hljs-keyword">let</span> transactionInstance = transaction(el, name);

<span class="hljs-comment">// Multiple properties transaction</span>
<span class="hljs-keyword">let</span> transactionInstance = transaction(el, [name]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String|Array</code>: The CSS property or list of properties that should be rolled back after the transaction.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Transaction</code> - The <a href="/tooling/play-ui/docs/js/api/css/transaction/transaction">Transaction</a> instance.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background-color</span>: yellow;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el&#x27;</span>);

<span class="hljs-comment">// Obtaine a Transaction instance</span>
<span class="hljs-keyword">let</span> transactionInstance = transaction(el, [<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]);
<span class="hljs-comment">// Create a savepoint - savepoint1</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transactionInstance.save();

<span class="hljs-comment">// Restyle the element</span>
el.style.color = <span class="hljs-string">&#x27;green&#x27;</span>;
el.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span>;
<span class="hljs-comment">// Create a savepoint - savepoint2</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transactionInstance.save();

<span class="hljs-comment">// Restyle the element again</span>
el.style.color = <span class="hljs-string">&#x27;brown&#x27;</span>;
el.style.backgroundColor = <span class="hljs-string">&#x27;teal&#x27;</span>;
<span class="hljs-comment">// Create a savepoint - savepoint3</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transactionInstance.save();

<span class="hljs-comment">// Rollback to anypoint after some time</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transactionInstance.rollback(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// Now background-color should fallback to yellow</span>
    <span class="hljs-comment">// And color should be back to red</span>
}, <span class="hljs-number">2000</span>);</code></pre>
<p>In the code above, if another part of the app had changed one of those properties, then <em>rollback</em> would have left that property untouched to respect the other code.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtaine a Transaction instance</span>
<span class="hljs-keyword">let</span> transactionInstance = transaction(el, [<span class="hljs-string">&#x27;background-color&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>]);
<span class="hljs-comment">// Create a savepoint - savepoint1</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transactionInstance.save();

<span class="hljs-comment">// Restyle the element again</span>
el.style.color = green;
el.style.backgroundColor = black;
<span class="hljs-comment">// Create a savepoint - savepoint2</span>
<span class="hljs-comment">// We can rollback to this point later</span>
transactionInstance.save();

<span class="hljs-comment">// This is another code setting their own color</span>
<span class="hljs-comment">// after we have saved a rollback point</span>
el.style.color = brown;


<span class="hljs-comment">// Rollback to savepoint2</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Rollback all the way to the element&#x27;s initial state</span>
    transactionInstance.rollback(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// Now background-color should be rolled back to black</span>
    <span class="hljs-comment">// But color will remain brown</span>
}, <span class="hljs-number">2000</span>);</code></pre>

						</div>
					</template>

					<template name="writeasync">
						<div exportgroup="readme">

							<h1 id="csswriteasync">CSS/writeAsync()</h1>
<p>This function sets one or more style properties on the given element. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/writesync"><code>writeSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>writeAsync()</code> is a promised-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> writeAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/writeAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<p>See <a href="/tooling/play-ui/docs/js/api/css/cssasync#greater-than-set-unset-inline-styles"><code>cssAsync() - Set/Unset Inline Styles</code></a></p>

						</div>
					</template>

					<template name="writesync">
						<div exportgroup="readme">

							<h1 id="csswritesync">CSS/writeSync()</h1>
<p>This function sets one or more style properties on the given element. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style"><code>ElementCSSInlineStyle.style</code></a>. It also has special support for vendor-prefixed properties.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/css/writeasync"><code>writeAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>writeSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> writeSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/css/writeSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<p>See <a href="/tooling/play-ui/docs/js/api/css/csssync#greater-than-set-unset-inline-styles"><code>cssAsync() - Set/Unset Inline Styles</code></a></p>

						</div>
					</template>
				</template>

				<template name="dom">
					<div exportgroup="readme">

						<h1 id="the-dom">The DOM</h1>
<p>The set of DOM APIs for traversing and manipulating the DOM.</p>
<p>Below, you will notice PlayUI's radical new approach to the DOM that offers a pair of <strong>synchronous</strong> and <strong>asynchronous</strong> methods for operations that affect the browser's <em>Layout</em>. The <em>asynchronous</em> methods employ a technique that prevents <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">Layout Thrashing</a> to keep the UI at maximum performance. These <em>asynchronous</em> methods are what you want! The <em>synchronous</em> versions would, however, need to go with the <a href="/tooling/play-ui/docs/js/api/dom/reflow"><code>Reflow</code></a> DOM abstraction utility to achieve the same level of performance.</p>
<p>Modules in this set can be imported individually or collectively.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Import all modules</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> DOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/index.js&#x27;</span>;
<span class="hljs-keyword">let</span> select = DOM.select;

<span class="hljs-comment">// Import a module</span>
<span class="hljs-keyword">import</span> select <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/select.js&#x27;</span>;</code></pre>
<h2 id="api">API</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/dom/select"><code>DOM/select()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/selectall"><code>DOM/selectAll()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/el"><code>DOM/el()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/appendsync"><code>DOM/appendSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/appendasync"><code>DOM/appendAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/prependsync"><code>DOM/prependSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/prependasync"><code>DOM/prependAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/htmlsync"><code>DOM/htmlSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/htmlasync"><code>DOM/htmlAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/textsync"><code>DOM/textSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/textasync"><code>DOM/textAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>DOM/attrSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>DOM/attrAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/classsync"><code>DOM/classSync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/classasync"><code>DOM/classAsync()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/data"><code>DOM/data()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/gettextnodes"><code>DOM/getTextNodes()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>DOM/mutationCallback()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/connectedcallback"><code>DOM/connectedCallback()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/disconnectedcallback"><code>DOM/disconnectedCallback()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/dom/attrchangecallback"><code>DOM/attrChangeCallback()</code></a></li>
</ul>

					</div>

					<template name="appendasync">
						<div exportgroup="readme">

							<h1 id="domappendasync">DOM/appendAsync()</h1>
<p>This function appends content to an element. It works exactly the same as <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append"><code>ParentNode.append()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/appendsync"><code>appendSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>appendAsync()</code> is a promise-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> appendAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/appendAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = appendAsync(el[, ...content);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>[String|HTMLElement]</code>: The set of content to append. Each could be a plain text, an HTML/XML markup, or even a DOM node.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">body</span>&gt;&lt;/<span class="hljs-keyword">body</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Append content</span>
appendAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with body</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>appendAsync()</code> are internally batched to a <em>write</em> queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Append content</span>
appendAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Append operation&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current content is: &#x27;</span> + content);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Current content is: 
Append operation</code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Append content</span>
appendAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Append operation&#x27;</span>);
    <span class="hljs-comment">// Get content</span>
    htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current content is: &#x27;</span> + content);
    });
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Append operation
Current content is: Hello world!</code></pre>

						</div>
					</template>

					<template name="appendsync">
						<div exportgroup="readme">

							<h1 id="domappendsync">DOM/appendSync()</h1>
<p>This function appends content to an element. It works exactly the same as <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append"><code>ParentNode.append()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/appendasync"><code>appendAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>appendSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> appendSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/appendSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">appendSync(el[, ...content);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>[String|HTMLElement]</code>: The set of content to append. Each could be a plain text, an HTML/XML markup, or even a DOM node.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">body</span>&gt;&lt;/<span class="hljs-keyword">body</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
<span class="hljs-keyword">let</span> body = appendSync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>);</code></pre>

						</div>
					</template>

					<template name="attrasync">
						<div exportgroup="readme">

							<h1 id="domattrasync">DOM/attrAsync()</h1>
<p>This function sets or gets an element's attribute. It is the shorter alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute"><code>Element.setAttribute()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute"><code>Element.getAttribute()</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a>. It also has special support for list-based attributes like <code>class</code>.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>attrSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>attrAsync()</code> is a promised-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> attrAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/attrAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, requestOrPayload[, valOrMutation = <span class="hljs-literal">null</span>[, subValMutation = <span class="hljs-literal">null</span>]]);</code></pre>
<h3 id="gt-setremove-attribute">&gt; Set/Remove Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single attribute</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, name, value);
<span class="hljs-comment">// Remove a single attribute</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, name, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Set multiple attributes</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, {
    <span class="hljs-attr">name</span>: value,
});
<span class="hljs-comment">// Remove multiple attributes</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, {
    <span class="hljs-attr">name</span>: <span class="hljs-literal">false</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to set or remove.</li>
<li><code>value</code> - <code>String|Boolean</code>: The attribute value to set. When <code>true</code>, the string <code>"true"</code> is set on the attribute. When <code>false</code>, the attribute is unset from the element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-setremove-attribute-entry">&gt; Set/Remove Attribute Entry</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single attribute entry</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, name, entry, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove a single attribute entry</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, name, entry, state === <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Set multiple attribute entries</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, {
    <span class="hljs-attr">name</span>: entry,
}, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove multiple attribute entries</span>
<span class="hljs-keyword">let</span> promise = attrAsync(el, {
    <span class="hljs-attr">name</span>: entry,
}, state === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to modify.</li>
<li><code>entry</code> - <code>String</code>: The text to insert or remove.</li>
<li><code>state</code> - <code>Boolean</code>: The indication of <em>insert</em> or <em>remove</em>. When <code>true</code>, the given text is inserted into the attribute's value list. When <code>false</code>, the given text is removed from the attribute's value list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-get-attribute">&gt; Get Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = attrAsync(el, name);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to read.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target attribute's value is returned when the promise resolves.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">class1</span> <span class="hljs-symbol">class2</span>&quot; <span class="hljs-symbol">role</span>=&quot;<span class="hljs-symbol">article</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> article = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
attrAsync(article, <span class="hljs-string">&#x27;role&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">article</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with article</span>
});

<span class="hljs-comment">// Insert a class entry</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-params">article</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with article</span>
});

<span class="hljs-comment">// Get attribute value</span>
attrAsync(article, <span class="hljs-string">&#x27;role&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with value</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>attrAsync()</code> are internally batched to an appropriate queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Remove class1</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class1&#x27;</span>, <span class="hljs-literal">false</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;class1 removed&#x27;</span>);
});

<span class="hljs-comment">// Read the class attribute</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;classList: &#x27;</span> + value);
});

<span class="hljs-comment">// Remove class2</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class2&#x27;</span>, <span class="hljs-literal">false</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;class2 removed&#x27;</span>);
});

<span class="hljs-comment">// Read the class attribute</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;classList: &#x27;</span> + value);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
classList: class1 class2
<span class="hljs-attr">classList</span>: class1 class2
class1 removed
class2 removed</code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Remove class2</span>
attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class2&#x27;</span>, <span class="hljs-literal">false</span>).then(<span class="hljs-function"><span class="hljs-params">article</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;class2 removed&#x27;</span>);
    <span class="hljs-comment">// Read the class attribute</span>
    attrAsync(article, <span class="hljs-string">&#x27;class&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;classList: &#x27;</span> + value);
    });
});
<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
class2 removed
<span class="hljs-attr">classList</span>: class1</code></pre>

						</div>
					</template>

					<template name="attrchangecallback">
						<div exportgroup="readme">

							<h1 id="domattrchangecallback">DOM/attrChangeCallback()</h1>
<p>This function observes changes on attributes of the given element.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> attrChangeCallback <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/attrChangeCallback.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">attrChangeCallback(el, callback[, filter = []]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The specific element to observe.</li>
<li><code>callback</code> - <code>Function</code>: The callback function that recieves the notification. This callback will be called once for every change with the following arguments.<ul>
<li><code>mutation</code> - <code>MutationEntry</code>: An object representing the mutation that occured.</li></ul></li>
<li><code>filter</code> - <code>Array</code>: (Optional) A more specific list of attributes to observe.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>MutationObserver</code> - The instantiated MutationObserver.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;body&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el1&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;cls1&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/body&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtain an element instance</span>
<span class="hljs-keyword">let</span> el1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el1&#x27;</span>);

<span class="hljs-comment">// Observe</span>
attrChangeCallback(el1, <span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The class attribute has changed.&#x27;</span>, mutation);
});

<span class="hljs-comment">// Start mutating</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    el1.classList.add(<span class="hljs-string">&#x27;cls2&#x27;</span>); <span class="hljs-comment">// The class attribute has changed.</span>
}, <span class="hljs-number">1000</span>);</code></pre>

						</div>
					</template>

					<template name="attrsync">
						<div exportgroup="readme">

							<h1 id="domattrsync">DOM/attrSync()</h1>
<p>This function sets or gets an element's attribute. It is the shorter alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute"><code>Element.setAttribute()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute"><code>Element.getAttribute()</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a>. It also has special support for list-based attributes like <code>class</code>.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>attrAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>attrSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> attrSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/attrSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
attrSync(el, requestOrPayload[, valOrMutation = <span class="hljs-literal">null</span>[, subValMutation = <span class="hljs-literal">null</span>]]);</code></pre>
<h3 id="gt-setremove-attribute">&gt; Set/Remove Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single attribute</span>
<span class="hljs-keyword">let</span> el = attrSync(el, name, value);
<span class="hljs-comment">// Remove a single attribute</span>
<span class="hljs-keyword">let</span> el = attrSync(el, name, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Set multiple attributes</span>
<span class="hljs-keyword">let</span> el = attrSync(el, {
    <span class="hljs-attr">name</span>: value,
});
<span class="hljs-comment">// Remove multiple attributes</span>
<span class="hljs-keyword">let</span> el = attrSync(el, {
    <span class="hljs-attr">name</span>: <span class="hljs-literal">false</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to set or remove.</li>
<li><code>value</code> - <code>String|Boolean</code>: The attribute value to set. When <code>true</code>, the string <code>"true"</code> is set on the attribute. When <code>false</code>, the attribute is unset from the element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-setremove-attribute-entry">&gt; Set/Remove Attribute Entry</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single attribute entry</span>
<span class="hljs-keyword">let</span> el = attrSync(el, name, entry, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove a single attribute entry</span>
<span class="hljs-keyword">let</span> el = attrSync(el, name, entry, state === <span class="hljs-literal">false</span>);

<span class="hljs-comment">// Set multiple attribute entries</span>
<span class="hljs-keyword">let</span> el = attrSync(el, {
    <span class="hljs-attr">name</span>: entry,
}, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove multiple attribute entries</span>
<span class="hljs-keyword">let</span> el = attrSync(el, {
    <span class="hljs-attr">name</span>: entry,
}, state === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to modify.</li>
<li><code>entry</code> - <code>String</code>: The text to insert or remove.</li>
<li><code>state</code> - <code>Boolean</code>: The indication of <em>insert</em> or <em>remove</em>. When <code>true</code>, the given text is inserted into the attribute's value list. When <code>false</code>, the given text is removed from the attribute's value list.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-get-attribute">&gt; Get Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> value = attrSync(el, name);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>name</code> - <code>String</code>: The attribute name to read.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>String</code> - The attribute value.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">class1</span> <span class="hljs-symbol">class2</span>&quot; <span class="hljs-symbol">role</span>=&quot;<span class="hljs-symbol">article</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> article = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);

<span class="hljs-comment">// Set attribute</span>
attrSync(article, <span class="hljs-string">&#x27;role&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>);

<span class="hljs-comment">// Insert a class entry</span>
attrSync(article, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Get attribute value</span>
<span class="hljs-keyword">let</span> value = attrSync(article, <span class="hljs-string">&#x27;role&#x27;</span>);</code></pre>

						</div>
					</template>

					<template name="classasync">
						<div exportgroup="readme">

							<h1 id="domclassasync">DOM/classAsync()</h1>
<p>This function is a convenience function over <a href="/tooling/play-ui/docs/js/api/dom/attrasync"><code>attrAsync()</code></a> for setting/unsetting the <em>class</em> attribute or adding/removing entries on an element's <em>class</em> list.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/classsync"><code>classSync()</code></a>. Unlike the <em>Async</em> counterpart, <code>classAsync()</code> is a promise-based function that runs in a different flow from that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> classAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/classAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
<span class="hljs-keyword">let</span> promise = classAsync(el[, valOrMutation = <span class="hljs-literal">null</span>[, subValMutation = <span class="hljs-literal">null</span>]]);</code></pre>
<h3 id="gt-setremove-the-class-attribute">&gt; Set/Remove the Class Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the class attribute</span>
<span class="hljs-keyword">let</span> el = classAsync(el, classlist);

<span class="hljs-comment">// Remove the class attribute</span>
<span class="hljs-keyword">let</span> promise = classAsync(el, <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>classlist</code> - <code>String|Boolean</code>: Space-delimitted class names. When <code>true</code>, the string <code>"true"</code> is implied. When <code>false</code>, the class attribute is unset from the element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-addremove-class-entry">&gt; Add/Remove Class Entry</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a class entry</span>
<span class="hljs-keyword">let</span> promise = classAsync(el, entry, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove a class entry</span>
<span class="hljs-keyword">let</span> promise = classAsync(el, entry, state === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>entry</code> - <code>String</code>: The classname to insert or remove.</li>
<li><code>state</code> - <code>Boolean</code>: The indication of <em>insert</em> or <em>remove</em>. When <code>true</code>, the given classname is inserted into the aelement's classlist. When <code>false</code>, the given classname is removed from the aelement's classlist.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-get-the-class-attribute">&gt; Get the Class Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = classAsync(el);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The element's classlist is returned as a string when the promise resolves.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">class1</span> <span class="hljs-symbol">class2</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> article = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);

<span class="hljs-comment">// Insert a class entry</span>
classAsync(article, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Get the classlist</span>
classAsync(article).then(<span class="hljs-function"><span class="hljs-params">classlist</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with classlist</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>See <a href="/tooling/play-ui/docs/js/api/dom/attrasync#implementation-note"><code>attrAsync()</code></a></p>

						</div>
					</template>

					<template name="classsync">
						<div exportgroup="readme">

							<h1 id="domclasssync">DOM/classSync()</h1>
<p>This function is a convenience function over <a href="/tooling/play-ui/docs/js/api/dom/attrsync"><code>attrSync()</code></a> for setting/unsetting the <em>class</em> attribute or adding/removing entries on an element's <em>class</em> list.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/classasync"><code>classAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>classSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> classSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/classSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
classSync(el[, valOrMutation = <span class="hljs-literal">null</span>[, subValMutation = <span class="hljs-literal">null</span>]]);</code></pre>
<h3 id="gt-setremove-the-class-attribute">&gt; Set/Remove the Class Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set the class attribute</span>
<span class="hljs-keyword">let</span> el = classSync(el, classlist);

<span class="hljs-comment">// Remove the class attribute</span>
<span class="hljs-keyword">let</span> el = classSync(el, <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>classlist</code> - <code>String|Boolean</code>: Space-delimitted class names. When <code>true</code>, the string <code>"true"</code> is implied. When <code>false</code>, the class attribute is unset from the element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-addremove-class-entry">&gt; Add/Remove Class Entry</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a class entry</span>
<span class="hljs-keyword">let</span> el = classSync(el, entry, state === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Remove a class entry</span>
<span class="hljs-keyword">let</span> el = classSync(el, entry, state === <span class="hljs-literal">false</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>entry</code> - <code>String</code>: The classname to insert or remove.</li>
<li><code>state</code> - <code>Boolean</code>: The indication of <em>insert</em> or <em>remove</em>. When <code>true</code>, the given classname is inserted into the aelement's classlist. When <code>false</code>, the given classname is removed from the aelement's classlist.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-get-the-class-attribute">&gt; Get the Class Attribute</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> classlist = classSync(el);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>String</code> - The element's classlist.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">class1</span> <span class="hljs-symbol">class2</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> article = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.class1&#x27;</span>);

<span class="hljs-comment">// Insert a class entry</span>
classSync(article, <span class="hljs-string">&#x27;class3&#x27;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Get the classlist</span>
<span class="hljs-keyword">let</span> classlist = classSync(article);</code></pre>

						</div>
					</template>

					<template name="connectedcallback">
						<div exportgroup="readme">

							<h1 id="domconnectedcallback"><code>DOM/connectedCallback()</code></h1>
<p>This function observes when the specified elements are added to the document or given context. This is a convenience function for <a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>mutationCallback()</code></a></p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> connectedCallback <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/connectedCallback.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">connectedCallback(els, callback[, context = <span class="hljs-literal">null</span>[, observeIndirectMutation = <span class="hljs-literal">true</span>]]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>els</code> - <code>HTMLElement|String|Array</code>: The specific element or elements to observe. This could be a single element instance, a CSS selector or an array of element specifiers.</li>
<li><code>callback</code> - <code>Function</code>: The callback function that recieves the notification. This callback will recieve the following arguments.<ul>
<li><code>nodes</code> - <code>[HTMLElement]</code>: A variadic list of the elements added to the DOM.</li></ul></li>
<li><code>context</code> - <code>DOMDocument|HTMLElement</code>: (Optional) The subtree to observe. This is the <em>document</em> itself by default.</li>
<li><code>observeIndirectMutation</code> - <code>Boolean</code>: (Optional) A specifier that tells whether to watch direct or indirect mutations of the specified elements.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>MutationObserver</code> - The instantiated MutationObserver.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;el1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtain an element instance</span>
<span class="hljs-keyword">let</span> el1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el1&#x27;</span>);

<span class="hljs-comment">// Observe both by instance and by selector</span>
connectedCallback([el1, <span class="hljs-string">&#x27;#el2&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">...nodes</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;These nodes are now added to the document.&#x27;</span>, ...nodes);
});

<span class="hljs-comment">// Start mutating</span>
el1.remove();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">document</span>.body.appendChild(el1); <span class="hljs-comment">// These nodes are now added to the document. #el1</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">document</span>.body.append(<span class="hljs-string">&#x27;&lt;div id=&quot;el2&quot;&gt;&lt;/div&gt;&#x27;</span>); <span class="hljs-comment">// These nodes are now added to the document. #el2</span>
    }, <span class="hljs-number">1000</span>);
}, <span class="hljs-number">1000</span>);</code></pre>

						</div>
					</template>

					<template name="data">
						<div exportgroup="readme">

							<h1 id="domdata">DOM/data()</h1>
<p>This function sets or gets custom data/values associated with the given element.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> data <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/data.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">data(el, requestOrPayload[, val = <span class="hljs-literal">null</span>]);</code></pre>
<h3 id="gt-setunset-value">&gt; Set/Unset Value</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set a single value</span>
<span class="hljs-keyword">let</span> el = data(el, key, value);
<span class="hljs-comment">// Unset a data key</span>
<span class="hljs-keyword">let</span> el = data(el, key, <span class="hljs-literal">undefined</span>);

<span class="hljs-comment">// Set multiple values</span>
<span class="hljs-keyword">let</span> el = data(el, {
    <span class="hljs-attr">key</span>: value,
});
<span class="hljs-comment">// Unset multiple data keys</span>
<span class="hljs-keyword">let</span> el = data(el, {
    <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>,
});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>key</code> - <code>String</code>: The key to set or unset.</li>
<li><code>value</code> - <code>Any</code>: The data value to set. When <code>undefined</code>, the data key is unset from the element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h3 id="gt-get-value">&gt; Get Value</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> value = data(el, key);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>key</code> - <code>String</code>: The data key to read.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Any</code> - The data value.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set</span>
data(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Get</span>
<span class="hljs-built_in">console</span>.log(data(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;two&#x27;</span>)); <span class="hljs-comment">// 2</span></code></pre>

						</div>
					</template>

					<template name="disconnectedcallback">
						<div exportgroup="readme">

							<h1 id="domdisconnectedcallback"><code>DOM/disconnectedCallback()</code></h1>
<p>This function observes when the specified elements are removed from the document or given context. This is a convenience function for <a href="/tooling/play-ui/docs/js/api/dom/mutationcallback"><code>mutationCallback()</code></a></p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> disconnectedCallback <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/disconnectedCallback.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">disconnectedCallback(els, callback[, context = <span class="hljs-literal">null</span>[, observeIndirectMutation = <span class="hljs-literal">true</span>]]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>els</code> - <code>HTMLElement|String|Array</code>: The specific element or elements to observe. This could be a single element instance, a CSS selector or an array of element specifiers.</li>
<li><code>callback</code> - <code>Function</code>: The callback function that recieves the notification. This callback will recieve the following arguments.<ul>
<li><code>nodes</code> - <code>[HTMLElement]</code>: A variadic list of the elements removed from the DOM.</li></ul></li>
<li><code>context</code> - <code>DOMDocument|HTMLElement</code>: (Optional) The subtree to observe. This is the <em>document</em> itself by default.</li>
<li><code>observeIndirectMutation</code> - <code>Boolean</code>: (Optional) A specifier that tells whether to watch direct or indirect mutations of the specified elements.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>MutationObserver</code> - The instantiated MutationObserver.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;body&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el1&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el2&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/body&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtain an element instance</span>
<span class="hljs-keyword">let</span> el1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el1&#x27;</span>);

<span class="hljs-comment">// Observe both by instance and by selector</span>
disconnectedCallback([el1, <span class="hljs-string">&#x27;#el2&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">...nodes</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;These nodes are now removed from the document.&#x27;</span>, ...nodes);
});

<span class="hljs-comment">// Start mutating</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    el1.remove(); <span class="hljs-comment">// These nodes are now removed from the document. #el1</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el2&#x27;</span>).remove(); <span class="hljs-comment">// These nodes are now removed from the document. #el2</span>
    }, <span class="hljs-number">1000</span>);
}, <span class="hljs-number">1000</span>);</code></pre>

						</div>
					</template>

					<template name="el">
						<div exportgroup="readme">

							<h1 id="domel">DOM/el()</h1>
<p>This function translates a variety of input types to an element. You can supply a CSS selector or an HTML markup and get an <code>HTMLElement</code> in return.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> el <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/el.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">el(input);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>input</code> - <code>String|HTMLElement</code>: A valid CSS selector, HTML markup or an instance of <code>HTMLElement</code>. If a selector is provided, only the first-matched element is returned.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>HTMLElement</code> - The resulting DOM element.</li>
<li><code>NULL</code> - Where <em>input</em> is a CSS selector but matches no element.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>In the example below, we are calling this function with a CSS selector.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> div = el(<span class="hljs-string">&#x27;div&#x27;</span>);
<span class="hljs-built_in">console</span>.log(div.innerText); <span class="hljs-comment">// DIV1</span></code></pre>

						</div>
					</template>

					<template name="gettextnodes">
						<div exportgroup="readme">

							<h1 id="domgettextnodes">DOM/getTextNodes()</h1>
<p>This function finds and returns all text nodes within an element.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> getTextNodes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/getTextNodes.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">getTextNodes(el);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>Array</code> - The text nodes found.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> textNodes = getTextNodes(<span class="hljs-built_in">document</span>.body);
<span class="hljs-built_in">console</span>.log(textNodes); <span class="hljs-comment">// Array</span></code></pre>

						</div>
					</template>

					<template name="htmlasync">
						<div exportgroup="readme">

							<h1 id="domhtmlasync">DOM/htmlAsync()</h1>
<p>This function sets or gets an element's HTML/XML content. It is the programmatic alternative to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML"><code>Element.innerHTML</code></a>. Additionally, when this function receives <code>undefined</code> for a <em>set</em> operation, an empty string will be used instead.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/htmlsync"><code>htmlSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>htmlAsync()</code> is a promised-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> htmlAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/htmlAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Method signature</span>
<span class="hljs-keyword">let</span> promise = htmlAsync(el[, content = <span class="hljs-literal">null</span>]);</code></pre>
<h3 id="gt-set-content">&gt; Set Content</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = htmlAsync(el, content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>String|HTMLElement</code>: The content to set. This could be a plain text, an HTML/XML markup, or even a DOM node.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-get-content">&gt; Get Content</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = htmlAsync(el);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The source element's content is returned when the promise resolves.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;&lt;main&gt;&lt;div&gt;DIV1&lt;/div&gt;&lt;/main&gt;&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with body</span>
});

<span class="hljs-comment">// Get content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with content</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>htmlAsync()</code> are internally batched to an appropriate queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 1&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 1&#x27;</span>);
});

<span class="hljs-comment">// Set content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi again&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 2&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 2&#x27;</span>);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Get operation <span class="hljs-number">1</span>
Get operation <span class="hljs-number">2</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">1</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">2</span></code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 1&#x27;</span>);
    <span class="hljs-comment">// Get content</span>
    htmlAsync(body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 1&#x27;</span>);
    });
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">1</span>
Get operation <span class="hljs-number">1</span></code></pre>

						</div>
					</template>

					<template name="mutationcallback">
						<div exportgroup="readme">

							<h1 id="dommutationcallback">DOM/mutationCallback()</h1>
<p>This function observes when the specified elements are added to, or removed from the document or given context.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> mutationCallback <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/mutationCallback.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">mutationCallback(els, callback[, connectedState = <span class="hljs-literal">null</span>[, context = <span class="hljs-literal">null</span>[, observeIndirectMutation = <span class="hljs-literal">true</span>]]]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>els</code> - <code>HTMLElement|String|Array</code>: The specific element or elements to observe. This could be a single element instance, a CSS selector or an array of element specifiers.</li>
<li><code>callback</code> - <code>Function</code>: The callback function that recieves the notification. This callback will recieve the following arguments.<ul>
<li><code>connectedState</code> - <code>Int</code>: The type of mutation that occured. This could be either <code>1</code> or <code>0</code>, indicating whether the elements were added to the DOM or removed.</li>
<li><code>nodes</code> - <code>[HTMLElement]</code>: A variadic list of the elements added or removed from the DOM.</li></ul></li>
<li><code>connectedState</code> - <code>Int</code>: (Optional) The mutation type to watch for. This could be either <code>1</code> or <code>0</code>, indicating whether to watch only additions to the DOM or removals.</li>
<li><code>context</code> - <code>DOMDocument|HTMLElement</code>: (Optional) The subtree to observe. This is the <em>document</em> itself by default.</li>
<li><code>observeIndirectMutation</code> - <code>Boolean</code>: (Optional) A specifier that tells whether to watch direct or indirect mutations of the specified elements.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>MutationObserver</code> - The instantiated MutationObserver.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;body&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el1&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;el2&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/body&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Obtain an element instance</span>
<span class="hljs-keyword">let</span> el1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el1&#x27;</span>);

<span class="hljs-comment">// Observe both by instance and by selector</span>
mutationCallback([el1, <span class="hljs-string">&#x27;#el2&#x27;</span>, <span class="hljs-string">&#x27;#el3&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">connectedState, ...nodes</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (connectedState) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;These nodes are now added to the document.&#x27;</span>, ...nodes);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;These nodes are now removed from the document.&#x27;</span>, ...nodes);
    }
});

<span class="hljs-comment">// Start mutating</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    el1.remove(); <span class="hljs-comment">// These nodes are now removed from the document. el1</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#el2&#x27;</span>).remove(); <span class="hljs-comment">// These nodes are now removed from the document. #el2</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">document</span>.body.append(<span class="hljs-string">&#x27;&lt;div id=&quot;el3&quot;&gt;&lt;/div&gt;&#x27;</span>); <span class="hljs-comment">// These nodes are now added to the document. #el3</span>
        }, <span class="hljs-number">1000</span>);
    }, <span class="hljs-number">1000</span>);
}, <span class="hljs-number">1000</span>);</code></pre>

						</div>
					</template>

					<template name="prependasync">
						<div exportgroup="readme">

							<h1 id="domprependasync">DOM/prependAsync()</h1>
<p>This function prepends content to an element. It works exactly the same as <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend"><code>ParentNode.prepend()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/prependsync"><code>prependSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>prependAsync()</code> is a promise-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> prependAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/prependAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = prependAsync(el[, ...content);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>[String|HTMLElement]</code>: The set of content to prepend. Each could be a plain text, an HTML/XML markup, or even a DOM node.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">body</span>&gt;&lt;/<span class="hljs-keyword">body</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
prependAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with body</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>prependAsync()</code> are internally batched to a <em>write</em> queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
prependAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Prepend operation&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current content is: &#x27;</span> + content);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Current content is: 
Prepend operation</code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
prependAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Prepend operation&#x27;</span>);
    <span class="hljs-comment">// Get content</span>
    htmlAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Current content is: &#x27;</span> + content);
    });
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Prepend operation
Current content is: Hello world!</code></pre>

						</div>
					</template>

					<template name="prependsync">
						<div exportgroup="readme">

							<h1 id="domprependsync">DOM/prependSync()</h1>
<p>This function prepends content to an element. It works exactly the same as <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend"><code>ParentNode.prepend()</code></a> except that when the implied content is undefined, it is converted to an empty string.</p>
<p>The suffix <em>Sync</em> differentiates this method from its <em>Async</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/prependasync"><code>prependAsync()</code></a>. Unlike the <em>Async</em> counterpart, <code>prependSync()</code> is a normal function that runs in the same flow with that of the calling code.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> prependSync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/prependSync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">prependSync(el[, ...content);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>[String|HTMLElement]</code>: The set of content to prepend. Each could be a plain text, an HTML/XML markup, or even a DOM node.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>HTMLElement</code> - The target DOM element.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">body</span>&gt;&lt;/<span class="hljs-keyword">body</span>&gt;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Prepend content</span>
<span class="hljs-keyword">let</span> body = prependSync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>);</code></pre>

						</div>
					</template>

					<template name="select">
						<div exportgroup="readme">

							<h1 id="domselect">DOM/select()</h1>
<p>This function finds and returns the first DOM element that matches the given CSS selecotr. Where no matches are found, <code>NULL</code> is returned.</p>
<p>This works like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"><code>Document.querySelector()</code></a> / <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector"><code>Element.querySelector()</code></a> but internally polyfills the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS/:is"><code>:is()</code>, (<code>:matches()</code>, <code>:any()</code>) pseudo-class function</a>.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> select <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/select.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">select(selector[, context = <span class="hljs-literal">null</span>]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>selector</code> - <code>String</code>: A valid CSS selector.</li>
<li><code>context</code> - <code>HTMLElement</code>: An optional <em>node</em> under which to run the query. This would be equivalent to <code>context.querySelector(selector)</code>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>HTMLElement</code> - The matched element.</li>
<li><code>NULL</code> - if no matches were found.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>The example below demonstrates this function with the CSS <code>:is()</code> pseudo-class function.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> div = select(<span class="hljs-string">&#x27;:is(header, main) &gt; div&#x27;</span>);
<span class="hljs-built_in">console</span>.log(div.innerText); <span class="hljs-comment">// DIV1</span></code></pre>

						</div>
					</template>

					<template name="selectall">
						<div exportgroup="readme">

							<h1 id="domselectall">DOM/selectAll()</h1>
<p>This function finds and returns all DOM elements that matche the given CSS selecotr as a <code>NodeList</code>. Where no matches are found, an empty <code>NodeList</code> is returned.</p>
<p>This works like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll"><code>Document.querySelectorAll()</code></a> / <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll"><code>Element.querySelectorAll()</code></a> but internally polyfills the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS/:is"><code>:is()</code>, (<code>:matches()</code>, <code>:any()</code>) pseudo-class function</a>.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> selectAll <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/selectAll.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript">selectAll(selector[, context = <span class="hljs-literal">null</span>]);</code></pre>
<h3 id="parameters">Parameters</h3>
<ul>
<li><code>selector</code> - <code>String</code>: A valid CSS selector.</li>
<li><code>context</code> - <code>HTMLElement</code>: An optional <em>node</em> under which to run the query. This would be equivalent to <code>context.querySelectorAll(selector)</code>.</li>
</ul>
<h3 id="return">Return</h3>
<ul>
<li><code>NodeList</code> - A <em>non-live</em> <code>NodeList</code> containing zero or more matched elements.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>The example below demonstrates this function with the CSS <code>:is()</code> pseudo-class function.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> divs = selectAll(<span class="hljs-string">&#x27;:is(header, main) &gt; div&#x27;</span>);
<span class="hljs-built_in">console</span>.log(divs.length); <span class="hljs-comment">// 2</span></code></pre>

						</div>
					</template>

					<template name="textasync">
						<div exportgroup="readme">

							<h1 id="domtextasync">DOM/textAsync()</h1>
<p>The suffix <em>Async</em> differentiates this method from its <em>Sync</em> counterpart - <a href="/tooling/play-ui/docs/js/api/dom/textsync"><code>textSync()</code></a>. Unlike the <em>Sync</em> counterpart, <code>textAsync()</code> is a promise-based function that runs in a different flow from that of the calling code. It follows a performance strategy that lets the browser engine decide the most convenient time to honour its call.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> textAsync <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/dom/textAsync.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = textAsync(el[, content = <span class="hljs-literal">null</span>);</code></pre>
<h3 id="gt-set-text-content">&gt; Set Text Content</h3>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> promise = textAsync(el, content);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The target DOM element.</li>
<li><code>content</code> - <code>String</code>: The text content to set.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The target DOM element is returned when the promise resolves.</li>
</ul>
<h3 id="gt-get-text-content">&gt; Get Text Content</h3>
<pre><code class="hljs javascript language-javascript">textAsync(el).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with content</span>
});</code></pre>
<p><strong>Parameters</strong></p>
<p><strong>el</strong> - <code>HTMLElement</code>: The source DOM element.</p>
<p><strong>Return</strong></p>
<p><code>Promise</code> - A <em>Promise</em> that resolves when the operation finally gets executed. The source element's text content is returned when the promise resolves.</p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
textAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hello world!&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with body</span>
});

<span class="hljs-comment">// Get content</span>
textAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-comment">// Do something with content</span>
});</code></pre>
<h2 id="implementation-note">Implementation Note</h2>
<p>Technically, DOM operations initiated with <code>textAsync()</code> are internally batched to an appropriate queue using the <a href="/tooling/play-ui/docs/js/api/reflow">Reflow</a> utility. <em>Read</em> operations run first, then <em>write</em> operations. This works to eliminate <em>layout thrashing</em> as discussed in <em>Reflow</em>'s documentation.</p>
<p>Notice the order of execution in the following example.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
textAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 1&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
textAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 1&#x27;</span>);
});

<span class="hljs-comment">// Set content</span>
textAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi again&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 2&#x27;</span>);
});

<span class="hljs-comment">// Get content</span>
textAsync(<span class="hljs-built_in">document</span>.body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 2&#x27;</span>);
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
Get operation <span class="hljs-number">1</span>
Get operation <span class="hljs-number">2</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">1</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">2</span></code></pre>
<p>The proper way to synchronize with an async function is to move code into its <code>then()</code> block as seen below.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Set content</span>
textAsync(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;Hi&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Set operation 1&#x27;</span>);
    <span class="hljs-comment">// Get content</span>
    textAsync(body).then(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Get operation 1&#x27;</span>);
    });
});

<span class="hljs-comment">// ------------</span>
<span class="hljs-comment">// console</span>
<span class="hljs-comment">// ------------</span>
<span class="hljs-built_in">Set</span> operation <span class="hljs-number">1</span>
Get operation <span class="hljs-number">1</span></code></pre>

						</div>
					</template>
				</template>

				<template name="interaction">
					<div exportgroup="readme">

						<h1 id="interaction">Interaction</h1>
<p>A set of APIs for creating and responding to DOM events and UI gestures.</p>
<p>Modules in this set can be imported individually or collectively.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Import all modules</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> interaction <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/index.js&#x27;</span>;
<span class="hljs-keyword">let</span> trigger = interaction.trigger;

<span class="hljs-comment">// Import a module</span>
<span class="hljs-keyword">import</span> trigger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/trigger.js&#x27;</span>;</code></pre>
<h2 id="api">API</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/interaction/on"><code>Interaction/on()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/interaction/off"><code>Interaction/off()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/interaction/trigger"><code>Interaction/trigger()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/interaction/custom-events">Custom Events</a></li>
</ul>

					</div>

					<template name="custom-events">
						<div exportgroup="readme">

							<h1 id="custom-events">Custom Events</h1>
<p>PlayUI's event system can be hooked into to provide custom event implementations. For example, its <em>tripletap</em>, (doubletap), and <em>singletap</em> gestures are custom implementations/variations of the <em>tap</em> gesture. But custom events can also be just an alias for another event. PlayUI makes everything easy!</p>
<p>To create a custom event, import the <code>CustomEvents</code> object.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> CustomEvents <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/evt/CustomEvents.js&#x27;</span>;</code></pre>
<p>To create an alias of an existing event:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Simply map the custom event name to an existing event name</span>
CustomEvents.hit = <span class="hljs-string">&#x27;tap&#x27;</span>;

<span class="hljs-comment">// Now we can bind to the &quot;hit&quot; event instead of &quot;tap&quot;</span>
on(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;hit&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type);
})</code></pre>
<p>To create a full custom event implementation, provide a class with two methods: <em>setup</em> and <em>teardown</em>. The <em>setup</em> method will be called at the first call to bind to the event for the given element. This function will receive certain useful parameters - the emitter being the most important. The <em>teardown</em> method will be called at the last call to unbinding the event for the given element.</p>
<pre><code class="hljs javascript language-javascript">CustomEvents.tick = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-comment">// When the fisrt listenr of this event</span>
    <span class="hljs-comment">// is attached to the element, we start ticking</span>
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">el, type, emitter, hammertime</span>)</span> {
        <span class="hljs-built_in">this</span>.el = el;
        <span class="hljs-built_in">this</span>.type = type;
        <span class="hljs-built_in">this</span>.hammertime = hammertime;
        <span class="hljs-built_in">this</span>.intervalID = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            emitter.call();
        }, <span class="hljs-number">100</span>);
    }

    <span class="hljs-comment">// When the last listener of this</span>
    <span class="hljs-comment">// event is removed, no need to keep ticking</span>
    <span class="hljs-function"><span class="hljs-title">teardown</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.intervalID);
    }
};

<span class="hljs-comment">// Now we can bind to the &quot;tick&quot; event</span>
on(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;tick&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type);
});</code></pre>

						</div>
					</template>

					<template name="off">
						<div exportgroup="readme">

							<h1 id="off"><code>off()</code></h1>
<p>This function unbinds event/gesture handlers previously bound using the <a href="/tooling/play-ui/docs/js/api/interaction/on"><code>on()</code></a> function.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> off <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/off.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all listeners bound to the following event name</span>
<span class="hljs-comment">// regardless of the event handler</span>
off(el, eventName);

<span class="hljs-comment">// Unbind the listener bound with the following event handler  </span>
off(el, eventName, originalHandler);

<span class="hljs-comment">// Unbind the listener bound with the following event handler and tag </span>
off(el, eventName, originalHandler, {<span class="hljs-attr">tags</span>:[...originalTags]});

<span class="hljs-comment">// Unbind the listener bound with the following tag </span>
<span class="hljs-comment">// regardless of the event handler</span>
off(el, eventName, <span class="hljs-literal">null</span>, {<span class="hljs-attr">tags</span>:[...originalTags]});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>eventName</code> - <code>String</code>: The event name.</li>
<li><code>originalHandler</code> - <code>Function</code>: The handler function originally used with <code>on()</code>.</li>
<li><code>params</code> - <code>Object</code>: Additional parameters.</li>
</ul>
<p><strong>Return</strong></p>
<ul>
<li><code>undefined</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind a specific listenr bound to doubletap</span>
off(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;doubletap&#x27;</span>, originalHandler);

<span class="hljs-comment">// Unbind all listenrs bound to doubletap</span>
off(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;doubletap&#x27;</span>);</code></pre>

						</div>
					</template>

					<template name="on">
						<div exportgroup="readme">

							<h1 id="evton">EVT/on()</h1>
<p>This function binds an event/gesture handler to an element. This works like <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"><code>EventTarget.addEventListener()</code></a> but adds support for user gestures and custom event implementation.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> on <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/on.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">on(el, eventName, handler[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>eventName</code> - <code>String</code>: The event name.</li>
<li><code>handler</code> - <code>Function</code>: The handler function. This recieves:<ul>
<li><code>event</code> - an event object</li></ul></li>
<li><code>params</code> - <code>Object</code>: Additional parameters.</li>
</ul>
<p><strong>Return</strong><br />
A <a href="/tooling/play-ui/docs/js/api/interaction/on/#the-returned-listener-instance"><em>Listener</em> instance</a>.</p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs javascript language-javascript">on(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;doubletap&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;You doubletapped me!&#x27;</span>, event.details);
});</code></pre>
<p>Use the <a href="/tooling/play-ui/docs/js/api/interaction/trigger"><code>trigger()</code></a> method to fire the event.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Trigger</span>
trigger(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;doubletap&#x27;</span>);
<span class="hljs-comment">// And we can add details</span>
trigger(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">&#x27;doubletap&#x27;</span>), {<span class="hljs-attr">time</span>:<span class="hljs-number">0</span>});</code></pre>
<h2 id="tagging-a-listener">Tagging a Listener</h2>
<p>The <code>params.tags</code> parameter can be used to tag a listener. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be used to identify the listener for later use.</p>
<pre><code class="hljs js language-js">on(el, eventName, handler, {<span class="hljs-attr">tags</span>:[<span class="hljs-string">&#x27;#tag&#x27;</span>]});</code></pre>
<h2 id="the-returned-listener-instance">The Returned Listener Instance</h2>
<p>The <code>on()</code> function returns a <em>Listener</em> instance that gives us per-instance control.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Listener instance</span>
<span class="hljs-keyword">let</span> instance = on(el, eventName, handler);

<span class="hljs-comment">// Synthetically trigger the listener</span>
instance.fire({
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;doubletap&#x27;</span>,
});

<span class="hljs-comment">// Disconnect the listener</span>
instance.disconnect();</code></pre>
<h2 id="gestures">Gestures</h2>
<p>PlayUI uses the <a href="https://hammerjs.github.io/">Hammer.js</a> gesture library to support the following gestures out of the box. For details of these gestures, see the <em>Hammer.js</em> documentation.</p>
<ul>
<li><strong>press</strong>: press, pressup</li>
<li><strong>rotate</strong>: rotate, rotatestart, rotatemove, rotateend, rotatecancel</li>
<li><strong>pinch</strong>: pinch, pinchstart, pinchmove, pinchend, pinchcancel, pinchin, pinchout</li>
<li><strong>pan</strong>: pan, panstart, panmove, panend, pancancel, panleft, panright, panup, pandown</li>
<li><strong>swipe</strong>: swipe, swipeleft, swiperight, swipeup, swipedown</li>
<li><strong>tap</strong>: tap, (by custom extension: tripletap, doubletap, singletap)</li>
</ul>
<p>Ensure to include Hammer in your page.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/@webqit/cui/ext/hammer.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

						</div>
					</template>

					<template name="trigger">
						<div exportgroup="readme">

							<h1 id="trigger"><code>trigger()</code></h1>
<p>This function is used to trigger event/gesture handlers previously bound using the <a href="/tooling/play-ui/docs/js/api/interaction/on"><code>on()</code></a> function.</p>
<h2 id="import">Import</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> trigger <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/interaction/trigger.js&#x27;</span>;</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js">trigger(el, eventName[, details = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>el</code> - <code>HTMLElement</code>: The source DOM element.</li>
<li><code>eventName</code> - <code>String</code>: The event name.</li>
<li><code>details</code> - <code>Object</code>: (Optional) oustom data for the event.</li>
</ul>
<p><strong>Return</strong><br />
An <a href="/tooling/play-ui/docs/js/api/interaction/trigger/#the-returned-event-instance"><em>Event</em> instance</a>.</p>
<h2 id="the-returned-event-instance">The Returned Event Instance</h2>
<p><code>trigger()</code> returns the fired event object which be inspected about the disposition of its handlers.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> event = trigger(el, eventName);</code></pre>
<p>Inspect the event to see the disposition of the fired listeners.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">if</span> (event.defaultPrevented) {
    <span class="hljs-comment">// event.preventDefault() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned false</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.propagationStopped) {
    <span class="hljs-comment">// event.stopPropagation() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned false</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.promises) {
    <span class="hljs-comment">// event.promise() has been called by a handler</span>
    <span class="hljs-comment">// Or a handler returned a promise</span>
    event.promises.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// When all promises resolve</span>
    }).catch(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// When any of the promises fail</span>
    });
}</code></pre>

						</div>
					</template>
				</template>

				<template name="ui">
					<div exportgroup="readme">

						<h1 id="the-ui">The UI</h1>
<p>The set of DOM APIs for manipulating the rendered UI.</p>
<p>Modules in this set can be imported individually or collectively.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Import all modules</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> UI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/ui/index.js&#x27;</span>;
<span class="hljs-keyword">let</span> offsetTo = UI.offsetTo;

<span class="hljs-comment">// Import a module</span>
<span class="hljs-keyword">import</span> offsetTo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui/src/ui/poffsetTolay.js&#x27;</span>;</code></pre>
<h2 id="api">API</h2>
<ul>
<li><a href="/tooling/play-ui/docs/js/api/ui/coordsatrect"><code>UI/coordsAtRect()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/offsets"><code>UI/offsets()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/offsetto"><code>UI/offsetTo()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/positioningoffsets"><code>UI/positioningOffsets()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/rect"><code>UI/rect()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/rectatoffsets"><code>UI/rectAtOffsets()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/scrollparent"><code>UI/scrollParent()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/scrolls"><code>UI/scrolls()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/scrollto"><code>UI/scrollTo()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/size"><code>UI/size()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/translateto"><code>UI/translateTo()</code></a></li>
<li><a href="/tooling/play-ui/docs/js/api/ui/resizecallback"><code>UI/resizeCallback()</code></a></li>
<li>[UI/ProximityObserver](ProximityObserver</li>
</ul>

					</div>

					<div exportgroup="coordsatrect">

						<h1 id="uicoordsatrect">UI/coordsAtRect()</h1>

					</div>

					<div exportgroup="offsets">

						<h1 id="uioffsets">UI/offsets()</h1>

					</div>

					<div exportgroup="offsetto">

						<h1 id="uioffsetto">UI/offsetTo()</h1>

					</div>

					<div exportgroup="positioningoffsets">

						<h1 id="uipositioningoffsets">UI/positioningOffsets()</h1>

					</div>

					<div exportgroup="proximityobserver">

						<h1 id="uiproximityobserver">UI/ProximityObserver</h1>

					</div>

					<div exportgroup="rect">

						<h1 id="uirect">UI/rect()</h1>

					</div>

					<div exportgroup="rectatoffsets">

						<h1 id="uirectatoffsets">UI/rectAtOffsets()</h1>

					</div>

					<div exportgroup="resizecallback">

						<h1 id="uiresizecallback">UI/resizeCallback()</h1>

					</div>

					<div exportgroup="scrollparent">

						<h1 id="uiscrollparent">UI/scrollParent()</h1>

					</div>

					<div exportgroup="scrolls">

						<h1 id="uiscrolls">UI/scrolls()</h1>

					</div>

					<div exportgroup="scrollto">

						<h1 id="uiscrollto">UI/scrollTo()</h1>

					</div>

					<div exportgroup="size">

						<h1 id="uisize">UI/size()</h1>

					</div>

					<div exportgroup="translateto">

						<h1 id="uitranslateto">UI/translateTo()</h1>

					</div>
				</template>
			</template>

			<template name="installation">
				<div exportgroup="readme">

					<h1 id="installation-guide">Installation Guide</h1>
<p>Play UI can be used via a script tag or as an npm package.</p>
<h2 id="option-1-embed-as-script">Option 1: Embed as script</h2>
<p>Add the following script tag to your page to include the all-in-one Play UI module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/play-ui/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-comment">&lt;!-- The above tag loads Play UI into a global &quot;WQ&quot; object --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">window</span>.WQ.$;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="option-2-install-via-npm">Option 2: Install via NPM</h2>
<pre><code class="hljs text language-text">$ npm i -g npm
$ npm i @webqit/play-ui</code></pre>
<p>The installed package is designed to be <em>built</em> into a single object from the individual <a href="/tooling/play-ui/docs/js/installation/packages">Play UI packages</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui&#x27;</span>;
<span class="hljs-keyword">const</span> $ = PlayUI();</code></pre>
<p>It is also possible to use Play UI in a server-side <em>window</em> context such as the one provided by <a href="https://github.com/jsdom/jsdom">jsdom</a>. Here is how that could look:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Utilities we&#x27;ll need</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-comment">// Import jsdom</span>
<span class="hljs-keyword">import</span> jsdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jsdom&#x27;</span>;

<span class="hljs-keyword">import</span> PlayUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/play-ui&#x27;</span>;

<span class="hljs-comment">// Read the HTML document file from the server</span>
<span class="hljs-keyword">const</span> documentFile = fs.readFileSync(path.resolve(<span class="hljs-string">&#x27;./index.html&#x27;</span>));
<span class="hljs-comment">// Instantiate jsdom so we can obtain the &quot;window&quot; for building Play UI</span>
<span class="hljs-comment">// Detailed instruction on setting up jsdom is available in the jsdom docs</span>
<span class="hljs-keyword">const</span> JSDOM = <span class="hljs-keyword">new</span> jsdom.JSDOM(documentFile.toString());

<span class="hljs-comment">// Create the build using the window above</span>
<span class="hljs-keyword">const</span> $ = PlayUI({<span class="hljs-attr">window</span>: JSDOM.window});</code></pre>
<!--
## All-in-one or derivatively

While the most common usecase is to install and use Play UI as a single, built object, it can also be used derivatively on its smaller modules.
-->

				</div>
			</template>

			<template name="packages">
				<div exportgroup="readme">

					<h1 id="packages">Packages</h1>
<ul>
<li><a href="/tooling/play-ui/docs/js/packages/play-collapsible">Play Collapsible</a></li>
<li><a href="/tooling/play-ui/docs/js/packages/play-icon">Play Icon</a></li>
<li><a href="/tooling/play-ui/docs/js/packages/play-sequence">Play Sequence</a></li>
</ul>

				</div>

				<template name="play-collapsible">
					<div exportgroup="readme">

						<h1 id="play-collapsible">Play Collapsible</h1>

					</div>
				</template>

				<template name="play-icon">
					<div exportgroup="readme">

						<h1 id="play-icon">Play Icon</h1>

					</div>
				</template>

				<template name="play-sequence">
					<div exportgroup="readme">

						<h1 id="play-sequence">Play Sequence</h1>

					</div>
				</template>
			</template>
		</template>
	</template>

	
