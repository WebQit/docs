
	

	<template name="docs">
		<div exportgroup="readme">

			<h1 id="oohtml">OOHTML</h1>
<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/oohtml.svg" alt="NPM version" /></a></span><br />
<span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/oohtml.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<p><a href="https://github.com/webqit/oohtml">Object-Oriented HTML (OOHTML)</a> is a suite of new DOM features that particularly facilitates writing <em>modular</em>, <em>reusable</em>, and <em>reactive</em> HTML and JavaScript <em>natively</em> and <em>more conveniently</em>.</p>
<p><em>Handcraft your HTML, CSS and JavaScript into a powerful UI without writing a line of framework-specific code! OOHTML comes with all modern UI development paradigms built into the plain old HTML so you can go without a tool.</em></p>
<blockquote>
  <p>OOHTML is being proposed as a <a href="https://discourse.wicg.io/t/proposal-chtml/4716">W3C standard at the Web Platform Incubator Community Group</a>. Consider bringing your ideas to the discussion.</p>
</blockquote>
<blockquote>
  <p><a href="https://github.com/webqit/oohtml">Visit project repo</a>.</p>
</blockquote>
<blockquote>
  <p>This entire documentation is currently being improved on.</p>
</blockquote>
<h2 id="features">Features</h2>
<p>OOHTML brings five new features that make common UI design terminologies possible without external tooling. These features may be used individually or together to improve how we author the UI. Here is an overview:</p>
<ul>
<li><a href="/tooling/oohtml/docs/#html-modules">HTML Modules</a></li>
<li><a href="/tooling/oohtml/docs/#html-imports">HTML Imports</a></li>
<li><a href="/tooling/oohtml/docs/#namespaced-html">Namespaced HTML</a></li>
<li><a href="/tooling/oohtml/docs/#the-state-api">The State API</a></li>
<li><a href="/tooling/oohtml/docs/#subscript">Subscript</a></li>
</ul>
<h3 id="html-modules">HTML Modules</h3>
<p>HTML Modules are a way to implement reusable HTML markup using the <em>module</em>, <em>import</em> and <em>export</em> paradigm. This feature establishes the standard <code>&lt;template&gt;</code> element as the module infrastructure for HTML and introduces new attributes, properties and events that make that work.</p>
<p>Every module is a regular <code>&lt;template&gt;</code> element with a <code>name</code> attribute - <em>the module ID</em>, and the contents if a module are simply regarded as <em>exports</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Exports may be more properly wrapped within an <code>&lt;export&gt;</code> element of a designated name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Or they may be individually <em>tagged</em> to an export identifier using the <code>exportgroup</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Either way, they are accessed the same way using the <em>Modules API</em>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Access module1 from document.templates</span>
<span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;

<span class="hljs-comment">// Import module1&#x27;s exports</span>
<span class="hljs-keyword">let</span> questionExport = module1.exports.question; <span class="hljs-comment">// Array</span>

<span class="hljs-comment">// Clone the elements in the export</span>
<span class="hljs-keyword">let</span> questionExportClone = questionExport.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.cloneNode(<span class="hljs-literal">true</span>));</code></pre>
<p>Taking things further, template elements may reference remote content using the <code>src</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-remote&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The contents of the remote file automatically become the template's content on load.</p>
<p><em>Details are in the <a href="/tooling/oohtml/docs/html-modules">HTML Modules</a> documentation. Learn more about the convention, API, events, and the polyfill support.</em></p>
<h3 id="html-imports">HTML Imports</h3>
<p>HTML Imports are a declarative way to <em>import</em> reusable snippets from HTML Modules into slots in the main document.</p>
<blockquote>
  <p>Note that this is not the same as the HTML Imports that earlier shipped with Web Components.</p>
</blockquote>
<p>Here, an <code>&lt;import&gt;</code> element in the <code>&lt;body&gt;</code> area simply points to a module to <em>place</em> one of its exports.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Import question here from module1 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Resolution takes place and the <code>&lt;import&gt;</code> element is replaced by all of the imported contents.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- import element replaced --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The <code>&lt;import&gt;</code> stands by somewhere so that it can return to its slot in the event that all of the imported ccontents are removed. Details ahead.</p>
<p>Now, it is possible to define one <em>module ID</em> on a regular element for use by one or more <code>&lt;import&gt;</code> elements within the block.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to a module; one module ID for all imports within --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Import question here from module1 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Import another export here from module1 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>Imports</em> maintain a <em>live</em> relationship with the modules they point to. For example, they are resolved again when the module ID is dynamically pointed at another module element.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Changing the module ID on the DIV container above will see all associated imports resolved again</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div[template=&quot;module1&quot;]&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre>
<p>This opens up new simple ways to create very dynamic applications.</p>
<p><em>Details are in the <a href="/tooling/oohtml/docs/html-imports">HTML Imports</a> documentation. Learn more about the convention, dynamicity, Slot Inheritance, isomorphic rendering, and the polyfill support.</em></p>
<h3 id="namespaced-html">Namespaced HTML</h3>
<p>Namespacing is a way to let an element establish its own naming context for descendant elements. This makes it possible to keep IDs scoped to a context other than the document's global scope; thus the ability to write collision-free IDs across a page.</p>
<p>The following modular markup implements its IDs in namespaces:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;continents&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;europe&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asia&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>Namespaced HTML gives us many benefits. For example, the above gives us a conceptual model of repeating objects:</p>
<pre><code class="hljs html language-html">continents
|- europe
|   |- about
|   |- countries
|- asia
    |- about
    |- countries</code></pre>
<p>The <em>namespace API</em> translates that model into a real object tree:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new &quot;namespace&quot; DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre>
<p>We get a document structure that's easier to reason about and that translates to a more consistent, bankable API.</p>
<p>Namespaced HTML also helps us to (1) write collision-free IDs and selectors, and (2) by means of the Namespace API, minimize selector-based DOM traversal (e.g <code>el.namespace.some_id</code> vs <code>el.querySelector('#some_id')</code>). Much of our code in the examples below will now use the <code>namespace</code> attribute in markup and the <code>.namespace</code> property in JS.</p>
<p><em>Details are in the <a href="/tooling/oohtml/docs/namespaced-html">Namespaced HTML</a> documentation. Learn more about the convention, Namespaced Selectors, API, observability, and the polyfill support.</em></p>
<h3 id="the-state-api">The State API</h3>
<p>The State API is a DOM API that lets us maintain application state at both the document level and the individual element level. It makes it easy to think about application state at different levels in the DOM tree and to keep track of changes at each level.</p>
<p>This API exposes a <code>.state</code> property on the document object and on elements. Arbitrary values can be set and read here the same way we would with regular objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// At the document level</span>
<span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.state.pageTitle); <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// At the element level</span>
element.state.collapsed = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">console</span>.log(element.state.collapsed); <span class="hljs-comment">// true</span></code></pre>
<p><em>State Objects</em> are <em>live objects</em> that can be observed for changes using the <a href="/tooling/oohtml/docs/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-string">&#x27;pageTitle&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;New Page Title: &#x27;</span> + e.value);
    <span class="hljs-comment">// Or we could reflect this state on the document title element</span>
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;title&#x27;</span>).innerHTML = e.value;
});</code></pre>
<p>This lets us build very reactive applications natively.</p>
<p>Using an element's state API, here's how we could make a practical <em>collapsible</em> component.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-collapsible</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;control&quot;</span>&gt;</span>Toggle Me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 0px&quot;</span>&gt;</span>
        Some content
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">my-collapsible</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

    <span class="hljs-comment">/**
     * Creates the Shadow DOM
     */</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// Observe state and get the UI synced</span>
        Observer.observe(<span class="hljs-built_in">this</span>.state, <span class="hljs-string">&#x27;collapsed&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
            <span class="hljs-built_in">this</span>.namespace.content.style.height = e.value ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
            <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-collapsed&#x27;</span>, e.value ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
        });

        <span class="hljs-comment">// Implement the logic for toggling collapsion</span>
        <span class="hljs-built_in">this</span>.namespace.control.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });
    }

});</code></pre>
<p>Now, other parts of the application are able to work in sync with the state of this element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> collapsible = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>);
Observer.observe(collapsible.state, <span class="hljs-string">&#x27;collapsed&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.value ? <span class="hljs-string">&#x27;element collapsed&#x27;</span> : <span class="hljs-string">&#x27;element expanded&#x27;</span>);
});</code></pre>
<p><em>Details are in the <a href="/tooling/oohtml/docs/the-state-api">State API</a> documentation. Learn more about the API, deep observability, and the polyfill support.</em></p>
<h3 id="subscript">Subscript</h3>
<p>Subscript is a type of JavaScript runtime that lets us create scoped, <em>reactive</em> <code>&lt;script&gt;</code> elements across the UI. That gives us a UI binding language and the ability to have UI logic without involving actual JavaScript classes or files.</p>
<p>The following <code>&lt;script&gt;</code> element is scoped to the <code>#alert</code> element - its host element - instead of the global browser scope:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id); <span class="hljs-comment">// alert</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>As seen, the <code>this</code> variable is a reference to the script's host element. In addition, variables declared within the script are available only within the script, while global variables are always available across all scripts.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">this</span>.namespace.exit.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Below is how we could render something - a message - from the element's state object - <code>.state.message</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Render the &quot;message&quot; property from the element&#x27;s state object</span>

            <span class="hljs-built_in">this</span>.namespace.message.innerHTML = <span class="hljs-built_in">this</span>.state.message;
            <span class="hljs-built_in">this</span>.namespace.exit.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">this</span>.remove();
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>And here is one of the most important features of Subscript: reactivity! While Subscript works like regular JavaScript, it is also able to observe changes in its scope and respond to them. And it does this at the statement level such that a given statement is evaluated again and independent of other statements whenever the observable references on the statement change. Thus, in the code above, any changes made to the observable reference<code>.state.message</code> will trigger that particular statement to run again.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> alertElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>);
alertElement.state.message = <span class="hljs-string">&#x27;Task started!&#x27;</span>;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    alertElement.state.message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
}, <span class="hljs-number">1000</span>);</code></pre>
<p>Leveraging this reactivity, here's how we could implement the <code>&lt;my-collapsible&gt;</code> component we created in the <em>State API</em> section above - this time, without a JavaScript class.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;collapsible&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;control&quot;</span>&gt;</span>Toggle Me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 0px&quot;</span>&gt;</span>
        Some content
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Observe state and get the UI synced, without requiring Observer.observe() here...</span>

        <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-collapsed&#x27;</span>, <span class="hljs-built_in">this</span>.state.collapsed ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
        <span class="hljs-built_in">this</span>.namespace.content.style.height = <span class="hljs-built_in">this</span>.state.collapsed ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
        <span class="hljs-built_in">this</span>.namespace.control.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// Toggle collapsion state</span>
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<blockquote>
  <p>We can see that with Subscript, we sometimes don't need as much as a custom element to bring life to some areas in the UI.</p>
</blockquote>
<p><em>Details are in the <a href="/tooling/oohtml/docs/subscript">Subscript</a> documentation. Learn more about the event-based runtime, deep observability, bindings, the API, error handling, and the polyfill support.</em></p>
<h2 id="getting-started">Getting Started</h2>
<p>All it takes to use OOHTML is include the <a href="/tooling/oohtml/docs/polyfill">polyfill</a> on a page. You can begin writing modular, reusable, reactive HTML right away! You definitely want to visit the documentation for each feature and try everything out by pasting the code examples and running them right on your browser.</p>
<p>We're putting together a collection of examples in the <a href="/tooling/oohtml/docs/examples">examples</a> section.</p>
<h2 id="getting-involved">Getting Involved</h2>
<p><em>Platform feature</em> proposals aren't the easiest thing in the world!</p>
<ul>
<li><p>They have to be something everyone can agree on! This makes us want to hear from you.</p>
<p>If you indeed have a usecase for all, or aspects, of OOHTML, or have some opinions, you should please join the discussion at the <a href="https://discourse.wicg.io/t/proposal-chtml/4716">WICG</a>.</p>
<p>If you are building something early with it (just as we are building <a href="//webqit.io">webqit.io</a> with it), we'd like to hear from you via any means - <a href="https://discourse.wicg.io/t/proposal-chtml/4716">WICG</a>, [email - webqit.io@gmail.com], <a href="https://github.com/webqit/oohtml/discussions">Github Discussions</a>. Your personal experience working with OOHTML may have something to give back in some way to its development. You may also like us to feature your work with OOHTML.</p></li>
<li><p>Platform feature proposals also have to go through a million iterations! And much in dollars go into that!</p>
<p>If you could help in some way, we'd be more than glad! If you'd like to find out what your $1 could do for us and what's in for you, do indeed reach out at webqit.io@gmail.com.</p></li>
</ul>
<h2 id="design-goals">Design Goals</h2>
<p>See the <a href="/tooling/oohtml/docs/explainer">features explainer</a>.</p>
<h2 id="issues">Issues</h2>
<p>To report bugs or request features, please submit an <a href="https://github.com/webqit/oohtml/issues">issue</a>.</p>
<h2 id="discusions-new">Discusions (new)</h2>
<p>We now have <a href="https://github.com/webqit/oohtml/discussions">Github Discussions</a> for OOHTML. General feedback may be taken here instead of filing an issue.</p>
<h2 id="license">License</h2>
<p>MIT.</p>

		</div>

		<template name="examples">
			<div exportgroup="readme">

				<h1 id="examples">Examples</h1>
<p>Here are a few examples that you can try right now. You can simply copy and paste these codes to view on your browser.</p>
<ul>
<li><a href="/tooling/oohtml/docs/examples/tooling">Tooling Example</a></li>
<li><a href="/tooling/oohtml/docs/examples/spa">An SPA In OOHTML</a></li>
<li><a href="/tooling/oohtml/docs/examples/todo">A TODO List In OOHTML</a></li>
</ul>

			</div>

			<template name="spa">
				<div exportgroup="readme">

					<h1 id="an-spa-in-oohtml">An SPA In OOHTML</h1>
<p>This example makes a Single Page Application (SPA) of <a href="/tooling/oohtml/docs/examples/html-imports"><em>HTML Imports</em></a>.</p>
<p>Below, we're using the two <code>&lt;template&gt;</code> elements to each represent a route - a page. Then we point the <code>&lt;body&gt;</code>'s template attribute to either of the <code>&lt;template&gt;</code>s, depending on the current URL.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>An SPA In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.import=import&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pages&quot;</span>&gt;</span>

            <span class="hljs-comment">&lt;!-- &quot;home&quot; page module --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>
                    Welcome Home!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>About Me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

            <span class="hljs-comment">&lt;!-- &quot;about&quot; page module --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>
                    About Me!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>Back to Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;pages/home&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Page not Found!<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
                <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">document</span>.location.hash.substr(<span class="hljs-number">1</span>);
                <span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;pages&#x27;</span> + path);
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Navigate to a route that does not begin with <code>#/home</code> or <code>#/about</code>, you should see the default content showing <em>404</em>.</p>
<p><a href="//webqit.io/tooling/.docs/oohtml/examples/spa/.demos/index.html">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

				</div>
			</template>

			<template name="todo">
				<div exportgroup="readme">

					<h1 id="a-todo-list-in-oohtml">A TODO List In OOHTML</h1>
<p>Below is a TODO list application that is based a plain JavaScript array bound to <code>document.state</code>.</p>
<p>It features the ability to add/remove items.</p>
<ul>
<li><strong>The <em>remove</em> feature</strong> - When the <em>remove</em> button of a <code>&lt;li&gt;</code> element is clicked, the corresponding entry in the array is <em>spliced</em> off.</li>
<li><strong>The <em>add</em> feature</strong> - When the <em>add</em> button in the TODO container is clicked, an item is added to the array.</li>
</ul>
<p>Adding and removing items on the array happens <em>reactively</em>, and the corresponding <code>&lt;li&gt;</code> element is added or removed from the DOM. The <code>$.itemize()</code> function does this for us!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>A TODO List in OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/play-ui/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Make PlayUI available globally</span>
            <span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.WQ.$;

            <span class="hljs-comment">// Create the app</span>
            <span class="hljs-keyword">let</span> app = {
                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My TODO&#x27;</span>,
                <span class="hljs-attr">todo</span>: [
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-1&#x27;</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-2&#x27;</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-3&#x27;</span>},
                ],
            };
            <span class="hljs-built_in">document</span>.setState(app);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;items&quot;</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">namespace</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;remove&quot;</span>&gt;</span>Remove<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                    <span class="hljs-built_in">this</span>.namespace.desc.innerHTML = <span class="hljs-built_in">this</span>.state.desc;
                </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;items&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;items&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            You can also add items from the console directly.<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
            Open your console and type: <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>document.state.todo.push({desc:&quot;New Item&quot;})<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                <span class="hljs-built_in">this</span>.namespace.title.innerHTML = <span class="hljs-built_in">document</span>.state.title;
                <span class="hljs-built_in">this</span>.namespace.add.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-built_in">document</span>.state.todo.push({<span class="hljs-attr">desc</span>: prompt(<span class="hljs-string">&#x27;Task description&#x27;</span>),});
                });
                $(<span class="hljs-built_in">this</span>.namespace.items).itemize(<span class="hljs-built_in">document</span>.state.todo, <span class="hljs-function">(<span class="hljs-params">callbackType, el, data, index, isUpdate</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (callbackType === <span class="hljs-string">&#x27;setState&#x27;</span> &amp;&amp; !isUpdate) {
                        <span class="hljs-comment">// This means el was newly generated by itemize()</span>
                        el.namespace.remove.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                            <span class="hljs-built_in">document</span>.state.todo.splice(index, <span class="hljs-number">1</span>);
                        });
                    }
                });
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><a href="//webqit.io/tooling/.docs/oohtml/examples/todo/.demos/index.html">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

				</div>
			</template>

			<template name="tooling">
				<div exportgroup="readme">

					<h1 id="tooling-in-oohtml">Tooling In OOHTML</h1>
<p>This example shows how we could use a DOM abstraction library, like jQuery, from within Subscript code.</p>
<p>Turns out that this is naturally possible!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Tooling In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                $(<span class="hljs-built_in">this</span>.namespace.message).html(<span class="hljs-built_in">this</span>.state.message || <span class="hljs-string">&#x27;Task pending...&#x27;</span>);
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// The alert</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).setState({
                    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;This task is now complete!&#x27;</span>,
                });
            }, <span class="hljs-number">3000</span>);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Tooling can also help us acheive more efficient DOM manipulation. Generally, surgically updating the DOM may have performance implications on the UI, as arising from layout thrashing (see <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">this article</a> on Web Fundamentals). But we also don't need as much as a <em>Virtual DOM</em> for this. A technique like that of <a href="https://github.com/wilsonpage/fastdom">fast DOM</a> could just suffice.</p>
<p>This technique is natively implemented by the <a href="https://webqit.io/tooling/play-ui">PlayUI</a> library which has a jQuery-like API. We will now use PlayUI as a drop-in replacement for jQuery in the code above.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Tooling In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/play-ui/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                <span class="hljs-comment">// The .html() method is asynchronous</span>
                $(<span class="hljs-built_in">this</span>.namespace.message).html(<span class="hljs-built_in">this</span>.state.message).then(<span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-comment">// Do something sync</span>
                });
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Make PlayUI available globally</span>
            <span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.WQ.$;

            <span class="hljs-comment">// The alert</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).setState({
                    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;This task is now complete!&#x27;</span>,
                });
            }, <span class="hljs-number">3000</span>);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><a href="//webqit.io/tooling/.docs/oohtml/examples/tooling/.demos/index.html">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

				</div>
			</template>
		</template>

		<template name="explainer">
			<div exportgroup="readme">

				<h1 id="oohtml-features-explainer">OOHTML Features Explainer</h1>
<p>This information is being gathered to present OOHTML's design and architectural choices in the light of the problem space. We intend to maintain this as a living document; watch this space, or help us improve it by submitting a pull request or by <a href="https://github.com/webqit/oohtml/issues">filing an issue</a>.</p>
<h2 id="object-oriented-markup">Object-Oriented Markup</h2>
<p><em>Naming and finding things</em> is hard; modular design makes it easier! This isn't necessarily some modern wisdom, we just couldn't before now address HTML's old idea of one global scope for IDs and CSS selectors. Here's how we currently struggle with creating modular markup and how OOHTML makes it a lot easier.</p>
<ul>
<li><p><strong><a href="https://getbem.com">BEM</a></strong> has been an agreeable workaround for many people. It's, however, clunky.</p>
<ul>
<li>Compare that with the more succinct <strong><a href="../namespaced-html#namespaced-selectors">Namespaced Selectors</a></strong> in <a href="/tooling/oohtml/docs/namespaced-html">Namespaced HTML</a>.</li></ul>
<p><em>BEM also doesn't really go beyond usage in CSS. Namespaced HTML, on the other hand, is able to translate Namespaces in markup into namespace objects in JavaScript by means of the Namespace API.</em></p></li>
<li><p><strong><a href="https://github.com/stuartpb/pwalls-spec">Stuart P.'s Parts and Walls</a></strong> proposal from 2015 also points to the same need for a modular naming that's accessible in JavaScript.</p>
<ul>
<li>But while the above is based on programmatic DOM traversal, Namespaced HTML let's us access the same elements declaratively as live DOM properties. In other words, instead of having to query the DOM each time to access named elements, the DOM exposes them as properties and let's us receive updates when any of the properties change. <em>See details in the <a href="../namespaced-html#api">Namespace API</a> of <a href="/tooling/oohtml/docs/namespaced-html">Namespaced HTML</a>.</em></li></ul>
<p><em>And just for fun, it also looks like the DOM itself likes the idea of exposing strategic UI objects in JavaScript as DOM properties. See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/head"><code>document.head</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body"><code>document.body</code></a>. These are indeed more concise than <code>document.querySelector('head')</code> and <code>document.querySelector('body')</code>.</em></p></li>
</ul>
<p>Overall, <a href="/tooling/oohtml/docs/namespaced-html">Namespaced HTML</a> is the far-reaching solution to authoring modular HTML and CSS.</p>
<h2 id="html-modules-and-imports">HTML Modules and Imports</h2>
<p>On the expansive subject of <a href="https://github.com/WICG/webcomponents/issues/645"><em>HTML Modules</em></a>, OOHTML takes a very, very different approach from the many existing opinions to how reusable markup should be delivered and consumed in the browser - <em><a href="/tooling/oohtml/docs/html-modules">OOHTML's HTML Modules</a></em>. What is the most important difference?</p>
<ul>
<li>OOHTML sees HTML Modules as simply a way to ship and consume <strong>static, inert content</strong>, and is thus more oriented towards HTML's standard primitive for <em>static, inert content</em> - the <code>&lt;template&gt;</code> element. OOHTML simply introduces <a href="/tooling/oohtml/docs/html-modules#remote-content">the <strong>src</strong> attribute</a> as a way to <em>load a template's content from a remote HTML file</em>.</li>
<li><a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/html-modules-explainer.md">This explainer</a>, among others, however, follows the JavaScript route of using ES6 module infrastructure to load <strong>both static content and active script elements</strong>.</li>
</ul>
<p>How do these compare?</p>
<ul>
<li><p><strong>OOHTML's approach let's us <em>author and deliver HTML in HTML</em>.</strong> And it's as declarative as this:</p>
<p><em>Remote File: /bundle.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Main Document:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bundle&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><em>See also: <a href="https://discourse.wicg.io/t/add-src-attribute-to-template/2721">[proposal - <strong>src</strong> attribute]</a>, <a href="https://github.com/whatwg/html/issues/2791">[proposal - <strong>src</strong> attribute]</a></em></p>
<p><strong>But, the other approach gets us to deal with JavaScript code to import remote HTML</strong></p>
<p><em>Remote File: /import.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> blogPost = <span class="hljs-keyword">import</span>.meta.document.querySelector(<span class="hljs-string">&quot;#blogPost&quot;</span>);
    <span class="hljs-keyword">export</span> { blogPost }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><em>Main Document:</em>`</p>
<pre><code class="hljs js language-js">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;
    <span class="hljs-keyword">import</span> { blogPost } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;import.html&quot;</span>;
&lt;/script&gt;</code></pre></li>
<li><p><strong>OOHTML's approach provides for consuming the imported HTML <em>both in JavaScript and in HTML</em>.</strong> And it's as declarative as the following two cases:</p>
<p><em>In JavaScript - as detailed in <a href="/tooling/oohtml/docs/html-modules#api">HTML Modules API</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> [ blogPost ] = <span class="hljs-built_in">document</span>.templates.bundle.exports.blogPost;
    <span class="hljs-built_in">document</span>.body.appendChild(blogPost.cloneNode(<span class="hljs-literal">true</span>));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><em>See also: <a href="https://discourse.wicg.io/t/document-templates/1057">[proposal - <code>document.templates</code>]</a></em></p>
<p><em>In HTML - as detailed in <a href="/tooling/oohtml/docs/html-imports">OOHTML Imports</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><strong>But, the other approach remains based <em>only in JavaScript</em></strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">import</span> { blogPost } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;import.html&quot;</span>
        <span class="hljs-built_in">document</span>.body.appendChild(blogPost);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>But <a href="https://github.com/WICG/webcomponents/issues/863">the new direction</a> of this approach is having an afterthought toward a declarative way to place imported content in markup.</em></p></li>
<li><p><strong>OOHTML's approach follows <em>lazy-loading of remote modules and lazy rendering of <code>&lt;import&gt;</code> elements, as driven by module events</em>.</strong> This makes <code>&lt;import&gt;</code> elements work just like elements like <code>&lt;img&gt;</code>: 'display whenever you can load', as seen below:</p>
<p><em>In HTML - as detailed in <a href="/tooling/oohtml/docs/html-imports">OOHTML Imports</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Resolves whenever module loads --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><strong>But, the other approach simply does not.</strong></p></li>
</ul>
<p>Overall, it seems more traditional to us to implement HTML Modules in HTML than in JavaScript, letting us do all HTML concerns in HTML (templates) and all JavaScript concerns in JavaScript (ES6 modules).</p>
<p>But then, it is a common pattern today for some reusable HTML has to go with some logic. And it is interesting how another of OOHTML's features - <a href="/tooling/oohtml/docs/subscript">Subscript</a> - lets us add such non-global JavaScript to HTML markup, with everything working happily:</p>
<p><em>Remote File: /bundle.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;#content&#x27;</span>).innerHTML = <span class="hljs-built_in">document</span>.state.content;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- previous syntax: &lt;script type=&quot;scoped&quot;&gt;&lt;/script&gt; --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Main Document:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bundle&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Resolves whenever module loads, and the slotted element&#x27;s scoped script activates --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>And how far can this go? We run this in production with webqit.io. Our real life success with this pattern is something we want to eagerly publish.</p>
<h2 id="state-observability-and-reactivity">State, Observability and Reactivity</h2>
<p>Primitives for building <em>reactive</em> applications and keeping track of very dynamic state have not particularly found their way to native web languages.</p>
<ul>
<li><p><strong>State:</strong> We indeed have some primitives related to the concept of <em>state</em>, but they have very limited usecases. An example is <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/dataset">HTML5's DataSet API</a> that lets us keep state with HTML elements. But, it turns out to be tied to just HTML data <code>(data-*)</code> attributes - making it less useful as a general way to work with application state in the UI.</p>
<p>Compare OOHTML's <a href="/tooling/oohtml/docs/the-state-api">State API</a> which gives us robust <em>state management</em> - covering both document-level and element-level state, with automatic support for observability.</p></li>
<li><p><strong>Observability:</strong> Much engineering still goes into using JavaScript's change-detection mechanisms for <em>reactive</em> UI development, and some things don't even scale. Check out a consideration of some of those difficulties in <a href="https://webqit.io/tooling/observer/explainer">this explainer</a>.</p>
<p>Compare the <a href="https://github.com/webqit/observer">Observer API</a> which provides generic functions for observing and intercepting JavaScript objects. See its <em>universal</em> role across the rest of OOHTML, and potentially other technologies.</p></li>
<li><p><strong>Reactivity:</strong> A Reactuve UI binding language? See <a href="/tooling/oohtml/docs/subscript">Subscript</a>. It comes bringing the full power of JavaScript for the job.</p>
<p>Compare <a href="https://discourse.wicg.io/t/extension-of-template/447">this early idea for a template syntax by Jonathan Kingston</a> from 2014, <a href="https://github.com/whatwg/html/issues/2254">this proposal</a> from 2017, and <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Apple's proposal</a> from 2017.</p></li>
</ul>

			</div>
		</template>

		<template name="html-imports">
			<div exportgroup="readme">

				<h1 id="html-imports">HTML Imports</h1>
<p>HTML Imports are a declarative way to place reusable HTML snippets on any location in the DOM. This feature abstracts over the <a href="/tooling/oohtml/docs/html-modules">HTML Modules API</a> to provide incredibly powerful composability in just a matter of tags and attributes.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="/tooling/oohtml/docs/html-imports/#polyfill-support">Polyfill Support</a> section below for the features described on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>The <a href="/tooling/oohtml/docs/html-modules">HTML Modules Specification</a> introduces the <em>import</em> and <em>export</em> terminology in working with <code>&lt;template&gt;</code> elements and their contents.</p>
<p>The <code>&lt;template&gt;</code> elements below are HTML modules. Exports are defined using the two standard conventions.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- part of export-1 --&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <span class="hljs-comment">&lt;!-- part of export-2 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- part of export-2 --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>HTML Imports introduces an <code>&lt;import&gt;</code> element that lets us place these <em>exports</em> into any location on the DOM.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Place all of export-1 here --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>An import element uses the <code>name</code> attribute as the <em>export</em> identifier and the <code>template</code> attribute as the <em>module</em> identifier.</p>
<p><em>Resolution</em> takes place and the <code>&lt;import&gt;</code> element is replaced by the <em>export</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- import element replaced --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>And all elements of an <em>export ID</em> go together into the same <em>import slot</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">question-element</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place all of export-2 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">question-element</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">question-element</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
        <span class="hljs-comment">&lt;!-- import element replaced --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">question-element</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The module identifier may also be defined on any element to establish a <em>resolution scope</em> for all import elements within its subtree.</p>
<pre><code class="hljs html language-html">&lt;body template=&quot;module1&quot;&gt;

    &lt;!-- Place all of export-1 here --&gt;
    &lt;import name=&quot;export-1&quot;&lt;/import&gt;
    &lt;question-element&gt;
        &lt;!-- Place all of export-2 here --&gt;
        &lt;import name=&quot;export-2&quot;&gt;&lt;/import&gt;
    &lt;/question-element&gt;

&lt;/body&gt;</code></pre>
<p>Other import elements within a <em>resolution scope</em> can still reference their own module.</p>
<pre><code class="hljs html language-html">&lt;body template=&quot;module1&quot;&gt;

    &lt;!-- Place all of export-1 here --&gt;
    &lt;import name=&quot;export-1&quot;&lt;/import&gt;
    &lt;question-element&gt;
        &lt;!-- Place all of export-2 here --&gt;
        &lt;import name=&quot;export-2&quot; template=&quot;module2&quot;&gt;&lt;/import&gt;
    &lt;/question-element&gt;

&lt;/body&gt;</code></pre>
<h3 id="default-exports-and-imports">Default Exports and Imports</h3>
<p>HTML Modules may define contents without an export identifier - <a href="/tooling/oohtml/docs/html-modules#default-exports">Default Exports</a>. These arbitrary contents are also imported without an identifier.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module3&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <span class="hljs-comment">&lt;!-- This is part of the default export --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- This is part of the default export --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Place all of the default export here --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h3 id="module-reference-specificity">Module Reference Specificity</h3>
<p>Import elements that reference nested modules may define a fallback directive using the <code>template-specificity</code> attribute. A fallback directive allows the import resolution to fall back to ancestor modules to find the specified <em>export</em>.</p>
<p>The directive below is to fall back up to 2 steps from the right to find <code>export-2</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1/nonexistent/nonexistent&quot;</span> <span class="hljs-attr">template-specificity</span>=<span class="hljs-string">&quot;-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The directive below is to fall back up to 2 steps from the right, to at most 1 step from the left, to find <code>export-2</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1/nonexistent/nonexistent/nonexistent&quot;</span> <span class="hljs-attr">template-specificity</span>=<span class="hljs-string">&quot;1-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<blockquote>
  <p>The resolution of the above ends up at <code>module1/nonexistent</code> which is still <em>nonexisitent</em>. The import element is left unresolved.</p>
</blockquote>
<h2 id="dynamicity">Dynamicity</h2>
<p><em>Import slots</em> are resolved in realtime in response to a number of events.</p>
<ul>
<li><p>When the module reference - the <code>template</code> attribute - is changed, the import element is resolved again.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;import[template=&quot;module1&quot;]&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre>
<p>This also applies to all import elements within resolution scopes. Below, all import elements scoped to <code>&lt;body&gt;</code> will be resolved again.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;body&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre></li>
<li><p>On deleting the last of its slotted elements, an import element is automatically restored.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Remove the first element slotted</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;label&#x27;</span>).remove();
<span class="hljs-comment">// Remove the last element slotted</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>).remove();
<span class="hljs-comment">// The original import element should now be restored</span></code></pre></li>
<li><p>When exports and modules are added or removed, all import elements referencing them are reevaluated accordingly.</p>
<p>With the module addition below, all import elements referencing <code>module1/nonexistent</code> will now be resolved.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> nestedModule = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);
nestedModule.setAttribute(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;nonexistent&#x27;</span>);
nestedModule.content.append(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>));

<span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;template[name=&quot;module1&quot;]&#x27;</span>);
module1.content.append(nestedModule);</code></pre>
<p>With the module removal below, all import elements currently <em>resolved</em> from <code>module1</code> and its nested modules will now be restored.</p>
<pre><code class="hljs js language-js">module1.remove();</code></pre></li>
<li><p>When the external contents of a remote module become available, all import elements that depend on the loaded content will be resolved. (See <a href="/tooling/oohtml/docs/html-modules#module-events">Module Events</a>.)</p>
<p><strong>Remote file: /bundle.html</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-loaded&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><strong>Document:</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>template name=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module-remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>!-- This is resolved immediately --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-1&quot; template=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>!-- This is resolved as the targetted export becomes available --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-2&quot; template=&quot;module1/module-remote&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>!-- This is resolved as the targetted export becomes available --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-3&quot; template=&quot;module1/module-remote/module-loaded&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="slot-inheritance">Slot Inheritance</h2>
<p>An import element will work as a regular element until it is resolved, that is, replaced. Useful default content, along with attributes, may be displayed on its slot this way.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- An ixport element with default attribute and content --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;max-width:50px&quot;</span>&gt;</span>No image<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>A slot's default content and attributes may also be inheritted by slotted elements to persist the semantics of the slot.</p>
<ul>
<li><p><strong>Attributes</strong> - All attributes of an <code>&lt;import&gt;</code> element (other than the <code>name</code>, <code>template</code> and <code>template-specificity</code> attributes) are inheritted by slotted elements.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!-- The slotted element now inherits the style attribute  --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>img exportgroup=&quot;export-1&quot; src=&quot;logo.png&quot; style=&quot;max-width:50px&quot; /<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>When the attribute to inherit already exists on the element being slotted, one of the following happens:</p>
<ul>
<li>If the attribute is of space-delimitted attributes, like the <code>class</code> attribute, inheritted non-duplicate values are placed after existing values on the element being slotted.</li>
<li>If the attribute is of key/value attributes, like the <code>style</code> attribute, inheritted declarations are placed after existing declarations on the element being slotted (making CSS cascading work for the <code>style</code> attribute).</li>
<li>If the attribute is of single-value attributes, like the <code>id</code> attribute, the inheritted attribute value is made to replace exisiting value on the element being slotted.</li>
<li>All other attribute types are treated as single-value attributes.</li></ul></li>
<li><p><strong>Content</strong> - To inherit the default content of an import element, the import element will have to define its contents as exports and the element being slotted will have to reference this import element as its module and import its exports.</p>
<p>The import element will have to implicitly or explicitly define its contents as exports, thus acting as a module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!--
    The import element as a module
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-1&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;default-content&quot;<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The element being slotted will have to reference this import element as its module by defining a <code>template="@slot"</code> attribute (instead of pointing to an actual <code>&lt;template&gt;</code> element). Import elements defined within this element being slotted are resolved from the destination slot.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>template name=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>!--
    The element being slotted pointing to its destination slot
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot; template=&quot;@slot&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>!--
        The import element that actually imports the contents of its destination slot
        --<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>import name=&quot;default-content&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The default content is thus persisted on resolving the above.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot; template=&quot;@slot&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;default-content&quot;<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="isomorphic-rendering">Isomorphic Rendering</h2>
<p>When rendering happens on the server and has to be serialized for the browser to take over, import elements that are replaced on the server will need to be kept in some way in the serialized HTML output. This would enable the browser, on load, to <em>hydrate</em> the original import elements and map them in their replaced state to their currently slotted contents. With this, deleting a slot's contents, for example, can trigger the restoration of the hydrated <code>&lt;import&gt;</code> element.</p>
<p>HTML Imports makes it possible to serialize <code>&lt;import&gt;</code> elements as <em>comment nodes</em> (<code>&lt;!-- &lt;import&gt;&lt;/import&gt; --&gt;</code>) when rendering on the server. It can also be told in the browser to rehydrate these import elements on loading the serialized HTML output. This feature is turned on by setting the <code>isomorphic</code> directive to <code>1</code> or <code>true</code> on the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>.</p>
<p><strong>HTML to be rendered on the server</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>The serialized HTML output</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name=&quot;export-1&quot; id=&quot;headline&quot; style=&quot;color:red&quot;&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template=&quot;module1&quot; name=&quot;export-1&quot; style=&quot;color:blue&quot;&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>Hydrated slots in the browser</strong><br />
On loading the above serialized HTML output in the browser, find and delete the server-slotted element with ID <code>#headline</code>. The original <code>&lt;import&gt;</code> element should now be restored.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name=&quot;slot-1&quot; id=&quot;headline&quot; style=&quot;color:red&quot;&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">import</span>=<span class="hljs-string">&quot;slot-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template=&quot;module1&quot; name=&quot;slot-1&quot; style=&quot;color:blue&quot;&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../polyfill">OOHTML polyfill implementation</a> has full support for HTML Imports. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="/tooling/oohtml/docs/html-imports/#convention">element.import</a></strong> - The tag name for the import element. The standard import element is <code>&lt;import&gt;</code>, but the polyfill uses <code>&lt;html-import&gt;</code> by default. This can be reset to the standard tag name or to something else.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.import=import;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-imports/#convention">attr.importid</a></strong> - The <em>import ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.importid=data-name;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-imports/#module-reference-specificity">attr.templatespec</a></strong> - The <em>module specificity</em> attribute. The standard attribute is <code>template-specificity</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.templatespec=module-specificity;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span> <span class="hljs-attr">module-specificity</span>=<span class="hljs-string">&quot;0-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML META tag <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">here</a>.</p>

			</div>
		</template>

		<template name="html-modules">
			<div exportgroup="readme">

				<h1 id="html-modules">HTML Modules</h1>
<p>HTML's standard <code>&lt;template&gt;</code> elements are a special type of element that helps us hold independent, reusable HTML snippets. But a standard way to name and find these templates has been missing.</p>
<p>HTML Modules are a new DOM feature that lets us work with <code>&lt;template&gt;</code> elements and their contents using the <em>module</em>, <em>import</em> and <em>export</em> paradigm. It introduces a clear naming convention for easy access to these elements and for organizing them <em>meaningfully</em> in a document.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="/tooling/oohtml/docs/html-modules/#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Modules are designated using the <code>name</code> attribute - the <em>module identifier</em>. Their contents are regarded as <em>exports</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Exports may be more properly wrapped within an <code>&lt;export&gt;</code> element of a designated name - the <em>export identifier</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Or they may be individually <em>tagged</em> to an export identifier using the <code>exportgroup</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Contents not associated with an export identifier are regarded as <em>default exports</em>.</p>
<h3 id="module-nesting">Module Nesting</h3>
<p>For organizational purposes, modules may be nested.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-nested&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The absolute <em>module ID</em> of nested modules is written as a path expression, e.g <code>module1/module-nested</code>.</p>
<p>Unnested modules are called <em>top-level modules</em>.</p>
<h3 id="module-referencing">Module Referencing</h3>
<p>Modules can be referenced by their module ID from anywhere in a page.</p>
<p>Regular elements can point to a module that they may depend on in some way. For example, Custom Elements that implement the Shadow DOM often depend on markup stored in templates. These dependencies can now be maintained in the element's markup instead of hard-coding it to its internal JavaScript code.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Or in the case of a nested module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1/module-nested&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The internal JavaScript code for <code>&lt;my-prompt&gt;</code> can now simply depend on this module reference as seen in the <a href="/tooling/oohtml/docs/html-modules/#api">API section</a> below.</p>
<h2 id="remote-content">Remote Content</h2>
<p>Template elements may reference remote content using the <code>src</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-remote&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p><strong>Remote file: /bundle.html</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-loaded&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p>Remote contents automatically become the template's content on load.</p>
<blockquote>
  <p>The <code>src</code> attribute isn't honoured when a template already has content.</p>
</blockquote>
<h2 id="api">API</h2>
<p><em>HTML Modules</em> offers a set of APIs that lets us work with modules, imports and exports as objects and properties.</p>
<blockquote>
  <p>One advantage of Object-Orientend Development is that it minimizes selector-based queries.</p>
</blockquote>
<ul>
<li><p><strong>document.templates: Object</strong> - This is a <em>readonly</em> property on the <code>document</code> object that gives the document's top-level templates as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1; <span class="hljs-comment">// Returns the &quot;module1&quot; element in the markup somewhere above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.templates: Object</strong> - This is a <em>readonly</em> property on the <code>&lt;template&gt;</code> element that gives the template's own nested templates as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;
<span class="hljs-keyword">let</span> nestedModule = module1.templates[<span class="hljs-string">&#x27;module-nested&#x27;</span>]; <span class="hljs-comment">// Returns the nested &quot;module-nested&quot; element in the markup somewhere above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.exports: Object</strong> - This is a <em>readonly</em> property on the <code>&lt;template&gt;</code> element that gives the template's <em>exports</em> as an object. Each export is given as an <em>array</em> of elements.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;

<span class="hljs-comment">// Named exports</span>
<span class="hljs-keyword">let</span> questionExport = module1.exports.question; <span class="hljs-comment">// Returns the &quot;label&quot; and &quot;input&quot; elements in the markup somewhere above</span>
<span class="hljs-built_in">console</span>.log(questionExport.length); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">let</span> defaultExport = module1.exports.default; <span class="hljs-comment">// Returns the &quot;default&quot; export in the markup somewhere above</span>
<span class="hljs-built_in">console</span>.log(defaultExport.length); <span class="hljs-comment">// 1</span></code></pre></li>
<li><p><strong>Element.prototype.template: HTMLTemplateElement</strong> - This is a <em>readonly</em> property of any element that returns the element's module reference - the <code>&lt;template&gt;</code> element that may be referenced by the element as a dependency.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.template;</code></pre>
<p>Here's how this could be used in the internal JavaScript code of the <code>&lt;my-prompt&gt;</code> custom element.</p>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-prompt&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{&lt;pre&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>/**
 * Creates the Shadow DOM
 */
constructor() {
    super();
    // Get the referenced template element
    let moduleReference = this.template;
    // Clone its &quot;question&quot; export
    let shadowContent = moduleReference.exports.question.map(el =<span class="hljs-symbol">&amp;gt;</span> el.cloneNode(true));
    // Create Shadow DOM and send in the content
    let shadow =  this.attachShadow({mode: &#x27;open&#x27;});
    shadow.append(...shadowContent);
}<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span></span>&lt;/pre&gt;});</code></pre>
<p>Here's how the HTML consuming the component could look.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>!-- Flavour 1 of <span class="hljs-symbol">&amp;lt;</span>my-prompt<span class="hljs-symbol">&amp;gt;</span> --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>my-prompt template=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/my-prompt<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>!-- Flavour 2 of <span class="hljs-symbol">&amp;lt;</span>my-prompt<span class="hljs-symbol">&amp;gt;</span> --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>my-prompt template=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/my-prompt<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="module-events">Module Events</h2>
<p>The following events are fired on <code>&lt;template&gt;</code> elements with remote content.</p>
<ul>
<li><strong>load: Event</strong> - This event is fired on the <code>&lt;template&gt;</code> element on loading its remote content.</li>
<li><strong>loaderror: Event</strong> - This event is fired on the <code>&lt;template&gt;</code> element when there is an error loading its remote content.</li>
</ul>
<p>The following events are fired on the document object when the document's modules or their composition change.</p>
<ul>
<li><p><strong>templatemutation: Event</strong> - This event is fired on the <code>document</code> object when templates are added to or removed from the document, or when exports are added to or removed from a module. The <em>event</em> object has a <code>.detail</code> property that gives the details of the event.</p>
<ul>
<li><strong>event.detail.path: String</strong> - This gives the path to the event source, the module under which the event is fired. This is empty when top-level modules are added to or removed from the document.</li>
<li><strong>event.detail.addedExports: Array</strong> - This gives the list of exports added to a module. Each <em>entry</em> is an object describing the added export.<ul>
<li><strong>entry.name: String</strong> - The name of the export.</li>
<li><strong>entry.items: Array</strong> - Elements in the export.</li></ul></li>
<li><strong>event.detail.removedExports: Array</strong> - This gives the list of exports removed from a module. Each <em>entry</em> is an object describing the removed export.<ul>
<li><strong>entry.name: String</strong> - The name of the export.</li>
<li><strong>entry.items: Array</strong> - Elements in the export.</li></ul></li>
<li><strong>event.detail.addedTemplates: Array</strong> - This gives the list of templates added to a module or the top-level scope. Each <em>entry</em> is an object describing the added template.<ul>
<li><strong>entry.name: String</strong> - The name of the template.</li>
<li><strong>entry.item: HTMLTemplateElement</strong> - The template element.</li></ul></li>
<li><strong>event.detail.removedTemplates: Array</strong> - This gives the list of templates removed from a module or the top-level scope. Each <em>entry</em> is an object describing the removed template.<ul>
<li><strong>entry.name: String</strong> - The name of the template.</li>
<li><strong>entry.item: HTMLTemplateElement</strong> - The template element.</li></ul></li></ul>
<p>With the listener below, adding a new template to the document, or removing one, will be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;templatemutation&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>
<p>With the code below, the fired event's <code>.detail.path</code> property will be empty, while its <code>.detail.addedTemplates</code> property will give a list of one added template whose <em>name</em> is <code>module2</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);
template.setAttribute(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);
<span class="hljs-built_in">document</span>.body.append(template);</code></pre>
<p>With the code below, when the nested module is done loading its contents, its exports are given in a <code>templatemutation</code> event on its <code>.detail.addedExports</code> property. If loaded contents include template elements themselves, they will be given in the event's <code>.detail.addedTemplates</code> property. The event's <code>.detail.path</code> property itself will be <code>module2/module-remote</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export5&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export6&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module-remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong>templatecontentloaded: Event</strong> - This event is fired on the <code>document</code> object when a template completes loading its remote content. The event object has a <code>.detail</code> property that gives the template element and its path.</p>
<p>With the code below, when the nested template is done loading its contents, a report is logged to the console with path being <code>module2/module-remote</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;templatecontentloaded&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.detail.path, event.detail.template);
});</code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export5&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export6&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module-remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong>templatecontentloaderror: Event</strong> - This event is fired on the <code>document</code> object when a template fails loading its remote content. The event object has a <code>.detail</code> property that gives the template element and its path.</p></li>
</ul>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../polyfill">OOHTML polyfill implementation</a> has full support for the HTML Modules Specification. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#convention">attr.moduleid</a></strong> - The <em>module ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.moduleid=data-name;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#convention">attr.exportid</a></strong> - The <em>export ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.exportid=data-name;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#convention">attr.exportgroup</a></strong> - The <em>exportgroup</em> attribute. The standard attribute is <code>exportgroup</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.exportgroup=data-exportgroup;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#convention">attr.moduleref</a></strong> - The <em>module reference</em> attribute. The standard attribute is <code>template</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.moduleref=data-template;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#api">api.templates</a></strong> - The <em>templates</em> property exposed on the document object and on HTML template elements. The standard property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.templates=templatelist;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templatelist.module1;</code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#api">api.exports</a></strong> - The <em>exports</em> property exposed on HTML template elements. The standard property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.exports=exportlist;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> export1 = module1.exportlist.export1;</code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/html-modules/#api">api.moduleref</a></strong> - The <em>module reference</em> property exposed on HTML elements. The standard property is <code>template</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.moduleref=tpl;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.tpl;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">here</a>.</p>

			</div>
		</template>

		<template name="namespaced-html">
			<div exportgroup="readme">

				<h1 id="namespaced-html">Namespaced HTML</h1>
<p>Namespacing is a DOM feature that let's an element establish its own naming context for descendant elements. It makes it possible to keep IDs scoped to a context other than the document's global scope.</p>
<p>Namespaced HTML is a document that is structured as a hierarchy of <em>scopes</em> and <em>subscopes</em>.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="/tooling/oohtml/docs/namespaced-html/#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Namespaces are designated with the <code>namespace</code> <em>Boolean</em> attribute.</p>
<p>In the code below, the given ID is scoped to the element with the <code>namespace</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;some-id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>At scale, what we get is a <strong>hierarchy of <em>scopes</em> and <em>subscopes</strong></em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;continents&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;europe&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asia&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>A conceptual model of the hierarchy would be:</p>
<pre><code class="hljs html language-html">continents
|- europe
|   |- about
|   |- countries
|- asia
    |- about
    |- countries</code></pre>
<h2 id="namespaced-selectors">Namespaced Selectors</h2>
<p>Being able to layout elements in namespaces makes it possible to write collision-free CSS selectors. OOHTML introduces the concept of <em>Namespaced Selectors</em> which are regular CSS expressions written with a path notation.</p>
<p>Namespaced Selectors use the forward slash <code>/</code> to denote a namespace boundary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-id">#continents</span> / <span class="hljs-selector-id">#europe</span> / <span class="hljs-selector-id">#countries</span> {
    <span class="hljs-attribute">color</span>: darkblue;
}
<span class="hljs-selector-id">#continents</span> / <span class="hljs-selector-id">#asia</span> / <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">color</span>: orange;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>Namespacing would follow the same convention on existing DOM Selector APIs.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> aboutAsia = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#continents / #asia / #about&#x27;</span>);
<span class="hljs-keyword">let</span> divsAsia = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#continents / #asia / div&#x27;</span>);</code></pre>
<h2 id="api">API</h2>
<p><em>Namespaced HTML</em> offers an API for traversing namespaces as objects and properties.</p>
<blockquote>
  <p>One advantage of Object-Orientend Development is that it minimizes selector-based queries.</p>
</blockquote>
<ul>
<li><p><strong>document.namespace: Object</strong> - This <em>readonly</em> property gives the document's namespaced IDs - IDs scoped to the document - as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents; <span class="hljs-comment">// Returns the &quot;#continents&quot; element in the markup above</span></code></pre></li>
<li><p><strong>Element.prototype.namespace: Object</strong> - This <em>readonly</em> property gives an element's namespaced IDs - IDs scoped to the element - as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new &quot;namespace&quot; DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre></li>
</ul>
<h2 id="namespace-observability">Namespace Observability</h2>
<p>With observability at OOHTML's core, the <code>document.namespace</code> property and the <code>Element.prototype.namespace</code> property are implemented as <em>live objects</em> that can be observed for realtime changes in the namespace tree. Live objects are observed using the <a href="/tooling/oohtml/docs/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(continents.namespace, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
    });
});</code></pre>
<p>We could as well specify just the path to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, <span class="hljs-string">&#x27;africa&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// We&#x27;re now also logging the event&#x27;s value, that is, the element</span>
    <span class="hljs-built_in">console</span>.log(e.type, e.value);
});</code></pre>
<p>With the code above, adding a new ID - <code>africa</code> - to the <code>continents</code> namespace would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> section = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;section&#x27;</span>);
section.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;africa&#x27;</span>);
continents.append(section);</code></pre>
<p>Removing this element would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js">continents.namespace.africa.remove();</code></pre>
<p>To observe changes down the namespace hierarchy, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path<span class="hljs-comment">/*watch this*/</span>, e.value);
    });
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, [<span class="hljs-string">&#x27;africa&#x27;</span>, <span class="hljs-string">&#x27;namespace&#x27;</span>, <span class="hljs-string">&#x27;countries&#x27;</span>], <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.path, e.value));
});</code></pre>
<p>Other possibilities can be found in the Observer API documentation.</p>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../polyfill">OOHTML polyfill implementation</a> has good support for the Namespaced HTML Specification. With the exception of <a href="#namespaced-selectors">Namespaced Selectors</a>, all aspects of the specification are supported. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="/tooling/oohtml/docs/namespaced-html/#convention">attr.namespace</a></strong> - The <em>namespace keyword</em> attribute. The standard <em>namespace keyword</em> attribute is <code>namespace</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.namespace=data-namespace;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/namespaced-html/#convention">attr.id</a></strong> - The <em>namespaced-ID</em> attribute. The standard <em>namespaced-ID</em> attribute is <code>id</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;id01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;id02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/namespaced-html/#api">api.namespace</a></strong> - The <em>namespace</em> property exposed on the document object and on elements. The standard <em>namespace</em> property is <code>namespace</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.namespace=ns;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.ns.continents;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">here</a>.</p>

			</div>
		</template>

		<template name="polyfill">
			<div exportgroup="readme">

				<h1 id="installation-guide">Installation Guide</h1>
<p>This library is a polyfill for OOHTML.</p>
<h2 id="option-1-embed-as-script">Option 1: Embed As Script</h2>
<ul>
<li><strong>Embed The Complete Suite</strong> - Embed the build below for everything about OOHTML.</li>
</ul>
<pre><code class="hljs html language-html">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<ul>
<li><p><strong>Or Embed Individual Features</strong> - Find a build below for a specific OOHTML feature.</p>
<ul>
<li><strong><a href="/tooling/oohtml/docs/html-modules">HTML Modules</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/html-modules.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/html-imports">HTML Imports</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/html-imports.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/namespaced-html">Namespaced HTML</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/namespaced-html.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/the-state-api">The State API</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/state-api.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/subscript">Subscript</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/subscript.js"&gt;&lt;/script&gt;</code></li></ul></li>
</ul>
<h2 id="option-2-install-via-npm">Option 2: Install Via NPM</h2>
<pre><code class="hljs text language-text">$ npm i -g npm
$ npm i --save @webqit/oohtml</code></pre>
<p>The installed package is designed to be <em>initialized</em> with the <em>window</em> object of the current browser or server evironment.</p>
<ul>
<li><strong>Initialize the Complete Suite</strong> - Initialize the module below for everything about OOHTML.</li>
</ul>
<pre><code class="hljs js language-js">  <span class="hljs-comment">// Import</span>
  <span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/oohtml&#x27;</span>;
  <span class="hljs-comment">// Initialize</span>
  OOHTML(<span class="hljs-built_in">window</span>);</code></pre>
<h3 id="server-side-initialization">Server-Side Initialization</h3>
<p>To use OOHTML for server-side rendering, a library like <a href="https://github.com/jsdom/jsdom">jsdom</a> would be used to create a DOM instance, and the instance's <code>window</code> object would be used to initialize OOHTML.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import OOHTML</span>
<span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/oohtml&#x27;</span>;
<span class="hljs-comment">// Import jsDom</span>
<span class="hljs-keyword">import</span> jsdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jsdom&#x27;</span>;
<span class="hljs-comment">// Utilities we&#x27;ll need</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;

<span class="hljs-comment">// Read the HTML document file from the server</span>
<span class="hljs-keyword">const</span> documentFile = fs.readFileSync(path.resolve(<span class="hljs-string">&#x27;./index.html&#x27;</span>));
<span class="hljs-comment">// Instantiate jsdom so we can obtain the &quot;window&quot; for OOHTML</span>
<span class="hljs-comment">// Detailed instruction on setting up jsdom is available in the jsdom docs</span>
<span class="hljs-keyword">const</span> JSDOM = <span class="hljs-keyword">new</span> jsdom.JSDOM(documentFile.toString());

<span class="hljs-comment">// Initialize OOHTML...</span>
OOHTML(JSDOM.window);

<span class="hljs-comment">// And we can use OOHTML as normal</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">document</span> = JSDOM.window.document;
<span class="hljs-comment">// The document&#x27;s templates object...</span>
<span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;
<span class="hljs-comment">// etc</span></code></pre>
<h2 id="next-steps">Next Steps</h2>
<p>Be sure to check Polyfill Support for each of <a href="/tooling/oohtml/docs/">OOHTML's features</a> as documented alongside each feature. Then go native and build something!</p>

			</div>
		</template>

		<template name="subscript">
			<div exportgroup="readme">

				<h1 id="subscript">Subscript</h1>
<p>Subscript is a type of JavaScript runtime that lets us create scoped, <em>reactive</em> <code>&lt;script&gt;</code> elements across the UI. That gives us a UI binding language and the ability to have UI logic without involving an actual JavaScript file.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="/tooling/oohtml/docs/subscript/#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Subscript elements are defined with the <code>subscript</code> <em>MIME</em> type. They are scoped to their immediate host element instead of the global browser scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// ...</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They have their <code>this</code> variable implicitly bound to their host element.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">this</span>.id; <span class="hljs-comment">// alert</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They have their other variables resolved from the global scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Global scope</span>
    <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">&#x27;Task failed!&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = alertMessage; <span class="hljs-comment">// Task failed!</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They keep their variables from leaking out to the global scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Global scope</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// undefined</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>This lets us place behaviours of any form just where across the page we need them!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Global variable</span>
        <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">&#x27;Task failed!&#x27;</span>;
        <span class="hljs-comment">// The element&#x27;s state property</span>
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).state.message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message || alertMessage;
            <span class="hljs-built_in">console</span>.log(message);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Now, that was a bare-bones <code>#alert</code> component above! We could make it quite interactive by giving it a <em>remove</em> feature.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;close&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message;
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.message&#x27;</span>).innerHTML = message;
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.close&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<h2 id="runtime">Runtime</h2>
<p>Subscript is drastically different in behaviour from other JavaScript types (type="module", type="text/javascript", etc). The difference is that the script has the ability to observe the variables in its scope and respond to those changes. Changes that fire up the script this way are called <em>events</em>, and a script's response to these events is called the <em>event-based runtime</em>.</p>
<p>The event-based runtime can be understood from the code below. Take note of the first statement in the script which makes a reference to the <code>#alert</code> element's <code>.state.message</code> property.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;close&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message;
        <span class="hljs-built_in">this</span>.namespace.message.innerHTML = message;
        <span class="hljs-built_in">this</span>.namespace.close.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>This script will, at first, run top-down as with standard JavaScript. Then, it will begin to observe changes to the <code>this.state.message</code> reference - being an observable property. And when a change is detected, that particular statement will be reevaluated, and the new value is (re)assigned to the local <code>message</code> variable.</p>
<p>The following update to the element's state property will trigger that <em>event</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).state.message = <span class="hljs-string">&#x27;Task restarted!&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Now, the same event that changed the script's local <code>message</code> variable will go further to fire up subsequent statements that depend on it, in this case, leading to the new message being rendered. The third statement in this script is left untouched as it does not depend on the current change.</p>
<p>Thus, when events happen, the dependency chain within the script is followed even when broken down into local variables.</p>
<h3 id="observability">Observability</h3>
<p>The event-based runtime uses the <a href="/tooling/oohtml/docs/the-observer-api">Observer API</a> to observe objects in its scope whose properties can be observed. These are called <em>live objects</em>.</p>
<p>By default, the <code>this</code> object and the <code>document</code> object are observed. Thus, setting, updating or removing any of their properties using the Observer API will trigger the appropriate statement in a Subscript runtime.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global observableProperty:&#x27;</span>, <span class="hljs-built_in">document</span>.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own observableProperty:&#x27;</span>, <span class="hljs-built_in">this</span>.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;observableProperty&#x27;</span>, counter ++);
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(divElement, <span class="hljs-string">&#x27;observableProperty&#x27;</span>, counter2 ++);
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>But, as seen in the <code>#alert</code> example above, we can more easily set or remove observable properties using an element's <em>state object</em> (or the document's <em>state object</em>) as it internally uses the Observer API to apply property assignments and deletions.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global state.observableProperty:&#x27;</span>, <span class="hljs-built_in">document</span>.state.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own state.observableProperty:&#x27;</span>, <span class="hljs-built_in">this</span>.state.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">document</span>.state.observableProperty = counter ++;
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        divElement.state.observableProperty = counter2 ++;
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>In any of the cases above, we could get deep object mutations to be caught by the Subscript runtime using the Observer API.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global clock.time:&#x27;</span>, <span class="hljs-built_in">document</span>.clock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own state.clock.time:&#x27;</span>, <span class="hljs-built_in">this</span>.state.clock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Initial binding</span>
    Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;clock&#x27;</span>, {});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>.clock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(divElement.state.clock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="bindings">Bindings</h3>
<p>While the <code>this</code> object and the <code>document</code> object are automatically observed from within an element's Subscript runtime, it is also possible to bind other objects to the script's scope. This is done using a <code>.bind()</code> method on the element - to bind locally, or on the <code>document</code> object - to bind globally for all scripts in the document.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Globally-bound clock time:&#x27;</span>, globallyBoundClock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own-bound clock time:&#x27;</span>, locallyBoundClock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Create a collection of variables</span>
    <span class="hljs-keyword">let</span> globallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
    <span class="hljs-comment">// Bind them to all Subscript scopes in the document</span>
    <span class="hljs-built_in">document</span>.subscript.bind({globallyBoundClock});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Update existing binding</span>
        Observer.set(globallyBoundClock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
        <span class="hljs-comment">// Create new ones on the fly anytime</span>
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-comment">// Create a collection of variables</span>
    <span class="hljs-keyword">let</span> locallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
    <span class="hljs-comment">// Bind them to the current script</span>
    divElement.subscript.bind({locallyBoundClock});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Update existing binding for the current script</span>
        Observer.set(locallyBoundClock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
        <span class="hljs-comment">// Create new ones on the fly anytime</span>
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h4 id="api">API</h4>
<p>The following methods are used to dynamically bind observable variables to Subscript scopes.</p>
<ul>
<li><p><strong>document.subscript.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the document-level for all Subscript scopes across the document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind globally for all Subscript scopes in the document.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update existing variables in Subscript's global scope from properties of the given object or establish the given object as Subscript new global scope. Default: <code>false</code> - establish as new global scope.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
<span class="hljs-built_in">document</span>.subscript.bind({
    <span class="hljs-attr">globallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
<span class="hljs-built_in">document</span>.subscript.bind({
    <span class="hljs-attr">globallyBoundClock2</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>document.subscript.unbind(): Void</strong> - This method lets us unbind any existing binding from the document.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
<span class="hljs-built_in">document</span>.subscript.unbind();</code></pre></li>
<li><p><strong>Element.prototype.subscript.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the element-level. Objects bound here are automatically-observed in the element's <em>binding</em> script.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind to the element's Subscript scope.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update existing variables in the element's local scope from properties of the given object or establish the given object as the element's local scope. Default: <code>false</code> - establish as new scope.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
divElement.subscript.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
divElement.subscript.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>Element.prototype.subscript.unbind(): Void</strong> - This method lets us unbind any existing binding from an element's <em>binding</em> script.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
divElement.subscript.unbind();</code></pre></li>
</ul>
<h2 id="error-handling">Error Handling</h2>
<p>Subscript features a way to handle errors that may occur within scripts. By default, script errors are logged to the console. But they can be silently ignored by setting a <code>script.errors</code> directive on the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;chtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script.errors=0;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">this</span>.querySelectorSelectorSelector(<span class="hljs-string">&#x27;h1&#x27;</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Individual script tags may also be given an <code>errors</code> directive, to override the global <code>script.errors</code> directive for the script.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;chtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script.errors=0;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span> <span class="hljs-attr">binding</span> <span class="hljs-attr">errors</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">this</span>.querySelectorSelectorSelector(<span class="hljs-string">&#x27;h1&#x27;</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../polyfill">OOHTML polyfill implementation</a> has good support for Subscript. The polyfill additionally makes it possible to customise the follwoing areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="/tooling/oohtml/docs/subscript/#convention">selector.script</a></strong> - The CSS selector for matching the script element. The default selector is <code>script[type="subscript"]</code>. You may use a custom selector, like <code>script[is="my-script"][type="subscript"]</code>, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;selector.script=script[is=&#x27;my-script&#x27;][type=&#x27;reflex&#x27;];&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>script is=&quot;my-script&quot; type=&quot;subscript&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>script is=&quot;my-script&quot; type=&quot;subscript&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">here</a>.</p>

			</div>
		</template>

		<template name="the-observer-api">
			<div exportgroup="readme">

				<h1 id="the-observer-api">The Observer API</h1>
<p><a href="https://github.com/webqit/observer">Visit this project on Github</a>.</p>

			</div>
		</template>

		<template name="the-oohtml-meta-tag">
			<div exportgroup="readme">

				<h1 id="the-oohtml-meta-tag">The OOHTML Meta Tag</h1>
<p>OOHTML provides a meta tag for customizing its syntax or behaviour. It generally looks like this:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;prop1=val1; prop2=val2;&quot;</span>&gt;</span></code></pre>
<p><em>The actual configurable properties are documented across the various OOHTML features.</em></p>
<p>Customization can help you keep potential breaking changes under control when there is a change to the default syntax on future updates. For a new and fast-evolving technology, this should be expected.</p>
<p>Customization also lets you explore around the whole new idea, and this should hopefully bring new discoveries to the table. Feel free to bring your findings to the discussion at the <a href="https://discourse.wicg.io/t/proposal-chtml/4716">Web Platform Incubator Community Group</a>. You can always file an <a href="https://github.com/webqit/oohtml/issues">issue</a> to report a bug, ask a question, or raise a suggestion.</p>

			</div>
		</template>

		<template name="the-state-api">
			<div exportgroup="readme">

				<h1 id="the-state-api">The State API</h1>
<p>For so many reasons, we often have to deal with application data at the document and element levels. We either want to render data on an element or pass it down its subtree to be eventually rendered. The state of this data may be changing, and we may have to maintain some of it at each level. These are modern UI development paradigms that have not particularly been welcomed natively.</p>
<p>This specification defines proposed native primitives for implementing state and observability for modern "reactive" applications. These low-level APIs offer a baseline on which any design pattern, custom tooling or other high-level abstractions could be laid.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="/tooling/oohtml/docs/the-state-api/#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="document-level-state">Document-Level State</h2>
<p>Document-level state represents the global state of an application. This specification introduces a new <code>.state</code> property to the document object for managing document-wide state.</p>
<ul>
<li><p><strong>document.state: Object</strong> - This <em>readonly</em> property is an object whose properties are written to and read as-is, as with regular JavaScript objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
<span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span></code></pre></li>
<li><p><strong>document.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on the <code>document.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Thanks for visiting.&#x27;</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    },
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// {main, aside}</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Bonjour le Monde!&#x27;</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Bonjour le Monde!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>document.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from the document's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
<span class="hljs-built_in">document</span>.clearState();</code></pre></li>
</ul>
<h2 id="element-level-state">Element-Level State</h2>
<p>Element-level state represents the local state of an element. This specification introduces a new <code>.state</code> property to DOM elements for managing element-level state.</p>
<ul>
<li><p><strong>Element.prototype.state: Object</strong> - This <em>readonly</em> property is an object whose properties are written to and read as-is, as with regular JavaScript objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// -------</span>

<span class="hljs-comment">// Example usage - a simple toggle</span>
myCollapsible.onclick = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (myCollapsible.state.collapsed) {
        myCollapsible.style.height = <span class="hljs-string">&#x27;auto&#x27;</span>;
    } <span class="hljs-keyword">else</span> {
        myCollapsible.style.height = <span class="hljs-string">&#x27;0px&#x27;</span>;
    }
    myCollapsible.state.collapsed = !myCollapsible.state.collapsed;
};</code></pre></li>
<li><p><strong>Element.prototype.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on an element's <code>.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
myCollapsible.setState({
    <span class="hljs-attr">inView</span>: <span class="hljs-literal">true</span>,
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>Element.prototype.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from an element's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
myCollapsible.clearState();</code></pre></li>
</ul>
<h2 id="state-observability">State Observability</h2>
<p>The <code>document.state</code> property and the <code>Element.prototype.state</code> property are implemented as <em>live objects</em> that can be observed for property changes. Live objects are observed using the <a href="/tooling/oohtml/docs/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
    });
});</code></pre>
<p>We could as well specify just the path to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-string">&#x27;pageTitle&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
});</code></pre>
<p>With the code above, adding or updating the <code>pageTitle</code> property on the document's state object would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Bonjour!&#x27;</span>;</code></pre>
<p>Deleting this property would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">delete</span> <span class="hljs-built_in">document</span>.state.pageTitle;</code></pre>
<p>To observe changes down the state tree, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path<span class="hljs-comment">/*watch this*/</span>, e.value);
    });
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, [<span class="hljs-string">&#x27;pageContent&#x27;</span>, <span class="hljs-string">&#x27;aside&#x27;</span>], <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
});</code></pre>
<p>With the code above, mutating a nested property would trigger the observer.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// State object</span>
<span class="hljs-keyword">let</span> data = {
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Thanks for visiting.&#x27;</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    },
};
<span class="hljs-built_in">document</span>.setState(data);

<span class="hljs-comment">// Mutate pageContent afterwards...</span>
Observer.set(data.pageContent, <span class="hljs-string">&#x27;aside&#x27;</span>, <span class="hljs-string">&#x27;Related content...&#x27;</span>);</code></pre>
<h3 id="a-custom-element-example">A Custom Element Example</h3>
<p>The following example demonstrates state observability in a custom element. Our logic below helps keep the UI and application state in sync. Noteworthy is that we are reflecting the <code>collapsed</code> state in the <code>data-collapsed</code> attribute and keeping a part of that state - <code>content</code> - <em>bound</em> to a descendant element.</p>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

    <span class="hljs-comment">/**
     * Creates the Shadow DOM
     */</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-keyword">let</span> contentElement = <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.content&#x27;</span>);

        <span class="hljs-comment">// Observe state and get the UI synced</span>
        Observer.observe(<span class="hljs-built_in">this</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
            events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
                <span class="hljs-keyword">switch</span>(event.name) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;collapsed&#x27;</span>:
                        <span class="hljs-built_in">this</span>.style.height = event.value ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
                        <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-active&#x27;</span>, event.value ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;inView&#x27;</span>:
                        <span class="hljs-built_in">this</span>.style.animation = event.value ? <span class="hljs-string">&#x27;fadein 440ms&#x27;</span> : <span class="hljs-string">&#x27;fadeout 440ms&#x27;</span>;
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;content&#x27;</span>:
                        contentElement.setState(event.value);
                    <span class="hljs-keyword">break</span>;
                }
            });
        });

        <span class="hljs-comment">// Implement the logic for toggling collapsion</span>
        <span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });

        <span class="hljs-comment">// Implement the logic for detecting when in view</span>
        <span class="hljs-keyword">let</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">entries</span>) </span>{
            <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].isIntersecting) {
                <span class="hljs-built_in">this</span>.state.inView = entries[<span class="hljs-number">0</span>].intersectionRatio;
            }
        });
        io.observe(<span class="hljs-built_in">this</span>);
    }

});</code></pre>
<p>External code gets a standard way to infer the state of the <code>&lt;my-collapsible&gt;</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> myCollapsible = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>);
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed;
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView;</code></pre>
<p>External code gets a standard way to control state.</p>
<pre><code class="hljs js language-js">myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;</code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../polyfill">OOHTML polyfill implementation</a> has full support for The State API. The polyfill additionally makes it possible to customise following areas of its implementation of the API using the <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="/tooling/oohtml/docs/the-state-api/#api">api.state</a></strong> - The property name for exposing the <em>state object</em> on DOM elements and the document object. The standard property name is <code>state</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.state=stateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">myCollapsible.stateObject.collapsed = <span class="hljs-literal">true</span>;</code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/the-state-api/#api">api.setState</a></strong> - The <em>method name</em> for setting data on <em>state objects</em>. The standard <em>method name</em> is <code>setState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.setState=setStateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.setStateObject(data);</code></pre></li>
<li><p><strong><a href="/tooling/oohtml/docs/the-state-api/#api">api.clearState</a></strong> - The <em>method name</em> for clearing data from <em>state objects</em>. The standard <em>method name</em> is <code>clearState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.clearState=clearStateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.clearStateObject();</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/the-oohtml-meta-tag">here</a>.</p>

			</div>
		</template>
	</template>

	
