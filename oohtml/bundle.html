
	

	<template name="examples">
		<template name="jquery">
			<div exportgroup="readme">

				<h2 id="a-tooling-example">A Tooling Example</h2>
<p>Being a foundational technology, CHTML gives us every room to bring our own tooling. This example shows how we could use a DOM abstraction library, like jQuery, from scoped scripts.</p>
<p>Below, we're simply binding the <code>$</code> variable globally for use in every scoped script.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span>&gt;</span><span class="javascript">
            $(<span class="hljs-keyword">this</span>.namespace.message).html(message);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">document</span>.bind({<span class="hljs-attr">$</span>: <span class="hljs-built_in">window</span>.jQuery});
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#alert'</span>).bind({
            <span class="hljs-attr">message</span>: <span class="hljs-string">'This task is now complete!'</span>,
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Tooling can also help us acheive more efficient DOM manipulation. Generally, surgically updating the DOM may have performance implications on the UI, as arising from layout thrashing (see <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">this article</a> on Web Fundamentals). But we also don't need as much as a <em>Virtual DOM</em> for this. A technique like that of <a href="https://github.com/wilsonpage/fastdom">fast DOM</a> could just suffice.</p>
<p>This technique is natively implemented by the <a href="https://docs.web-native.dev/play-ui">PlayUI</a> library which has a jQuery-like API. We will now use PlayUI as a drop-in replacement for jQuery.</p>
<p><a href="https://web-native.dev/package/chtml/docs/demos/jquery.html">Check the live example here</a></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span>&gt;</span><span class="javascript">
            $(<span class="hljs-keyword">this</span>.namespace.message).html(message).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-comment">// Do something sync</span>
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/@web-native-js/play-ui/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">document</span>.bind({<span class="hljs-attr">$</span>: <span class="hljs-built_in">window</span>.WebNative.PlayUI});
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#alert'</span>).bind({
            <span class="hljs-attr">message</span>: <span class="hljs-string">'This task is now complete!'</span>,
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>

			</div>
		</template>

		<div exportgroup="readme">

			<h1 id="examples">Examples</h1>
<p>Here are a few examples that you can try right now. You can simply copy and paste these codes to view on your browser. And you may edit your page live from the browser console.</p>
<p>Be sure to include the CHTML polyfill from the <a href="../installation/README.md">installation page</a>.</p>
<ul>
<li><a href="todo/README.md">A TODO List Example</a></li>
<li><a href="spa/README.md">An SPA Example</a></li>
<li><a href="jquery/README.md">A jQuery Example</a></li>
</ul>

		</div>

		<template name="spa">
			<div exportgroup="readme">

				<h2 id="a-single-page-application-example">A Single Page Application Example</h2>
<p>This example makes an SPA of <em>templates and slots</em> composition. Below, we're using the two <code>&lt;template&gt;</code> elements to each represent a route - each is holding partials that are unique to a route. Then we point the <code>&lt;body&gt;</code> element to implement the <code>&lt;template&gt;</code> whose namespace matches the current URL.</p>
<p><a href="https://web-native.dev/package/chtml/docs/demos/spa.html">Check the live example here</a></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"route"</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"home"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">partials-slot</span>=<span class="hljs-string">"headline"</span>&gt;</span>
                    Welcome Home!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">partials-slot</span>=<span class="hljs-string">"content"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/about"</span>&gt;</span>About Me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"about"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">partials-slot</span>=<span class="hljs-string">"headline"</span>&gt;</span>
                    About Me!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">partials-slot</span>=<span class="hljs-string">"content"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>Back to Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"route/home"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"banner"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">partials-slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"headline"</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">partials-slot</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">partials-slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"content"</span>&gt;</span>Page not Found!<span class="hljs-tag">&lt;/<span class="hljs-name">partials-slot</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'popstate'</span>, e =&gt; {
                <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">document</span>.location.hash.substr(<span class="hljs-number">1</span>);
                <span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">'template'</span>, <span class="hljs-string">'route'</span> + path);
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Navigate to a route that does not begin with <code>#/home</code> or <code>#/about</code>, you should see the default content showing <em>404</em>.</p>

			</div>
		</template>

		<template name="todo">
			<div exportgroup="readme">

				<h2 id="a-todo-list-example">A TODO List Example</h2>
<p>Below is a TODO list composed from a JavaScript array using Scoped HTML, Scoped JS in combination with the HTML Partials API.</p>
<p>It features the ability to add/remove items. For the <em>remove</em> feature, we'd let the <code>&lt;li&gt;</code> element expose a <em>remover</em> button that the main <code>&lt;ul&gt;</code> logic can bind to the <code>removeItem()</code> method of the TODO application. For the <em>add</em> feature, we'd add a button to the TODO container that calls the <code>addItem()</code> method of the TODO application.</p>
<p>We've also decided to use <a href="https://docs.web-native.dev/observer">the Observer API</a> and <a href="https://docs.web-native.dev/play-ui/api/dom/itemize">PlayUI's <code>.itemize()</code></a> method that provides a simple way to keep the list container in sync with application items.</p>
<p><a href="https://web-native.dev/package/chtml/docs/demos/todo.html">Check the live example here</a></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>A TODO Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"items"</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">namespace</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"desc"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"remover"</span>&gt;</span>Remove<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span>&gt;</span><span class="actionscript">
                    <span class="hljs-keyword">this</span>.namespace.desc.innerHTML = desc;
                </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todo"</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"items"</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">scoped:id</span>=<span class="hljs-string">"adder"</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Ypu can also add items from the console. Open your console and type: <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>todoItems.push({desc:"New Item"})<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span>&gt;</span><span class="javascript">
                <span class="hljs-keyword">this</span>.namespace.title.innerHTML = title;
                $(<span class="hljs-keyword">this</span>.namespace.items).itemize(items, (el, data, index, isUpdate) =&gt; {
                    el.bind(data);
                    $(el).attr(<span class="hljs-string">'data-index'</span>, index);
                    <span class="hljs-keyword">if</span> (!isUpdate) {
                        <span class="hljs-comment">// This means el was newly generated by itemize()</span>
                        el.namespace.remover.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; removeItem(el.getAttribute(<span class="hljs-string">'data-index'</span>)));
                    }
                });
                <span class="hljs-keyword">this</span>.namespace.adder.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; addItem());
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/@web-native-js/observer/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/@web-native-js/play-ui/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/@web-native-js/chtml/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Declare our tools</span>
            <span class="hljs-keyword">let</span> Obs = <span class="hljs-built_in">window</span>.WN.Observer;
            <span class="hljs-keyword">let</span> $ = <span class="hljs-built_in">window</span>.WN.PlayUI;

            <span class="hljs-comment">// Create the app</span>
            <span class="hljs-keyword">let</span> todo = {
                $,
                <span class="hljs-attr">title</span>: <span class="hljs-string">'My TODO'</span>,
                <span class="hljs-attr">items</span>: [
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">'Task-1'</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">'Task-2'</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">'Task-3'</span>},
                ],
                addItem() {
                    <span class="hljs-built_in">window</span>.todoItems.push({<span class="hljs-attr">desc</span>: prompt(<span class="hljs-string">'Task description'</span>),});
                },
                removeItem(index) {
                    <span class="hljs-built_in">window</span>.todoItems.splice(index, <span class="hljs-number">1</span>);
                },
            };

            <span class="hljs-comment">// Bind the app to the UI</span>
            <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#todo'</span>).bind(todo);

            <span class="hljs-comment">// Make the items available globally</span>
            <span class="hljs-comment">// so that we can always manipulate them</span>
            <span class="hljs-built_in">window</span>.todoItems = Obs.proxy(todo.items);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

			</div>
		</template>
	</template>

	<template name="html-partials">
		<div exportgroup="readme">

			<h1 id="html-partials">HTML Partials</h1>
<p>HTML Partials is a new templating feature that abstracts over the <a href="../modular-naming-and-apis/README.md#named-templates">Named Template Specification</a> to provide incredibly powerful composability in the simple language of tags and attributes.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> but currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="templates-imports-and-exports">Templates, Imports and Exports</h2>
<p>The Named Template Specification introduces the <em>import</em> and <em>export</em> terminology to working with <code>&lt;template&gt;</code> elements and their contents.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span>This is export1 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span>This is export2 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-3"</span>&gt;</span>This is export3 in template2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-4"</span>&gt;</span>This is export4 in template2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>HTML Partials makes it possible for an element in the main document to point to the <code>&lt;template&gt;</code> element and import its <em>exports</em>. </p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to a template element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I have imports<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place export-1 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Place export-2 here --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>Slotting</em> takes place and the <code>&lt;import&gt;</code> elements are replaced by the template's exports.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I have imports<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span>This is export1 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span>This is export2 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The element is said to have <em>implemented</em> the <code>&lt;template&gt;</code>. The element is known as an <em>implementation block</em>.</p>
<p>HTML Partials also supports <em>default exports</em> - a template's exports without an explicit <code>export</code> attribute or with an <code>export</code> attribute of "default". Default exports are slotted into the <em>default import slot</em> in the implementation block.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to a template element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place default exports here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"default"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>By default, <em>import slots</em> are scoped to their containing implementation block. But the <code>&lt;import&gt;</code> element may also be used independently of an implementation block to point to its own <code>&lt;template&gt;</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to a template element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I have imports<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place export-1 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Point to template2 and place export-3 here --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-3"</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h2 id="dynamicity">Dynamicity</h2>
<p><em>Import slots</em> are resolved in realtime.</p>
<ul>
<li><p>The <code>template</code> attribute can be dynamically set. Import slots are evaluated accordingly.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div[template="template1"]'</span>).setAttribute(<span class="hljs-string">'template'</span>, <span class="hljs-string">'template1/extended/nonexistent'</span>);</code></pre></li>
<li><p>Template elements can be added or removed dynamically. Import slots that depend on them are evaluated accordingly.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'template[name="template1"]'</span>).remove();</code></pre></li>
<li><p>Import elements that don't find a matching <em>export</em> in their implied source templates are left in place or are automatically restored if previously resolved.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1/extended/nonexistent"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- This import slot won't be resolved, or will be restored if previously resolved --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-2"</span> <span class="hljs-attr">template-fallback</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li>
<li><p>Import elements that are resolved from nested templates may define a fallback directive. A fallback directive allows the import resolution to fall back to ancestor templates where a matching <em>export</em> is not defined in the implied source template.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1/extended/nonexistent"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Fall back up to 2 steps backwards to find export-2 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-2"</span> <span class="hljs-attr">template-fallback</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li>
<li><p>On deleting the last of its slotted elements, an import element will be automatically restored.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The original import element for this slot will be restored</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div[template="template1"] div[export="export-2"'</span>).remove();</code></pre></li>
</ul>
<h2 id="slot-inheritance">Slot Inheritance</h2>
<p>An import element may have default content that displays before slotting takes place. It may also have attributes.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- An ixport element with default attribute and content --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"import-1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span>No results<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Now, these default attributes and content can be inheritted by slotted elements.</p>
<ul>
<li><p><strong>Attributes</strong> - An <code>&lt;import&gt;</code>'s attributes (other than the <code>name</code> and <code>template</code> attributes) are inheritable by slotted elements.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template="template1"<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!-- The slotted element now inherits the style attribute  --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div export="export-1" style="color:red"<span class="hljs-symbol">&amp;gt;</span>This is snippet 1<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<ul>
<li>On inheriting single-value attributes, like the <code>id</code> attribute, a replacement will be made where the slotted element has an existing attribute.</li>
<li>On inheriting space-delimitted attributes, like the <code>class</code> attribute, new and non-duplicate values are placed after any existing values that may be on the slotted element.</li>
<li>On inheriting key/value attributes, like the <code>style</code> attribute, new declarations are placed after any existing declarations that may be on the slotted element (making CSS cascading work for the <code>style</code> attribute).</li></ul></li>
<li><p><strong>Content</strong> - To inherit the default content of an import element, the import element will have to act as a <code>&lt;template&gt;</code> element while the slotting element as an implementation block for the import element.</p>
<p>To act as a <code>&lt;template&gt;</code> element, the import element will have to implicitly or explicitly define its default contents as exports.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template="template2"<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!--
    The import element with default content
    defined in the format of a <span class="hljs-symbol">&amp;lt;</span>template<span class="hljs-symbol">&amp;gt;</span>
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>import name="export-1"<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div export="default-content"<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>To act as an implementation block, the slotting element will have to define a <code>template</code> attribute but set it to the keyword <code>@slot</code> (instead of pointing to an actual <code>&lt;template&gt;</code> element), then define its own import elements that actually import the default content from off the slot.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>template name="template2"<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>!--
    The slotting element
    now acting as an implementation block
    for its destination slot
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div export="export-1" template="@slot"<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>import name="default-content"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>After slotting takes place, the final composition should look like:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template="template2"<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div export="export-1" template="@slot"<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div export="default-content"<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="responsive-imports">Responsive Imports</h2>
<p>Import elements may depend on templates with remote exports, and they would be resolved as soon as those contents are loaded. (See <a href="../named-templates/README.md#the-named-templates-api">Template Events</a>.)</p>
<p>**Remote file: <a href="http://localhost/templates.html**">http://localhost/templates.html**</a></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"extended"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><strong>Document: http://localhost</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-6"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template3"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/templates.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Now, we would expect the second import slot to be resolved before the first.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template2/template3/extended"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h2 id="isomorphic-rendering">Isomorphic Rendering</h2>
<p>When rendering happens on the server and has to be serialized for the browser to take over, the browser must still be able to maintain references to all <code>&lt;import&gt;</code>s, even those replaced on the server. HTML Partials addresses this by serializing <code>&lt;import&gt;</code> elements as <em>comment nodes</em> (<code>&lt;!-- &lt;import&gt;&lt;/import&gt; --&gt;</code>) with a view to recreating the original import elements from these comment nodes on getting to the browser. This way, composition is able to continue. Thus, in the browser, deleting a server-slotted element, for example, should trigger the restoration of the original <code>&lt;import&gt;</code> element; changing the <code>template</code> attribute of an element should get its import slots re-evaluated.</p>
<p><strong>Before Rendering on the Server</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"headline"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>After Rendering on the Server</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"headline"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name="export-1" id="headline" style="color:red"&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template="template1" name="export-1" style="color:blue"&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>Now on the Browser</strong><br />
Find and delete the server-slotted element with ID <code>#headline</code>. The original <code>&lt;import&gt;</code> element should now be restored and ready to be replaced the next time composition takes place.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"slot-1"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"headline"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name="slot-1" id="headline" style="color:red"&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">import</span>=<span class="hljs-string">"slot-1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template="template1" name="slot-1" style="color:blue"&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>Enabliing Import Serialization</strong><br />
Since slots serialization is only necessary for isomorphic pages, this feature is designed to be explicitly turned on on the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"isomorphic=true;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../installation/README.md">OOHTML polyfill implementation</a> has full support for HTML Partials. The polyfill additionally makes it possible to customise much of its implementation of the syntax using the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>. Much of this customization is done at the <a href="../named-templates/README.md#polyfill-support">Named Templates</a> level. The following are additional areas of customization:</p>
<ul>
<li><p><strong><a href="#templates-imports-and-exports">tag.import</a></strong> - The tag name for defining the import element. The standard element name is <code>import</code>, but this implementation currently only works with a custom element, which is <code>wq-import</code> by default. You may specify a different element name where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"tag.import=oohtml-import;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">oohtml-import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">oohtml-import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="../the-oohtml-meta-tag/README.md">here</a>.</p>

		</div>
	</template>

	<template name="installation">
		<div exportgroup="readme">

			<h1 id="installation-guide">Installation Guide</h1>
<p>This library is a polyfill for the <a href="https://discourse.wicg.io/t/proposal-chtml/4716">proposed</a> OOHTML suite.</p>
<h2 id="on-this-page">On this Page</h2>
<ul>
<li><a href="#embed-as-script">Embed As Script</a></li>
<li><a href="#install-via-npm">Install Via NPM</a><ul>
<li><a href="#server-side-initialization">Server-Side Initialization</a></li></ul></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="embed-as-script">Embed As Script</h2>
<ul>
<li><strong>Embed The Complete Suite</strong> - Embed the build below for everything about OOHTML.</li>
</ul>
<pre><code class="hljs html language-html">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/@webqit/oohtml/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<ul>
<li><p><strong>Embed Individual Features</strong> - Find a build below for a specific OOHTML feature.</p>
<ul>
<li><p><strong><a href="../namespaced-html/README.md">Namespaced HTML</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/namespaced-html.js"&gt;&lt;/script&gt;</code></p></li>
<li><p><strong><a href="../named-templates/README.md">Named Templates</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/named-templates.js"&gt;&lt;/script&gt;</code></p></li>
<li><p><strong><a href="../the-state-api/README.md">The State API</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/state.js"&gt;&lt;/script&gt;</code></p></li>
<li><p><strong><a href="../scoped-scripts/README.md">Scoped Scripts</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/scoped-scripts.js"&gt;&lt;/script&gt;</code></p></li>
<li><p><strong><a href="../html-partials/README.md">HTML Partials</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/html-partials.js"&gt;&lt;/script&gt;</code></p></li></ul></li>
</ul>
<h2 id="install-via-npm">Install Via NPM</h2>
<pre><code class="hljs text language-text">$ <span class="hljs-built_in">npm</span> i -g <span class="hljs-built_in">npm</span>
$ <span class="hljs-built_in">npm</span> i --save @webqit/oohtml</code></pre>
<p>The installed package is designed to be <em>initialized</em> with the <em>window</em> object of the current browser or server evironment.</p>
<ul>
<li><strong>Initialize the Complete Suite</strong> - Initialize the module below for everything about OOHTML.</li>
</ul>
<pre><code class="hljs js language-js">  <span class="hljs-comment">// Import</span>
  <span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">'@webqit/oohtml'</span>;
  <span class="hljs-comment">// Initialize</span>
  OOHTML(<span class="hljs-built_in">window</span>);</code></pre>
<h3 id="server-side-initialization">Server-Side Initialization</h3>
<p>To use OOHTML for server-side rendering, a library like <a href="https://github.com/jsdom/jsdom">jsdom</a> would be used to create a DOM instance, and the instance's <code>window</code> object would be used to initialize OOHTML.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import OOHTML</span>
<span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">'@webqit/oohtml'</span>;
<span class="hljs-comment">// Import jsDom</span>
<span class="hljs-keyword">import</span> jsdom <span class="hljs-keyword">from</span> <span class="hljs-string">'jsdom'</span>;
<span class="hljs-comment">// Utilities we'll need</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-comment">// Read the HTML document file from the server</span>
<span class="hljs-keyword">const</span> documentFile = fs.readFileSync(path.resolve(<span class="hljs-string">'./index.html'</span>));
<span class="hljs-comment">// Instantiate jsdom so we can obtain the "window" for OOHTML</span>
<span class="hljs-comment">// Detailed instruction on setting up jsdom is available in the jsdom docs</span>
<span class="hljs-keyword">const</span> JSDOM = <span class="hljs-keyword">new</span> jsdom.JSDOM(documentFile.toString());

<span class="hljs-comment">// Initialize OOHTML...</span>
OOHTML(JSDOM.window);

<span class="hljs-comment">// And we can use OOHTML as normal</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">document</span> = JSDOM.window.document;
<span class="hljs-comment">// The document's templates object...</span>
<span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;
<span class="hljs-comment">// etc</span></code></pre>
<h2 id="next-steps">Next Steps</h2>
<p>Be sure to check Polyfill Support for each of <a href="../README.md">OOHTML's features</a> as documented alongside each feature.</p>

		</div>
	</template>

	<template name="named-templates">
		<div exportgroup="readme">

			<h1 id="named-templates">Named Templates</h1>
<p>HTML's standard <code>&lt;template&gt;</code> elements are a special type of element that helps us hold independent, reusable HTML snippets. But a standard way to name and find these templates has been missing.</p>
<p>Named Templates follow a naming convention that makes it easier to access them and their contents, and to organize them <em>meaningfully</em> in a document.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> but currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Templates are named using the <code>name</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>For organizational purposes, templates may be nested. Unnested templates are called <em>top-level templates</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"extended"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>This convention also introduces the <em>imports</em> and <em>exports</em> terminology for snippets defined in a template.</p>
<h3 id="imports-and-exports">Imports and Exports</h3>
<p>Independent snippets are kept within a template with a view to being <em>imported</em> into strategic places across the rendered document. These snippets are considered <em>exports</em>.</p>
<p>Exports are named using the <code>export</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span>This is snippet 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span>This is snippet 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>An <em>export ID</em> may span multiple snippets - usually when intended to be imported together.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"question"</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"age"</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"question"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"anotherExport"</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Snippets may be left unnamed; these are taken as <em>default exports</em>. Default exports implicitly have the export ID "default".</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is part of the default export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"default"</span>&gt;</span>This is also part of the default export, as explicitly named<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<h2 id="template-dependency-attribute">Template Dependency Attribute</h2>
<p>Regular elements may hold a reference to a <code>&lt;template&gt;</code> element where they depend on a template for rendering. For example, Custom Elements that implement the Shadow DOM often depend on markup stored in a template. These dependencies would be, in many cases, better maintained in the element's markup than in application code.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>A path expression is used to reference nested templates.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1/extended"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h2 id="remote-content">Remote Content</h2>
<p>Template elements may reference remote content using the <code>src</code> attribute.</p>
<p>**Remote file: <a href="http://localhost/templates.html**">http://localhost/templates.html**</a></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"extended"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><strong>Document: http://localhost</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/templates.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-6"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<h2 id="the-named-templates-api">The Named Templates API</h2>
<p><em>Named Templates</em> offers a set of APIs that puts templates and their exports up as objects, to facilitate Object-Orientend Development and to minimize selector-based queries.</p>
<ul>
<li><p><strong>document.templates: Object</strong> - This <em>readonly</em> property is a reflection of the state of the document's top-level templates.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1; <span class="hljs-comment">// Returns the "template1" element in the markup above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.templates: Object</strong> - This <em>readonly</em> property (<code>&lt;template&gt;.templates</code>) is a reflection of the state of a template's own nested templates.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;
<span class="hljs-keyword">let</span> extendedTemplate = template1.templates.extended; <span class="hljs-comment">// Returns the nested "extended" element in the markup above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.exports: Object</strong> - This <em>readonly</em> property (<code>&lt;template&gt;.exports</code>) is a reflection of the state of a template's exports. Each export is given as an <em>array</em> of elements.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;

<span class="hljs-comment">// Named exports</span>
<span class="hljs-keyword">let</span> questionExport = template1.exports.question; <span class="hljs-comment">// Returns the "label" and "input" elements in the markup above</span>
<span class="hljs-built_in">console</span>.log(questionExport.length); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">let</span> anotherExport = template1.exports.anotherExport; <span class="hljs-comment">// Returns the "anotherExport" element in the markup above</span>
<span class="hljs-built_in">console</span>.log(anotherExport.length); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// Default exports</span>
<span class="hljs-keyword">let</span> defaultExport = template1.exports.default; <span class="hljs-comment">// Returns the two "div" elements in the second markup above</span>
<span class="hljs-built_in">console</span>.log(defaultExport.length); <span class="hljs-comment">// 2</span></code></pre></li>
<li><p><strong>Element.prototype.template: HTMLTemplateElement</strong> - This <em>readonly</em> property (<code>&lt;element&gt;.template</code>) is a reference to a <code>&lt;template&gt;</code> element that may be referenced by an element as a dependency.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.template;</code></pre>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">'my-prompt'</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{&lt;pre&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>/**
 * Creates the Shadow DOM
 */
constructor() {
    super();
    let templateDependency = this.template;
    let shadowContent = templateDependency.exports.question.map(el =<span class="hljs-symbol">&amp;gt;</span> el.cloneNode(true));
    let shadow =  this.attachShadow({mode: 'open'});
    shadow.append(...shadowContent);
}<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span></span>&lt;<span class="hljs-regexp">/pre&gt;});</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>!-- Flavour 1 of <span class="hljs-symbol">&amp;lt;</span>my-prompt<span class="hljs-symbol">&amp;gt;</span> --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>my-prompt template="template1"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/my-prompt<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>!-- Flavour 2 of <span class="hljs-symbol">&amp;lt;</span>my-prompt<span class="hljs-symbol">&amp;gt;</span> --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>my-prompt template="template2"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/my-prompt<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="template-tree-observability">Template Tree Observability</h2>
<p>When templates - both <em>top-level</em> and nested - are added or removed on the document, events are fired on the document object.</p>
<ul>
<li><p><strong>templateadded: Event</strong> - This event is fired when a template is added to the document. The event object has a <code>.detail</code> property that gives the added template element and its nesting path.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'templateadded'</span>, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail.path, event.detail.template);
});</code></pre>
<p>With the code above, adding a new template - <code>template2</code> - to the document would be reported in the console with path being <code>template2</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'template'</span>);
template.setAttribute(<span class="hljs-string">'name'</span>, <span class="hljs-string">'template2'</span>);
<span class="hljs-built_in">document</span>.body.append(template);</code></pre>
<p>With the code above, when the nested template - <code>template3</code> - completes loading its contents, a new template - <code>extended</code> - would have been added to the document and a report is logged to the console with path being <code>template2/template3/extended</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-6"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template3"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/templates.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong>templateremoved: Event</strong> - This event is fired when a template is removed from the document. The event object has a <code>.detail</code> property that gives the removed template element and its nesting path.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'templateremoved'</span>, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail.path, event.detail.template);
});</code></pre>
<p>With the code above, removing a template - the nested <code>template1</code> - from the document would be reported in the console with path being <code>template1/extended</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.templates.template1.templates.extended.remove();</code></pre></li>
<li><p><strong>templatecontentloaded: Event</strong> - This event is fired when a template completes loading its remote content. The event object has a <code>.detail</code> property that gives the removed template element and its nesting path.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'templatecontentloaded'</span>, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail.path, event.detail.template);
});</code></pre>
<p>With the code above, when the nested template - <code>template3</code> - completes loading its contents, a report is logged to the console with path being <code>template2/template3</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-6"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template3"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/templates.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
</ul>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../installation/README.md">OOHTML polyfill implementation</a> has full support for the Named Templates Specification. The polyfill additionally makes it possible to customise much of its implementation of the syntax using the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>. The following are areas of customization:</p>
<ul>
<li><p><strong><a href="#convention">attr.templatename</a></strong> - The <em>template name</em> attribute. The standard <em>template name</em> attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"attr.templatename=data-name;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#imports-and-exports">attr.export</a></strong> - The <em>export ID</em> attribute. The standard <em>export ID</em> attribute is <code>export</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"attr.export=data-export;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-export</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-export</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#template-dependency-attribute">attr.templatedep</a></strong> - The <em>template dependency</em> attribute. The standard <em>template dependency</em> attribute is <code>template</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"attr.templatedep=data-template;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-template</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#the-named-templates-api">api.templates</a></strong> - The <em>templates</em> property exposed on the document object and on HTML template elements. The standard <em>templates</em> property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.templates=templatelist;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templatelist.template1;</code></pre></li>
<li><p><strong><a href="#the-named-templates-api">api.exports</a></strong> - The <em>exports</em> property exposed on HTML template elements. The standard <em>exports</em> property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.exports=exportlist;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> export1 = template1.exportlist.export1;</code></pre></li>
<li><p><strong><a href="#the-named-templates-api">api.templatedep</a></strong> - The <em>template dependency</em> property exposed on HTML elements. The standard <em>template dependency</em> property is <code>template</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.templatedep=tpl;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.tpl;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="../the-oohtml-meta-tag/README.md">here</a>.</p>

		</div>
	</template>

	<template name="namespaced-html">
		<div exportgroup="readme">

			<h1 id="namespaced-html">Namespaced HTML</h1>
<p>Namespacing is a DOM feature that let's an element establish its own naming context for descendant elements. It makes it possible to keep IDs scoped to a context other than the document's global scope.</p>
<p>Namespaced HTML is a document that is structured as a hierarchy of <em>scopes</em> and <em>subscopes</em>.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> but currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Namespaces are designated with the <code>namespace</code> <em>Boolean</em> attribute.</p>
<p>In the code below, the given ID is scoped to the element with the <code>namespace</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"some-id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>At scale, what we get is a <strong>hierarchy of <em>scopes</em> and <em>subscopes</strong></em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"continents"</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"europe"</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countries"</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"asia"</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countries"</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>A conceptual model of the hierarchy would be:</p>
<pre><code class="hljs html language-html">continents
|- europe
|   |- about
|   |- countries
|- asia
    |- about
    |- countries</code></pre>
<h2 id="namespaced-selectors">Namespaced Selectors</h2>
<p>Being able to layout elements in namespaces makes it possible to write collision-free CSS selectors. OOHTML introduces the concept of <em>Namespaced Selectors</em> which are regular CSS expressions written with a path notation.</p>
<p>Namespaced Selectors use the forward slash <code>/</code> to denote a namespace boundary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
#continents / #europe / #countries {
    color: darkblue;
}
#continents / #asia / div {
    color: orange;
}
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>Namespacing would follow the same convention on existing DOM Selector APIs.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> aboutAsia = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#continents / #asia / #about'</span>);
<span class="hljs-keyword">let</span> divsAsia = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'#continents / #asia / div'</span>);</code></pre>
<h2 id="namespace-apis">Namespace APIs</h2>
<p><em>Namespaced HTML</em> offers a set of APIs for traversing namespaces as objects and properties.</p>
<ul>
<li><p><strong>document.namespace: Object</strong> - This <em>readonly</em> property is a reflection of the state of the document's namespaced IDs - IDs scoped to the document.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents; <span class="hljs-comment">// Returns the "#continents" element in the markup above</span></code></pre></li>
<li><p><strong>Element.prototype.namespace: Object</strong> - This <em>readonly</em> property is a reflection of the state of an element's namespaced IDs.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the "continents" article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new "namespace" DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre>
<blockquote>
  <p>An object tree helps to facilitate Object-Orientend Development and minimize selector-based queries. It also turns out to offer better DOM performance than selector-based DOM traversal as we are practically not querying the DOM to reach elements.</p>
</blockquote></li>
</ul>
<h2 id="namespace-observability">Namespace Observability</h2>
<p>With observability at OOHTML's core, the <code>document.namespace</code> property and the <code>Element.prototype.namespace</code> property are implemented as <em>live objects</em> that can be observed for realtime changes in the namespace tree. Live objects are observed using the <a href="../the-observer-api/README.md">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(continents.namespace, events =&gt; {
    <span class="hljs-built_in">console</span>.log(events.map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.type + <span class="hljs-string">': '</span> + event.name));
});</code></pre>
<p>We could as well specify just the name to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, <span class="hljs-string">'africa'</span>, event =&gt; {
    <span class="hljs-comment">// We're now also logging the event's value, that is, the element</span>
    <span class="hljs-built_in">console</span>.log(event.type, event.value);
});</code></pre>
<p>With the code above, adding a new ID - <code>africa</code> - to the <code>continents</code> namespace would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> section = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'section'</span>);
section.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'africa'</span>);
continents.append(section);</code></pre>
<p>Removing this element would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js">continents.namespace.africa.remove();</code></pre>
<p>To observe changes down the namespace hierarchy, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, events =&gt; {
    <span class="hljs-comment">// We're now also logging the event's path property</span>
    <span class="hljs-built_in">console</span>.log(events.map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.type + <span class="hljs-string">': '</span> + event.path));
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, [<span class="hljs-string">'africa'</span>, <span class="hljs-string">'namespace'</span>, <span class="hljs-string">'countries'</span>], event =&gt; {
    <span class="hljs-comment">// We're now also logging the event's value property</span>
    <span class="hljs-built_in">console</span>.log(event.type, event.path, event.value));
});</code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../installation/README.md">OOHTML polyfill implementation</a> has good support for the Namespaced HTML Specification. With the exception of <a href="#namespaced-selectors">Namespaced Selectors</a>, all aspects of the specification are supported. The polyfill additionally makes it possible to customise much of its implementation of the syntax using the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>. The following are areas of customization:</p>
<ul>
<li><p><strong><a href="#convention">attr.namespace</a></strong> - The <em>namespace keyword</em> attribute. The standard <em>namespace keyword</em> attribute is <code>namespace</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"attr.namespace=data-namespace;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"id01"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"id02"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.id</a></strong> - The <em>namespaced-ID</em> attribute. The standard <em>namespaced-ID</em> attribute is <code>id</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"attr.id=data-id;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">"id01"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">"id02"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#namespace-apis">api.namespace</a></strong> - The <em>namespace</em> property exposed on the document object and on elements. The standard <em>namespace</em> property is <code>namespace</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.namespace=ns;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the "continents" article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.ns.continents;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="../the-oohtml-meta-tag/README.md">here</a>.</p>

		</div>
	</template>

	<div exportgroup="readme">

		<h1 id="oohtml">OOHTML</h1>
<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/oohtml.svg" alt="NPM version" /></a></span><br />
<span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/oohtml.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<p><a href="https://webqit.io/tooling/oohtml">Object-Oriented HTML (OOHTML)</a> is a suite of new DOM features that particularly facilitates writing modular HTML, CSS, and JavaScript <em>natively</em> and <em>more conveniently</em>. It addresses a number of limitions inherent to existing conventions, and welcomes much of the paradigms associated with modern UI development.</p>
<blockquote>
  <p>OOHTML is being proposed as a <a href="https://discourse.wicg.io/t/proposal-chtml/4716">W3C standard at the Web Platform Incubator Community Group</a>. Consider bringing your ideas to the discussion.</p>
</blockquote>
<blockquote>
  <p><a href="https://github.com/webqit/oohtml">Visit this project on Github</a>.</p>
</blockquote>
<h2 id="low-level-features">Low-Level Features</h2>
<p>OOHTML brings certain new features to native web languages to make common UI design terminologies possible natively.</p>
<ul>
<li><strong>Modular Naming and APIs</strong> - <em>Naming and finding things</em> is hard; modular design makes it easier! But coming to HTML, we find a naming system that makes it difficult to keep things to small-sized scopes. There is only one global scope for IDs and CSS selectors and this kills any effort towards having a modular markup; we end up in terrible <em>hacks</em> and much naming wars, or at best, clunky naming conventions like <a href="https://getbem.com">BEM</a>. OOHTML addresses this design and architectural difficulty with two specifications that particularly facilitate modular design thinking: <a href="namespaced-html/README.md">Namespaced HTML</a> and <a href="named-templates/README.md">Named Templates</a>.</li>
<li><strong>State and Observability</strong> - The concept of building stateful applications and keeping track of all the moving parts have not particularly found a place among native web languages. Much engineering still goes into using JavaScript's change-detection mechanisms for "reactive" UI development, and everything quickly becomes very complex to reason about. OOHTML addresses this challenge, first at the language level, with the <a href="the-observer-api/README.md">Observer API</a>; then, at the DOM level, with <a href="the-state-api/README.md">The State API</a> that implements the Observer API.</li>
</ul>
<h2 id="higher-level-features">Higher-Level Features</h2>
<p>OOHTML provides features that offer <em>syntactic sugar</em> over its low-level features and existing DOM APIs.</p>
<ul>
<li><strong>Scoped Scripts</strong> - Scoped Scripts is a new feature that lets us write <code>&lt;script&gt;</code> elements that are scoped to their immediate host elements instead of the global browser scope. Scoped Scripts makes it easier to apply behaviour to modular markup as they execute in the context of their host elements. They are especially powerful in being able to automatically keep the UI in sync with tha state of an application as they internally implement the <a href="the-observer-api/README.md">Observer API</a>. <a href="scoped-scripts/README.md">Visit the details</a> to learn more.</li>
<li><strong>HTML Partials</strong> - HTML Partials is a new templating feature that abstracts over the <a href="named-templates/README.md">Named Templates Specification</a> to provide incredibly powerful composability in the simple language of tags and attributes. <a href="html-partials/README.md">Visit the details</a> to learn more.</li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p>To add the current OOHTML polyfill to your page, follow <a href="installation/README.md">the installation guide</a>.</p>
<p>The following examples give us a glimpse of what's possible with OOHTML. Links from these examples contain much further details.</p>
<h3 id="namespaced-html">Namespaced HTML</h3>
<p>The following modular markup implements its IDs in namespaces:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"continents"</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"europe"</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countries"</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"asia"</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countries"</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>The above gives us a conceptual hierarchy of objects:</p>
<pre><code class="hljs html language-html">continents
|- europe
|   |- about
|   |- countries
|- asia
    |- about
    |- countries</code></pre>
<p>The <em>namespace API</em> translates that model into a real object tree:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the "continents" article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new "namespace" DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre>
<p>We get a document structure that's easier to reason about and to work with.</p>
<p><em>Details are in the <a href="namespaced-html/README.md">Namespaced HTML</a> section.</em></p>
<h3 id="state-and-observability">State and Observability</h3>
<p>The <a href="the-observer-api/README.md">Observer API</a> lets us observe objects in real time:</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, mutations =&gt; {
    mutations.forEach(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(mutation.type, mutation.name, mutation.path, mutation.value, mutation.oldValue);
    });
});</code></pre>
<p>With the code above, adding a new ID - <code>africa</code> - to the <code>continents</code> namespace would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> section = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'section'</span>);
section.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'africa'</span>);
continents.append(section);</code></pre>
<p>The document object and every DOM element also feature <a href="the-state-api/README.md">The State API</a> that lets us maintian application state at the document and element levels:</p>
<pre><code class="hljs js language-js">Observer.observe(continents.state, mutations =&gt; {
    <span class="hljs-comment">// Set application data to element attributes</span>
    <span class="hljs-comment">// and keep them in sync</span>
    mutations.forEach(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
        continents.setAttribute(mutation.name, mutation.value);
    });
});</code></pre>
<p>With the code above, setting properties on <code>continents.state</code> would update the element.</p>
<pre><code class="hljs js language-js">continents.state.title = <span class="hljs-string">'List of continents'</span>;
<span class="hljs-comment">// Or</span>
continents.setState({
    <span class="hljs-attr">title</span>: <span class="hljs-string">'List of continents'</span>,
});</code></pre>
<p>We could easily update continents in the <code>#continents</code> tree this way:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Bind application data to section elements</span>
Observer.observe(continents.state, mutations =&gt; {
    mutations.forEach(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> sectionElement = continents.namespace[mutation.name];
        sectionElement.namespace.about.innerHTML = mutation.value.about;
        sectionElement.namespace.countries.innerHTML = mutation.value.countries;
    });
});
<span class="hljs-comment">// Update the "Asia" section</span>
continents.state.asia = {
    <span class="hljs-attr">about</span>: <span class="hljs-string">'About Asia (NEW)'</span>,
    <span class="hljs-attr">countries</span>: <span class="hljs-string">'Countries in Asia (NEW)'</span>,
};</code></pre>
<p>And we could easily add new continents to the <code>#continents</code> tree this way:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Bind application data to section elements</span>
Observer.observe(continents.state, mutations =&gt; {
    mutations.forEach(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> sectionElement = continents.namespace[mutation.name];
        <span class="hljs-keyword">if</span> (!sectionElement) {
            <span class="hljs-keyword">let</span> sectionElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'section'</span>);
            sectionElement.setAttribute(<span class="hljs-string">'id'</span>, mutation.name);
            <span class="hljs-comment">// ------------</span>
            <span class="hljs-keyword">let</span> aboutElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            aboutElement.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'about'</span>);
            <span class="hljs-keyword">let</span> countriesElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            countriesElement.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'countries'</span>);
            <span class="hljs-comment">// ------------</span>
            sectionElement.append(aboutElement, countriesElement);
            continents.append(sectionElement);
        }
        sectionElement.namespace.about.innerHTML = mutation.value.about;
        sectionElement.namespace.countries.innerHTML = mutation.value.countries;
    });
});
<span class="hljs-comment">// Add an "Africa" section</span>
continents.state.africa = {
    <span class="hljs-attr">about</span>: <span class="hljs-string">'About Africa'</span>,
    <span class="hljs-attr">countries</span>: <span class="hljs-string">'Countries in Africa'</span>,
};</code></pre>
<p>But just so we keep markup out of JavaScript code, we could employ a <a href="named-templates/README.md"><em>named</em> <code>&lt;template&gt;</code> element</a> to hold the markup separately:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"continent"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">namespace</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"countries"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Bind application data to section elements</span>
Observer.observe(continents.state, mutations =&gt; {
    mutations.forEach(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> sectionElement = continents.namespace[mutation.name];
        <span class="hljs-keyword">if</span> (!sectionElement) {
            <span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;
            sectionElement = template1.exports.continent[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">true</span>);
            sectionElement.setAttribute(<span class="hljs-string">'id'</span>, mutation.name);
            continents.append(sectionElement);
        }
        sectionElement.namespace.about.innerHTML = mutation.value.about;
        sectionElement.namespace.countries.innerHTML = mutation.value.countries;
    });
});</code></pre>
<p>Now, we could build web components more efficiently this way.</p>
<p><em>Details are in the <a href="the-state-api/README.md">State API</a> and <a href="named-templates/README.md">Named Templates</a> sections.</em></p>
<h3 id="scoped-scripts">Scoped Scripts</h3>
<p>The following <code>&lt;script&gt;</code> element is scoped to the <code>#alert</code> element - its host element:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"exit"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Close this message."</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="actionscript">
        <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.exit'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
            <span class="hljs-keyword">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>And we can render values from the global scope or from the element itself.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"exit"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Close this message."</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="actionscript">
            <span class="hljs-comment">// Render the "message" property from the element's state object</span>
            <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.message'</span>).innerHTML = <span class="hljs-keyword">this</span>.state.message;
            <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.exit'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
                <span class="hljs-keyword">this</span>.remove();
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>If we qualify the scoped script with the <code>binding</code> keyword, changes that happen to live objects, like the element's <em>state</em> object, will automatically re-run specific statements in the script.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"exit"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Close this message."</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="actionscript">
            <span class="hljs-comment">// Render the "message" property from the element's state object</span>
            <span class="hljs-comment">// This statement will re-run each time "this.state.message" gets updated</span>
            <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.message'</span>).innerHTML = <span class="hljs-keyword">this</span>.state.message;
            <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.exit'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
                <span class="hljs-keyword">this</span>.remove();
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> alertElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#alert'</span>);
        alertElement.state.message: <span class="hljs-string">'Task started!'</span>;
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            alertElement.state.message: <span class="hljs-string">'Task complete!'</span>;
        }, <span class="hljs-number">1000</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>This makes it possible to build more complex stuff without breaking a sweat. <a href="examples/README.md">Think a clock, a dynamic list</a>, etc.</p>
<p><em>Details are in the <a href="scoped-scripts/README.md">Scoped Scripts</a> section.</em></p>
<h3 id="html-partials">HTML Partials</h3>
<p>The following <code>&lt;template&gt;</code> elements contain reusable snippets called exports:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-1"</span>&gt;</span>This is export1 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-2"</span>&gt;</span>This is export2 in template1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"template2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-3"</span>&gt;</span>This is export3 in template2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"export-4"</span>&gt;</span>This is export4 in template2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>An element in the <code>&lt;body&gt;</code> area can point to the <code>&lt;template&gt;</code> element and <em>implement</em> its exports:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to the template element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I have imports<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place export-1 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Place export-2 here --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>Import</em> elements themselves can also point to a <code>&lt;template&gt;</code> directly:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to the template element --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I have imports<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place export-1 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Point to template2 and place export-3 here --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"export-3"</span> <span class="hljs-attr">template</span>=<span class="hljs-string">"template2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>An element can be dynamically pointed at another <code>&lt;template&gt;</code>, and its <em>imports</em> will be automatically resolved from the new <code>&lt;template&gt;</code>:</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div[template="template1"]'</span>).setAttribute(<span class="hljs-string">'template'</span>, <span class="hljs-string">'template2'</span>);</code></pre>
<p>This opens up new simple ways to create very dynamic applications. <a href="examples/README.md">Think a Single Page Application</a> (SPA).</p>
<p><em>Details are in the <a href="html-partials/README.md">HTML Partials</a> section.</em></p>
<h2 id="faqs">FAQs</h2>
<p>We are working on publishing some questions we've been asked, but you can always file an <a href="https://github.com/webqit/oohtml/issues">issue</a> to ask a new question or raise a suggestion.</p>
<h2 id="relationship-with-other-technologies">Relationship With Other Technologies</h2>
<p>There is a <a href="related-technologies/README.md">related technologies</a> section that gives a view of how OOHTML compares with existing technologies and related standardization efforts.</p>
<h2 id="issues">Issues</h2>
<p>To report bugs or request features, please submit an <a href="https://github.com/webqit/oohtml/issues">issue</a>.</p>
<h2 id="license">License</h2>
<p>MIT.</p>

	</div>

	<template name="related-technologies">
		<div exportgroup="readme">

			<h1 id="oohtmls-relationship-with-other-technologies">OOHTML's Relationship With Other Technologies</h1>
<p>Here are a few things that OOHTML may relate with in some way. We will be adding more as we discover them. And you may help out by <a href="https://github.com/webqit/oohtml/issues">filing an issue</a>.</p>
<p>This information is being gathered to help everyone better understand the problem domain of this technology and to provide hints to some of its design and architectural decisions. And when we meet at the <a href="https://discourse.wicg.io/t/proposal-chtml/4716">WICG</a>, we have good focus areas for consideration.</p>
<h2 id="the-observer-apithe-observer-apireadmemd"><a href="../the-observer-api/README.md">The Observer API</a></h2>
<ul>
<li>Mimicks the depreciated <strong><a href="https://arv.github.io/ecmascript-object-observe"><code>Object.observe()</code></a></strong> API and JavaScript's reflection APIs like <strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect"><code>Reflect</code></a></strong>.</li>
<li>Offers more general-purpose <em>interceptibility</em> than JavaScript's <strong>property <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">setters</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getters</a></strong>, and JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a> which specifically obscure object identity.</li>
</ul>
<h2 id="namespaced-htmlnamespaced-htmlreadmemd"><a href="../namespaced-html/README.md">Namespaced HTML</a></h2>
<ul>
<li>Captures the problem that the <strong><a href="https://getbem.com">BEM</a></strong> naming convention tries to solve but addresses it at the language level.</li>
<li>Relates with <strong><a href="https://github.com/stuartpb/pwalls-spec">Stuart P.'s Parts and Walls</a></strong> proposal from 2015.</li>
</ul>
<h2 id="named-templatesnamed-templatesreadmemd"><a href="../named-templates/README.md">Named Templates</a></h2>
<ul>
<li>Defines the <strong>src</strong> attribute that is also being considered <a href="https://discourse.wicg.io/t/add-src-attribute-to-template/2721">here</a> and <a href="https://github.com/whatwg/html/issues/2791">here</a>, and probbably elsewhere, but goes further in scope with its concept of <em>observability</em> using <code>templatecontentloaded</code> event and other features.</li>
<li>Defines the <strong>document.templates</strong> API that is also being proposed <a href="https://discourse.wicg.io/t/document-templates/1057">here</a>, but goes further in scope with its <code>HTMLTemplateElement.prototype.templates</code> API and other features.</li>
</ul>
<h2 id="scoped-scriptsscoped-scriptsreadmemd"><a href="../scoped-scripts/README.md">Scoped Scripts</a></h2>
<ul>
<li>Captures the problem that <strong>UI binding languages</strong> try to solve but comes bringing the full power of JavaScript for the job. Compare <a href="https://discourse.wicg.io/t/extension-of-template/447">this early idea for a template syntax by Jonathan Kingston</a> from 2014, <a href="https://github.com/whatwg/html/issues/2254">this proposal</a> from 2017, and <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Apple's proposal</a> from 2017.</li>
</ul>
<h2 id="the-state-apithe-state-apireadmemd"><a href="../the-state-api/README.md">The State API</a></h2>
<ul>
<li>Reminds us of <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/dataset">HTML5's DataSet API</a></strong>. But the DataSet API turns out to be simply an API to HTML's custom data attributes <code>(data-*)</code> with its one-to-one mapping to <code>data-*</code> attribute making it quite less useful for managing application state. In contrast, the new State API gives us a robust set of <em>state management</em> APIs - covering both document-level and element-level state, and the concept of automatic observability.</li>
</ul>

		</div>
	</template>

	<template name="scoped-scripts">
		<div exportgroup="readme">

			<h1 id="scoped-scripts">Scoped Scripts</h1>
<p>Scoped Scripts is a new feature that lets us write <code>&lt;script&gt;</code> elements that are scoped to their immediate host elements instead of the global browser scope. Scoped scripts make it easier to apply behaviour to modular markup as they execute in the context of their host elements.</p>
<p>We could also use them as a powerful abstraction over the <a href="../the-observer-api/README.md">Observer API</a> to automatically keep the UI in sync with the state of an application.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> but currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="scoped-scripts-1">Scoped Scripts</h2>
<p>Scoped scripts are defined with the <code>scoped</code> <em>Boolean</em> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="actionscript">
        <span class="hljs-comment">// ...</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They have their <code>this</code> variable implicitly bound to their host element.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> id = <span class="hljs-keyword">this</span>.id; <span class="hljs-comment">// alert</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They have their other variables resolved from the global scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Global scope</span>
    <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">'Task failed!'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = alertMessage; <span class="hljs-comment">// Task failed!</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They keep their variables from leaking out to the global scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">'Task complete!'</span>;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Global scope</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// undefined</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>This lets us place behaviours of any form just where we need them!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Global variable</span>
    <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">'Task failed!'</span>;
    <span class="hljs-comment">// The element's state property</span>
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#alert'</span>).state.message = <span class="hljs-string">'Task complete!'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-keyword">this</span>.state.message || alertMessage;
        <span class="hljs-built_in">console</span>.log(message);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The code above is an idea of a <a href="../the-state-api/README.md">stateful</a> <code>#alert</code> component. And we could make that functional, e.g. give it a <em>remove</em> feature.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"close"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Close this message."</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-keyword">this</span>.state.message || alertMessage;
        <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.message'</span>).innerHTML = message;
        <span class="hljs-comment">// details of how the #alert block should behave...</span>
        <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.close'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
            <span class="hljs-keyword">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<h2 id="binding-scripts">Binding Scripts</h2>
<p>Binding Scripts are a type of script elements that are automatically bound to the <em>live objects</em> that are referenced in their statements. When changes are detected on any of these objects, the specific statements that depend on them are re-run.</p>
<p>Binding scripts are defined with the <code>binding</code> <em>Boolean</em> attribute. And they could be used with the <code>scoped</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"alert"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"exit"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Close this message."</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-keyword">this</span>.state.message || alertMessage;
        <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.message'</span>).innerHTML = message;
        <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.close'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
            <span class="hljs-keyword">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>With the code above, updating the element's <code>.state.message</code> property will trigger a re-run of the statements that depend on it, leading to the new message being rendered.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#alert'</span>).state.message = <span class="hljs-string">'Task restarted!'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>The new message gets rendered because the first statement in the script has a reference to the updated property as <code>this.state.message</code>. The result of this statement is, in turn, referenced by the second statement, getting it to re-run, thus, getting the message rendered. The third statement is left untouched as it does not depend on the updated object.</p>
<p>The above shows that the dependency chain within a Binding Script is followed even when broken into local variables.</p>
<h3 id="the-asynchronous-runtime-and-observability">The Asynchronous Runtime and Observability</h3>
<p>Immediately a Binding Script is parsed, every statement is run sequentially from top to bottom - as with a regular script. From this point forward, statements are kept in sync with the <em>live objects</em> they depend on where they potentially get to be called again independently on a change event. This event-based, independent runtime is called the <em>asynchronous runtime</em>.</p>
<p>The asynchronous runtime uses the <a href="../the-observer-api/README.md">Observer API</a> to observe live, <em>object-like</em> variables for property changes. A variable is object-like when it is an object or when it works like an object, e.g arrays. A live object is any of such objects whose properties can be observed.</p>
<p>By default, the <code>this</code> object is observed from within an element's binding script; the <code>document</code> object is, too. Thus, any of their properties will trigger a statement in a scoped script if the property was set or removed using the Observer API.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Global observableProperty:'</span>, <span class="hljs-built_in">document</span>.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Local observableProperty:'</span>, <span class="hljs-keyword">this</span>.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">'observableProperty'</span>, counter ++);
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(divElement, <span class="hljs-string">'observableProperty'</span>, counter2 ++);
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>But, as seen in the <code>#alert</code> example above, we can more easily set or remove observable properties using an element's <em>state object</em> (or the document's <em>state object</em>) as it internally uses the Observer API to apply property assignments or mutations.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Global state.observableProperty:'</span>, <span class="hljs-built_in">document</span>.state.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Local state.observableProperty:'</span>, <span class="hljs-keyword">this</span>.state.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">document</span>.state.observableProperty = counter ++;
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        divElement.state.observableProperty = counter2 ++;
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>In any of the cases above, we could get deep object mutations to be observed from within a binding script using the Observer API.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Global clock.time:'</span>, <span class="hljs-built_in">document</span>.clock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Local state.clock.time:'</span>, <span class="hljs-keyword">this</span>.state.clock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Initial binding</span>
    Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">'clock'</span>, {});
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>.clock, <span class="hljs-string">'time'</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(divElement.state.clock, <span class="hljs-string">'time'</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="bindings">Bindings</h3>
<p>While the <code>this</code> object and the <code>document</code> object are automatically observed from within an element's binding script, it is also possible to bind other objects to the script. This is done using a <code>.bind()</code> method on the element - to bind locally, or on the <code>document</code> object - to bind globally for all scripts in the document.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Globally-bound clock time:'</span>, globallyBoundClock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Locally-bound clock time:'</span>, locallyBoundClock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> globallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
    <span class="hljs-built_in">document</span>.bind({globallyBoundClock});
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(globallyBoundClock, <span class="hljs-string">'time'</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">let</span> locallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
    divElement.bind({locallyBoundClock});
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Observer.set(locallyBoundClock, <span class="hljs-string">'time'</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="the-binding-scripts-api">The Binding Scripts API</h3>
<p>The following methods are used to dynamically bind object to <em>binding</em> scripts.</p>
<ul>
<li><p><strong>document.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the document-level. Objects bound here are automatically-observed in <em>binding</em> scripts across the document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind globally for all <em>binding</em> scripts in the document.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether this binding should update previous binding or undo it. Default: <code>false</code> - undo previous binding.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
<span class="hljs-built_in">document</span>.bind({
    <span class="hljs-attr">globallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
<span class="hljs-built_in">document</span>.bind({
    <span class="hljs-attr">globallyBoundClock2</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>document.unbind(): Void</strong> - This method lets us unbind any existing binding from the document.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
<span class="hljs-built_in">document</span>.unbind();</code></pre></li>
<li><p><strong>Element.prototype.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the element-level. Objects bound here are automatically-observed in the element's <em>binding</em> script.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind to the element's <em>binding</em> script.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether this binding should update previous binding or undo it. Default: <code>false</code> - undo previous binding.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
divElement.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
divElement.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">'00:00:00'</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>Element.prototype.unbind(): Void</strong> - This method lets us unbind any existing binding from an element's <em>binding</em> script.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
divElement.unbind();</code></pre></li>
</ul>
<h2 id="error-handling">Error Handling</h2>
<p>Scoped Scripts features a way to handle errors that may occur. By default, script errors are logged to the console. But they can be silently ignored by setting a <code>script-errors</code> directive on the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"chtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"script-errors=0;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span>&gt;</span><span class="actionscript">
            <span class="hljs-keyword">this</span>.querySelectorSelectorSelector(<span class="hljs-string">'h1'</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Individual script tags may also be given an <code>errors</code> directive, to override the global <code>script-errors</code> directive for the script.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"chtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"script-errors=0;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">binding</span> <span class="hljs-attr">errors</span>=<span class="hljs-string">"1"</span>&gt;</span><span class="actionscript">
            <span class="hljs-keyword">this</span>.querySelectorSelectorSelector(<span class="hljs-string">'h1'</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../installation/README.md">OOHTML polyfill implementation</a> has good support for Scope Scripts. But while the <a href="#scoped-scripts">proposed standard</a> uses the <code>scoped</code> <em>Boolean</em> attribute to designate a <em>scoped</em> script, this implementation uses the <code>type</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"scoped"</span> <span class="hljs-attr">binding</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The polyfill additionally makes it possible to customise much of its implementation of the syntax using the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>. The following are areas of customization:</p>
<ul>
<li><p><strong><a href="#scoped-scripts">selector.script</a></strong> - The CSS selector for matching the script element. The default selector is <code>script[type="scoped"]</code>. You may use a custom selector, like <code>script[is="my-script"][type="scoped"]</code>, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"selector.script=script[is='my-script'][type='scoped'];"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>script is="my-script" type="scoped"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>script is="my-script" type="scoped" binding<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#the-binding-scripts-api">api.bind</a></strong> - The <em>method name</em> for binding objects to scripts. The standard <em>method name</em> is <code>bind</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.bind=setBinding;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.setBinding(binding);</code></pre></li>
<li><p><strong><a href="#the-binding-scripts-api">api.unbind</a></strong> - The <em>method name</em> for unbinding objects from scripts. The standard <em>method name</em> is <code>unbind</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.bind=clearBinding;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.clearBinding();</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="../the-oohtml-meta-tag/README.md">here</a>.</p>

		</div>
	</template>

	<template name="the-observer-api">
		<div exportgroup="readme">

			<h1 id="the-observer-api">The Observer API</h1>
<p>Observability is fundamental to OOHTML, even as it is to modern UI development. OOHTML uses the general-purpose <a href="https://webqit.io/tooling/observer">Observer API</a> for this feature.</p>

		</div>
	</template>

	<template name="the-oohtml-meta-tag">
		<div exportgroup="readme">

			<h1 id="the-oohtml-meta-tag">The OOHTML Meta Tag</h1>
<p>OOHTML provides a meta tag for customizing its syntax or behaviour. It generally looks like this:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"prop1=val1; prop2=val2;"</span>&gt;</span></code></pre>
<p><em>The actual configurable properties are documented across the various OOHTML features.</em></p>
<p>Customization can help you keep potential breaking changes under control when there is a change to the default syntax on future updates. For a new and fast evolving technology, this should be expected.</p>
<p>Customization also lets you explore around the whole new idea, and this should hopefully bring new discoveries to the table. Feel free to bring your findings to the discussion at the <a href="https://discourse.wicg.io/t/proposal-chtml/4716">Web Platform Incubator Community Group</a>. You can always file an <a href="https://github.com/webqit/oohtml/issues">issue</a> to report a bug, ask a question, or raise a suggestion.</p>

		</div>
	</template>

	<template name="the-state-api">
		<div exportgroup="readme">

			<h1 id="the-state-api">The State API</h1>
<p>For so many reasons, we often have to deal with application data at the document and element levels. We either want to render data on an element or pass it down its subtree to be eventually rendered. The state of this data may be changing, and we may have to maintain some of it at each level. These are modern UI development paradigms that have not particularly been welcomed natively.</p>
<p>This specification defines proposed native primitives for implementing state and observability for modern "reactive" applications. These low-level APIs offer a baseline on which any design pattern, custom tooling or other high-level abstractions could be laid.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> but currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="document-level-state">Document-Level State</h2>
<p>Document-level state represents the global state of an application. This specification introduces a new <code>.state</code> property to the document object for managing document-wide state.</p>
<ul>
<li><p><strong>document.state: Object</strong> - This <em>readonly</em> property is a property-transparent state object; its properties are written and read as-is, as with regular JavaScript objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
<span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">'Hello World!'</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span></code></pre></li>
<li><p><strong>document.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on the <code>document.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">'Hello World!'</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">'Thanks for visiting.'</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">''</span>,
    },
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// {main, aside}</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">'Bonjour le Monde!'</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Bonjour le Monde!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>document.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from the document's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
<span class="hljs-built_in">document</span>.clearState();</code></pre></li>
</ul>
<h2 id="element-level-state">Element-Level State</h2>
<p>Element-level state represents the local state of an element and its subtree. This specification introduces a new <code>.state</code> property to DOM elements for managing element-level state.</p>
<ul>
<li><p><strong>Element.prototype.state: Object</strong> - This <em>readonly</em> property is a property-transparent state object; its properties are written and read as-is, as with regular JavaScript objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// -------</span>

<span class="hljs-comment">// Example usage - a simple toggle</span>
myCollapsible.onclick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (myCollapsible.state.collapsed) {
        myCollapsible.style.height = <span class="hljs-string">'auto'</span>;
    } <span class="hljs-keyword">else</span> {
        myCollapsible.style.height = <span class="hljs-string">'0px'</span>;
    }
    myCollapsible.state.collapsed = !myCollapsible.state.collapsed;
};</code></pre></li>
<li><p><strong>Element.prototype.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on an element's <code>.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
myCollapsible.setState({
    <span class="hljs-attr">inView</span>: <span class="hljs-literal">true</span>,
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>Element.prototype.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from an element's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
myCollapsible.clearState();</code></pre></li>
</ul>
<h2 id="state-observability">State Observability</h2>
<p>The <code>document.state</code> property and the <code>Element.prototype.state</code> property are implemented as <em>live objects</em> that can be observed for property changes. Live objects are observed using the <a href="../the-observer-api/README.md">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(<span class="hljs-built_in">document</span>.state, events =&gt; {
    <span class="hljs-built_in">console</span>.log(events.map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.type + <span class="hljs-string">': '</span> + event.name));
});</code></pre>
<p>We could as well specify just the name to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-string">'pageTitle'</span>, event =&gt; {
    <span class="hljs-comment">// We're now also logging the event's value property</span>
    <span class="hljs-built_in">console</span>.log(event.type, event.value);
});</code></pre>
<p>With the code above, adding or updating the <code>pageTitle</code> property on the document's state object would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">'Bonjour!'</span>;</code></pre>
<p>Deleting this property would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">delete</span> <span class="hljs-built_in">document</span>.state.pageTitle;</code></pre>
<p>To observe changes down the state tree, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, events =&gt; {
    <span class="hljs-comment">// We're now also logging the event's path property</span>
    <span class="hljs-built_in">console</span>.log(events.map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.type + <span class="hljs-string">': '</span> + event.path));
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, [<span class="hljs-string">'pageContent'</span>, <span class="hljs-string">'aside'</span>], event =&gt; {
    <span class="hljs-comment">// We're now also logging the event's path property</span>
    <span class="hljs-built_in">console</span>.log(event.type, event.path);
});</code></pre>
<p>With the code above, mutating a nested property would trigger the observer.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// State object</span>
<span class="hljs-keyword">let</span> data = {
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">'Hello World!'</span>,
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">'Thanks for visiting.'</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">''</span>,
    },
};
<span class="hljs-built_in">document</span>.setState(data);

<span class="hljs-comment">// Mutate pageContent afterwards...</span>
Observer.set(data.pageContent, <span class="hljs-string">'aside'</span>, <span class="hljs-string">'Related content...'</span>);</code></pre>
<h3 id="a-custom-element-example">A Custom Element Example</h3>
<p>The following example demonstrates state observability in a custom element. Our logic below helps keep the UI and application state in sync. Noteworthy is that we are reflecting the <code>collapsed</code> state in the <code>data-collapsed</code> attribute and keeping a part of that state - <code>content</code> - <em>bound</em> to a descendant element.</p>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">'my-collapsible'</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

    <span class="hljs-comment">/**
     * Creates the Shadow DOM
     */</span>
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">let</span> contentElement = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.content'</span>);

        <span class="hljs-comment">// Observe state and get the UI synced</span>
        Observer.observe(<span class="hljs-keyword">this</span>.state, events =&gt; {
            events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
                <span class="hljs-keyword">switch</span>(event.name) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'collapsed'</span>:
                        <span class="hljs-keyword">this</span>.style.height = event.value ? <span class="hljs-string">'0px'</span> : <span class="hljs-string">'auto'</span>;
                        <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">'data-active'</span>, event.value ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>);
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'inView'</span>:
                        <span class="hljs-keyword">this</span>.style.animation = event.value ? <span class="hljs-string">'fadein 440ms'</span> : <span class="hljs-string">'fadeout 440ms'</span>;
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'content'</span>:
                        contentElement.setState(event.value);
                    <span class="hljs-keyword">break</span>;
                }
            });
        });

        <span class="hljs-comment">// Implement the logic for toggling collapsion</span>
        <span class="hljs-keyword">this</span>.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            <span class="hljs-keyword">this</span>.state.collapsed = !<span class="hljs-keyword">this</span>.state.collapsed;
        });

        <span class="hljs-comment">// Implement the logic for detecting when in view</span>
        <span class="hljs-keyword">let</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">entries</span>) </span>{
            <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].isIntersecting) {
                <span class="hljs-keyword">this</span>.state.inView = entries[<span class="hljs-number">0</span>].intersectionRatio;
            }
        });
        io.observe(<span class="hljs-keyword">this</span>);
    }

});</code></pre>
<p>External code gets a standard way to infer the state of the <code>&lt;my-collapsible&gt;</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> myCollapsible = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'my-collapsible'</span>);
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed;
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView;</code></pre>
<p>External code gets a standard way to control state.</p>
<pre><code class="hljs js language-js">myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;</code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="../installation/README.md">OOHTML polyfill implementation</a> has full support for The State API. The polyfill additionally makes it possible to customise much of its implementation of the syntax using the <a href="../the-oohtml-meta-tag/README.md">OOHTML meta tag</a>. The following are areas of customization:</p>
<ul>
<li><p><strong><a href="#the-state-api">api.state</a></strong> - The property name for exposing the <em>state object</em> on DOM elements and the document object. The standard property name is <code>state</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.state=stateObject;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">myCollapsible.stateObject.collapsed = <span class="hljs-literal">true</span>;</code></pre></li>
<li><p><strong><a href="#the-state-api">api.setState</a></strong> - The <em>method name</em> for setting data on <em>state objects</em>. The standard <em>method name</em> is <code>setState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.setState=setStateObject;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.setStateObject(data);</code></pre></li>
<li><p><strong><a href="#the-state-api">api.clearState</a></strong> - The <em>method name</em> for clearing data from <em>state objects</em>. The standard <em>method name</em> is <code>clearState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"oohtml"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"api.clearState=clearStateObject;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.clearStateObject();</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="../the-oohtml-meta-tag/README.md">here</a>.</p>

		</div>
	</template>
