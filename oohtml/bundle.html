
	<div exportgroup="readme">

		<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/oohtml.svg" alt="NPM version" /></a></span> <span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/oohtml" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/oohtml.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<h2 id="robust-web-native-ui-development">Robust, Web-Native UI Development</h2>
<p>Think an all-new ability to author your entire UI from modular, reusable and granularly reactive HTML, letting you maintain a one-way or two-way binding with your JavaScript appliaction - and this time, <strong>altogether based on just native web platform primitives and none of a framework</strong>! OOHTML comes with all modern UI development paradigms built into the plain old HTML so you can go without a tool.</p>
<blockquote>
  <p><strong>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> at the Web Platform Incubator Community Group. Consider joining the discussion.</strong></p>
</blockquote>
<h2 id="getting-started">Getting Started</h2>
<p><a href="/tooling/oohtml/docs">Visit the docs</a> for an overview, the specifications and usage guides.</p>
<p><html-import data-id="quickstart" template="@layout/quickstart"></html-import></p>
<p>Also, <a href="https://github.com/webqit/oohtml/discussions">join the Github Discussions</a> for OOHTML.</p>
<h2 id="contributing-to-the-project">Contributing to the Project</h2>
<p>Help report bugs, or request features; or join in the development.</p>
<ul>
<li><a href="https://github.com/webqit/oohtml">Visit this project on github</a>.</li>
<li><a href="https://github.com/webqit/webqit-tooling.docs/edit/master/oohtml/docs">Contribute to the docs on github</a>.</li>
</ul>
<h2 id="license">License</h2>
<p>The MIT license.</p>

	</div>

	

	<template name="docs">
		<div exportgroup="readme">

			<h1 id="the-oohtml-docs">The OOHTML Docs</h1>
<p>Welcome to the OOHTML documentation. We hope you find it easy to understand and navigate.</p>
<p>If you have questions about anything related to OOHTML, you're always welcome to ask on our <a href="https://github.com/webqit/oohtml/discussions">GitHub Discussions</a>.</p>
<h2 id="explore-the-docs">Explore the Docs</h2>

		</div>

		<template name="getting-started">
			<div exportgroup="readme">

				<h1 id="getting-started">Getting Started</h1>

			</div>

			<template name="explainer">
				<div exportgroup="readme">

					<h1 id="explainer-todo">Explainer [TODO]</h1>

				</div>

				<div exportgroup="readme1">

					<h1 id="explainer-oohtml">Explainer: OOHTML</h1>
<p>This information is being gathered to present OOHTML's design and architectural choices in the light of the problem space. We intend to maintain this as a living document; watch this space, or help us improve it by submitting a pull request or by <a href="https://github.com/webqit/oohtml/issues">filing an issue</a>.</p>
<h2 id="object-oriented-markup">Object-Oriented Markup</h2>
<p><em>Naming and finding things</em> is hard; modular design makes it easier! This isn't necessarily some modern wisdom, we just couldn't before now address HTML's old idea of one global scope for IDs and CSS selectors. Here's how we currently struggle with creating modular markup and how OOHTML makes it a lot easier.</p>
<ul>
<li><p><strong><a href="https://getbem.com">BEM</a></strong> has been an agreeable workaround for many people. It's, however, clunky.</p>
<ul>
<li>Compare that with the more succinct <strong><a href="/tooling/oohtml/docs/getting-started/namespaced-html#namespaced-selectors">Namespaced Selectors</a></strong> in <a href="/tooling/oohtml/docs/getting-started/namespaced-html">Namespaced HTML</a>.</li></ul>
<p><em>BEM also doesn't really go beyond usage in CSS. Namespaced HTML, on the other hand, is able to translate Namespaces in markup into namespace objects in JavaScript by means of the Namespace API.</em></p></li>
<li><p><strong><a href="https://github.com/stuartpb/pwalls-spec">Stuart P.'s Parts and Walls</a></strong> proposal from 2015 also points to the same need for a modular naming that's accessible in JavaScript.</p>
<ul>
<li>But while the above is based on programmatic DOM traversal, Namespaced HTML let's us access the same elements declaratively as live DOM properties. In other words, instead of having to query the DOM each time to access named elements, the DOM exposes them as properties and let's us receive updates when any of the properties change. <em>See details in the <a href="/tooling/oohtml/docs/getting-started/namespaced-html#api">Namespace API</a> of <a href="/tooling/oohtml/docs/getting-started/namespaced-html">Namespaced HTML</a>.</em></li></ul>
<p><em>And just for fun, it also looks like the DOM itself likes the idea of exposing strategic UI objects in JavaScript as DOM properties. See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/head"><code>document.head</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body"><code>document.body</code></a>. These are indeed more concise than <code>document.querySelector('head')</code> and <code>document.querySelector('body')</code>.</em></p></li>
</ul>
<p>Overall, <a href="/tooling/oohtml/docs/getting-started/namespaced-html">Namespaced HTML</a> is the far-reaching solution to authoring modular HTML and CSS.</p>
<h2 id="html-modules-and-imports">HTML Modules and Imports</h2>
<p>We currently have HTML's standard <code>&lt;template&gt;</code> elements for defining reusable HTML snippets. But it still feels difficult getting things to work without a standard templating system.</p>
<p>For so many reasons, we often have to deal with application data at the document and element levels. We either want to render data on an element or pass it down its subtree to be eventually rendered. The state of this data may be changing, and we may have to maintain some of it at each level. These are modern UI development paradigms that have not particularly been welcomed natively.</p>
<hr />
<p>On the expansive subject of <a href="https://github.com/WICG/webcomponents/issues/645"><em>HTML Modules</em></a>, OOHTML takes a very, very different approach from the many existing opinions to how reusable markup should be delivered and consumed in the browser - <em><a href="/tooling/oohtml/docs/getting-started/html-modules">OOHTML's HTML Modules</a></em>. What is the most important difference?</p>
<ul>
<li>OOHTML sees HTML Modules as simply a way to ship and consume <strong>static, inert content</strong>, and is thus more oriented towards HTML's standard primitive for <em>static, inert content</em> - the <code>&lt;template&gt;</code> element. OOHTML simply introduces <a href="/tooling/oohtml/docs/getting-started/html-modules#remote-content">the <strong>src</strong> attribute</a> as a way to <em>load a template's content from a remote HTML file</em>.</li>
<li><a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/html-modules-explainer.md">This explainer</a>, among others, however, follows the JavaScript route of using ES6 module infrastructure to load <strong>both static content and active script elements</strong>.</li>
</ul>
<p>How do these compare?</p>
<ul>
<li><p><strong>OOHTML's approach let's us <em>author and deliver HTML in HTML</em>.</strong> And it's as declarative as this:</p>
<p><em>Remote File: /bundle.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Main Document:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bundle&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><em>See also: <a href="https://discourse.wicg.io/t/add-src-attribute-to-template/2721">[proposal - <strong>src</strong> attribute]</a>, <a href="https://github.com/whatwg/html/issues/2791">[proposal - <strong>src</strong> attribute]</a></em></p>
<p><strong>But, the other approach gets us to deal with JavaScript code to import remote HTML</strong></p>
<p><em>Remote File: /import.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> blogPost = <span class="hljs-keyword">import</span>.meta.document.querySelector(<span class="hljs-string">&quot;#blogPost&quot;</span>);
    <span class="hljs-keyword">export</span> { blogPost }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><em>Main Document:</em>`</p>
<pre><code class="hljs js language-js">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;
    <span class="hljs-keyword">import</span> { blogPost } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;import.html&quot;</span>;
&lt;/script&gt;</code></pre></li>
<li><p><strong>OOHTML's approach provides for consuming the imported HTML <em>both in JavaScript and in HTML</em>.</strong> And it's as declarative as the following two cases:</p>
<p><em>In JavaScript - as detailed in <a href="/tooling/oohtml/docs/getting-started/html-modules#api">HTML Modules API</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> [ blogPost ] = <span class="hljs-built_in">document</span>.templates.bundle.exports.blogPost;
    <span class="hljs-built_in">document</span>.body.appendChild(blogPost.cloneNode(<span class="hljs-literal">true</span>));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><em>See also: <a href="https://discourse.wicg.io/t/document-templates/1057">[proposal - <code>document.templates</code>]</a></em></p>
<p><em>In HTML - as detailed in <a href="/tooling/oohtml/docs/getting-started/html-imports">OOHTML Imports</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><strong>But, the other approach remains based <em>only in JavaScript</em></strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">import</span> { blogPost } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;import.html&quot;</span>
        <span class="hljs-built_in">document</span>.body.appendChild(blogPost);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>But <a href="https://github.com/WICG/webcomponents/issues/863">the new direction</a> of this approach is having an afterthought toward a declarative way to place imported content in markup.</em></p></li>
<li><p><strong>OOHTML's approach follows <em>lazy-loading of remote modules and lazy rendering of <code>&lt;import&gt;</code> elements, as driven by module events</em>.</strong> This makes <code>&lt;import&gt;</code> elements work just like elements like <code>&lt;img&gt;</code>: 'display whenever you can load', as seen below:</p>
<p><em>In HTML - as detailed in <a href="/tooling/oohtml/docs/getting-started/html-imports">OOHTML Imports</a></em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Resolves whenever module loads --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><strong>But, the other approach simply does not.</strong></p></li>
</ul>
<p>Overall, it seems more traditional to us to implement HTML Modules in HTML than in JavaScript, letting us do all HTML concerns in HTML (templates) and all JavaScript concerns in JavaScript (ES6 modules).</p>
<p>But then, it is a common pattern today for some reusable HTML has to go with some logic. And it is interesting how another of OOHTML's features - <a href="/tooling/oohtml/docs/getting-started/subscript">Subscript</a> - lets us add such non-global JavaScript to HTML markup, with everything working happily:</p>
<p><em>Remote File: /bundle.html</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;blogPost&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Content...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;#content&#x27;</span>).innerHTML = <span class="hljs-built_in">document</span>.state.content;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- previous syntax: &lt;script type=&quot;scoped&quot;&gt;&lt;/script&gt; --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><em>Main Document:</em></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bundle&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Resolves whenever module loads, and the slotted element&#x27;s scoped script activates --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blogPost&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;bundle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>And how far can this go? We run this in production with webqit.io. Our real life success with this pattern is something we want to eagerly publish.</p>
<h2 id="state-observability-and-reactivity">State, Observability and Reactivity</h2>
<p>Primitives for building <em>reactive</em> applications and keeping track of very dynamic state have not particularly found their way to native web languages.</p>
<ul>
<li><p><strong>State:</strong> We indeed have some primitives related to the concept of <em>state</em>, but they have very limited usecases. An example is <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/dataset">HTML5's DataSet API</a> that lets us keep state with HTML elements. But, it turns out to be tied to just HTML data <code>(data-*)</code> attributes - making it less useful as a general way to work with application state in the UI.</p>
<p>Compare OOHTML's <a href="/tooling/oohtml/docs/getting-started/the-state-api">State API</a> which gives us robust <em>state management</em> - covering both document-level and element-level state, with automatic support for observability.</p></li>
<li><p><strong>Observability:</strong> Much engineering still goes into using JavaScript's change-detection mechanisms for <em>reactive</em> UI development, and some things don't even scale. Check out a consideration of some of those difficulties in <a href="https://webqit.io/tooling/observer/explainer">this explainer</a>.</p>
<p>Compare the <a href="https://github.com/webqit/observer">Observer API</a> which provides generic functions for observing and intercepting JavaScript objects. See its <em>universal</em> role across the rest of OOHTML, and potentially other technologies.</p></li>
<li><p><strong>Reactivity:</strong> A Reactuve UI binding language? See <a href="/tooling/oohtml/docs/getting-started/subscript">Subscript</a>. It comes bringing the full power of JavaScript for the job.</p>
<p>Compare <a href="https://discourse.wicg.io/t/extension-of-template/447">this early idea for a template syntax by Jonathan Kingston</a> from 2014, <a href="https://github.com/whatwg/html/issues/2254">this proposal</a> from 2017, and <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Apple's proposal</a> from 2017.</p></li>
</ul>

				</div>
			</template>

			<template name="overview">
				<div exportgroup="readme">

					<h1 id="overview">Overview</h1>
<p>OOHTML offers a set of five features that make common UI development paradigms possible as native web platform features. These features may be used individually or together for some great UI-authoring capabilites. Here is an overview:</p>
<ul>
<li><a href="#html-modules">HTML Modules</a></li>
<li><a href="#html-imports">HTML Imports</a></li>
<li><a href="#namespaced-html">Namespaced HTML</a></li>
<li><a href="#the-state-api">The State API</a></li>
<li><a href="#subscript">Subscript</a></li>
</ul>
<h2 id="html-modules">HTML Modules</h2>
<p><em>HTML Modules</em> are a templating feature that lets us write reusable HTML markup using the <em>module</em>, <em>export</em> and  <em>import</em> paradigm. This feature establishes the standard <code>&lt;template&gt;</code> element as the foundation of a module infrastructure for HTML and introduces new attributes, properties and events that together closes the loop.</p>
<p>A module is a regular <code>&lt;template&gt;</code> element with a <code>name</code> attribute - <em>the module ID</em> - and its contents are simply the <em>exports</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Exports may be more properly wrapped within an <code>&lt;export&gt;</code> element of a designated name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Or they may be individually <em>tagged</em> to an export identifier using the <code>exportgroup</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Either way, they are accessed the same way using the <em>Modules API</em>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Access module1 from document.templates</span>
<span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;

<span class="hljs-comment">// Import module1&#x27;s exports</span>
<span class="hljs-keyword">let</span> questionExport = module1.exports.question; <span class="hljs-comment">// Array</span>

<span class="hljs-comment">// Clone the elements in the export</span>
<span class="hljs-keyword">let</span> questionExportClone = questionExport.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.cloneNode(<span class="hljs-literal">true</span>));</code></pre>
<p>Taking things further, template elements may reference remote content using the <code>src</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-remote&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The contents of the remote file automatically become the template's content on load.</p>
<p><strong>Details are in the <a href="/tooling/oohtml/docs/spec/html-modules">HTML Modules</a> specification. Learn more about the convention, API, events, and the polyfill support.</strong></p>
<h2 id="html-imports">HTML Imports</h2>
<p><em>HTML Imports</em> are a declarative way to use the <em>exports</em> of an <em>HTML Module</em> from anywhere in the main document.</p>
<blockquote>
  <p>Note that this is different from the HTML Imports that was spec'd with an early version of Web Components.</p>
</blockquote>
<p>Here, an <code>&lt;import&gt;</code> element in the <code>&lt;body&gt;</code> area is used to <em>place</em> a corresponing <em>export</em> of an HTML module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Import question here from module1 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Resolution takes place and the <code>&lt;import&gt;</code> element is replaced by all of the imported contents.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- import element replaced --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Also, multiple <code>&lt;import&gt;</code> elements within a block can be scoped to just one <em>module ID</em> declaration.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Point to a module; one module ID for all imports within --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Import question here from module1 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Import another export here from module1 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Now, on resolution, an <code>&lt;import&gt;</code> elements will stand by somewhere with a view to returning to its slot on any event that gets the slot empty. In fact, <code>&lt;import&gt;</code> elements maintain a <em>live</em> relationship with the modules they point to and with the contents that go into their slot.</p>
<p>So, if we dynamically changed the module ID declaration above to point to another module, <em>imports</em> will be resolved again, this time, from the new module.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Changing the module ID on the DIV container above will see all associated imports resolved again</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div[template=&quot;module1&quot;]&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre>
<p>This opens up new simple ways to create very dynamic applications.</p>
<p><strong>Details are in the <a href="/tooling/oohtml/docs/spec/html-imports">HTML Imports</a> specification. Learn more about the convention, dynamicity, Slot Inheritance, isomorphic rendering, and the polyfill support.</strong></p>
<h2 id="namespaced-html">Namespaced HTML</h2>
<p>Namespacing provides a way to let an element establish its own naming context for descendant elements. This makes it possible to keep IDs scoped to a context other than the document's global scope; thus the ability to write collision-free IDs across a page.</p>
<p>The following modular markup implements its IDs in namespaces:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;continents&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;europe&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asia&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>The above gives us a conceptual model of repeating objects, each encapsulating its IDs:</p>
<pre><code class="hljs html language-html">continents
 ├⏤europe
 │   ├⏤about
 │   ├⏤countries
 ├⏤asia
     ├⏤about
     ├⏤countries</code></pre>
<p>And beyond the point of giving us collision-free IDs, <em>Namespaced HTML</em> features an API that translates namespace models into real object trees:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new &quot;namespace&quot; DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre>
<p>We get a document structure that translates to a bankable API for building great functionalities.</p>
<blockquote>
  <p>Much of our code in the examples below will now use the <code>namespace</code> attribute in markup and the <code>.namespace</code> property in JavaScript.</p>
</blockquote>
<p><strong>Details are in the <a href="/tooling/oohtml/docs/spec/namespaced-html">Namespaced HTML</a> specification. Learn more about the convention, Namespaced Selectors, API, observability, and the polyfill support.</strong></p>
<h2 id="the-state-api">The State API</h2>
<p>The State API is a DOM API that lets us maintain application state at the document level and at individual element levels. It brings application state closer to the UI and makes it easy to keep the UI in sync with all the changes taking place.</p>
<p>This API exposes a document-level <em>state object</em> on a <code>document.state</code> property, and an element-level <em>state object</em> on an <code>element.state</code> property. Arbitrary values can be set and retrieved on <em>state objects</em> the same way we would with regular objects.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// At the document level</span>
<span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.state.pageTitle); <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// At the element level</span>
element.state.collapsed = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">console</span>.log(element.state.collapsed); <span class="hljs-comment">// true</span></code></pre>
<p>But state objects are unique in that they support <em>observability</em>. They are <em>live objects</em> that can be observed for changes using the <a href="/tooling/oohtml/docs/spec/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-string">&#x27;pageTitle&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;New Page Title: &#x27;</span> + e.value);
    <span class="hljs-comment">// Or we could reflect this state on the document title element</span>
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;title&#x27;</span>).innerHTML = e.value;
});</code></pre>
<p>This lets us build very reactive applications natively.</p>
<p>Using an element's state API, here's how we could make a <em>collapsible</em> component.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-collapsible</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;control&quot;</span>&gt;</span>Toggle Me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 0px&quot;</span>&gt;</span>
        Some content
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">my-collapsible</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

    <span class="hljs-comment">/**
     * Creates the Shadow DOM
     */</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// Observe state and get the UI synced</span>
        Observer.observe(<span class="hljs-built_in">this</span>.state, <span class="hljs-string">&#x27;collapsed&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
            <span class="hljs-built_in">this</span>.namespace.content.style.height = e.value ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
            <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-collapsed&#x27;</span>, e.value ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
        });

        <span class="hljs-comment">// Implement the logic for toggling collapsion</span>
        <span class="hljs-built_in">this</span>.namespace.control.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });
    }

});</code></pre>
<p>Now, other parts of the application are able to work in sync with the state of this element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> collapsible = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>);
Observer.observe(collapsible.state, <span class="hljs-string">&#x27;collapsed&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.value ? <span class="hljs-string">&#x27;element collapsed&#x27;</span> : <span class="hljs-string">&#x27;element expanded&#x27;</span>);
});</code></pre>
<p><strong>Details are in the <a href="/tooling/oohtml/docs/spec/the-state-api">State API</a> specification. Learn more about the API, deep observability, and the polyfill support.</strong></p>
<h2 id="subscript">Subscript</h2>
<p>Subscript is a type of JavaScript runtime that lets us create scoped, <em>reactive</em> <code>&lt;script&gt;</code> elements across an HTML document. That gives us a UI binding language and the ability to write UI logic without involving actual JavaScript classes or files.</p>
<p>Subscript lets us write <code>&lt;script&gt;</code> elements that are scoped to their host elements instead of the global browser scope. Below is such a <code>&lt;script&gt;</code> element, being scoped to the <code>#alert</code> element - its host element:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id); <span class="hljs-comment">// alert</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The <code>this</code> variable within Subscript is a reference to the script's host element. In addition, variables declared within the script are available only within the script, and global variables are always available across all scripts.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">this</span>.namespace.exit.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Below is how we could render something - a message - from the element's state object - <code>.state.message</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Render the &quot;message&quot; property from the element&#x27;s state object</span>

            <span class="hljs-built_in">this</span>.namespace.message.innerHTML = <span class="hljs-built_in">this</span>.state.message;
            <span class="hljs-built_in">this</span>.namespace.exit.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">this</span>.remove();
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>But the best part yet is Subscript's reactivity! While Subscript works like regular JavaScript, it is also able to observe changes in its scope and respond to them. And it does this at the granular statement level such that a given statement is evaluated again (independently of other statements in the script) whenever any of the observable references used in the statement experiences a change.</p>
<p>Below, changing the observable reference<code>.state.message</code> will trigger that particular statement in the script above to run again.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> alertElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>);
alertElement.state.message = <span class="hljs-string">&#x27;Task started!&#x27;</span>;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    alertElement.state.message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
}, <span class="hljs-number">1000</span>);</code></pre>
<p>Leveraging this reactivity, we could implement the <code>&lt;my-collapsible&gt;</code> component we created in the <em>State API</em> section above - this time, without a JavaScript class.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;collapsible&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;control&quot;</span>&gt;</span>Toggle Me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 0px&quot;</span>&gt;</span>
        Some content
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Observe state and get the UI synced, without requiring Observer.observe() here...</span>

        <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-collapsed&#x27;</span>, <span class="hljs-built_in">this</span>.state.collapsed ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
        <span class="hljs-built_in">this</span>.namespace.content.style.height = <span class="hljs-built_in">this</span>.state.collapsed ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
        <span class="hljs-built_in">this</span>.namespace.control.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// Toggle collapsion state</span>
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><strong>Details are in the <a href="/tooling/oohtml/docs/spec/subscript">Subscript</a> specification. Learn more about the event-based runtime, deep observability, bindings, the API, error handling, and the polyfill support.</strong></p>
<h2 id="going-further">Going Further</h2>
<p>You definitely want to visit the documentation for each of OOHTML's features and try everything out by pasting the code examples and running them right in your browser. Simply include the <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill</a> on your page and get away with writing modular, reusable, reactive HTML without a tool! </p>
<blockquote>
  <p>We're putting together a collection of examples in the <a href="/tooling/oohtml/docs/usage/examples">examples</a> section.</p>
</blockquote>

				</div>
			</template>

			<template name="polyfill">
				<div exportgroup="readme">

					<h1 id="the-oohtml-polyfill">The OOHTML Polyfill</h1>
<p>This library is the official polyfill for OOHTML. It can be used via a script tag or as an npm package.</p>
<h2 id="option-1-embed-as-script">Option 1: Embed as Script</h2>
<p>Add the following script tag to your page to include the all-in-one OOHTML build:</p>
<pre><code class="hljs html language-html">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Or embed individual OOHTML features via their respective build:</p>
<ul>
<li><strong><a href="/tooling/oohtml/docs/spec/html-modules">HTML Modules</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/html-modules.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/spec/html-imports">HTML Imports</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/html-imports.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/spec/namespaced-html">Namespaced HTML</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/namespaced-html.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/spec/the-state-api">The State API</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/state-api.js"&gt;&lt;/script&gt;</code></li>
<li><strong><a href="/tooling/oohtml/docs/spec/subscript">Subscript</a></strong> - <code>&lt;script src="https://unpkg.com/@webqit/oohtml/dist/subscript.js"&gt;&lt;/script&gt;</code></li>
</ul>
<h2 id="option-2-install-via-npm">Option 2: Install via NPM</h2>
<p>With <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">npm available on your terminal</a>, run the following command to install OOHTML:</p>
<pre><code class="hljs text language-text">$ npm i -g npm
$ npm i --save @webqit/oohtml</code></pre>
<p>Import and initialize the installed package with a <em>window</em> object in the current browser or server evironment.</p>
<p>You may initialize the all-in-one OOHTML module:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import</span>
<span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/oohtml&#x27;</span>;
<span class="hljs-comment">// Initialize</span>
OOHTML.call(<span class="hljs-built_in">window</span>);</code></pre>
<p>Or a specific feature module:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import</span>
<span class="hljs-keyword">import</span> Subscript <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/oohtml/src/subscript/index.js&#x27;</span>;
<span class="hljs-comment">// Initialize</span>
Subscript.call(<span class="hljs-built_in">window</span>);</code></pre>
<h3 id="server-side-initialization">Server-Side Initialization</h3>
<p>To use OOHTML for server-side rendering, a library like <a href="https://github.com/jsdom/jsdom">jsdom</a> would be used to create a DOM instance. Now, the instance's <code>window</code> object would be used to initialize OOHTML.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import OOHTML</span>
<span class="hljs-keyword">import</span> OOHTML <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/oohtml&#x27;</span>;
<span class="hljs-comment">// Import jsDom</span>
<span class="hljs-keyword">import</span> jsdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jsdom&#x27;</span>;
<span class="hljs-comment">// Utilities we&#x27;ll need</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;

<span class="hljs-comment">// Read the HTML document file from the server</span>
<span class="hljs-keyword">const</span> documentFile = fs.readFileSync(path.resolve(<span class="hljs-string">&#x27;./index.html&#x27;</span>));
<span class="hljs-comment">// Instantiate jsdom so we can obtain the &quot;window&quot; for OOHTML</span>
<span class="hljs-comment">// Detailed instruction on setting up jsdom is available in the jsdom docs</span>
<span class="hljs-keyword">const</span> JSDOM = <span class="hljs-keyword">new</span> jsdom.JSDOM(documentFile.toString());

<span class="hljs-comment">// Initialize OOHTML...</span>
OOHTML.call(JSDOM.window);

<span class="hljs-comment">// And we can use OOHTML as normal</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">document</span> = JSDOM.window.document;
<span class="hljs-comment">// The document&#x27;s templates object...</span>
<span class="hljs-keyword">let</span> template1 = <span class="hljs-built_in">document</span>.templates.template1;
<span class="hljs-comment">// etc</span></code></pre>
<h2 id="next-steps">Next Steps</h2>
<p>You want to visit each of <a href="/tooling/oohtml/docs/spec">OOHTML's features</a>.</p>

				</div>
			</template>
		</template>

		<template name="learn">
			<div exportgroup="readme">

				<h1 id="using-oohtml">Using OOHTML</h1>

			</div>

			<template name="examples">
				<div exportgroup="readme">

					<h1 id="examples">Examples</h1>
<p>Here are a few examples that you can try right now. You can simply copy and paste these codes to view on your browser.</p>

				</div>

				<template name="spa">
					<div exportgroup="readme">

						<h1 id="an-spa-in-oohtml">An SPA In OOHTML</h1>
<p>This example makes a Single Page Application (SPA) out of <a href="/tooling/oohtml/docs/spec/html-modules">HTML Modules</a> and <a href="/tooling/oohtml/docs/spec/html-imports">HTML Imports</a>.</p>
<p>Below, we're using the two <code>&lt;template&gt;</code> elements to each represent a route - a page. Then we point the <code>&lt;body&gt;</code>'s template attribute to either of the <code>&lt;template&gt;</code>s, depending on the current URL.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>An SPA In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.import=html-import&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml@1.8.12/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pages&quot;</span>&gt;</span>

            <span class="hljs-comment">&lt;!-- &quot;home&quot; page module --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>
                    Welcome Home!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>About Me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

            <span class="hljs-comment">&lt;!-- &quot;about&quot; page module --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>
                    About Me!
                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>Back to Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;pages/home&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">html-import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;headline&quot;</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">html-import</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">html-import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Page not Found!<span class="hljs-tag">&lt;/<span class="hljs-name">html-import</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
                <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">document</span>.location.hash.substr(<span class="hljs-number">1</span>);
                <span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;pages&#x27;</span> + path);
            });
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Navigate to a route that does not begin with <code>#/home</code> or <code>#/about</code>, you should see the default content showing <em>404</em>.</p>
<p><a href="/html/tooling/oohtml/docs/learn/examples/spa.html" target="_blank">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

					</div>
				</template>

				<template name="todo">
					<div exportgroup="readme">

						<h1 id="a-todo-list-in-oohtml">A TODO List In OOHTML</h1>
<p>Below is a TODO list application we made out of a plain JavaScript array bound to <a href="/tooling/oohtml/docs/spec/the-state-api#document-level-state"><code>document.state</code></a>.</p>
<p>It features the ability to add items and toggle the active state of each item.</p>
<ul>
<li><strong>For the <em>add</em> feature</strong> - When the <em>add</em> button in the TODO container is clicked, an item is added to the array - effectively becoming a new item in the UI.</li>
<li><strong>For the <em>toggle</em> feature</strong> - When the <em>toggle</em> button of an item in the UI is clicked, the corresponding entry in the array gets its <code>active</code> property toggled between <code>true</code> and <code>false</code>.</li>
</ul>
<blockquote>
  <p>Note that we're involving the <em>Observer API</em> to reactively mutate the todo list. Also, we're using the jQuery-like <em>Play UI</em> to manipulate the DOM.</p>
</blockquote>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>A TODO List in OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/play-ui@0.3.7/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml@1.8.12/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Make PlayUI available globally</span>
            <span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.WebQit.$;
            <span class="hljs-built_in">window</span>.Observer = <span class="hljs-built_in">window</span>.WebQit.Observer;

            <span class="hljs-comment">// Create the app</span>
            <span class="hljs-keyword">const</span> app = {
                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My TODO&#x27;</span>,
                <span class="hljs-attr">todo</span>: [
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-1&#x27;</span>, <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-2&#x27;</span>, <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>},
                    {<span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;Task-3&#x27;</span>, <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>},
                ],
            };
            <span class="hljs-built_in">document</span>.setState(app);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;items&quot;</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">namespace</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>Toggle Active<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                    $(<span class="hljs-built_in">this</span>.namespace.desc).html(<span class="hljs-built_in">this</span>.state.desc);
                    $(<span class="hljs-built_in">this</span>.namespace.desc).css(<span class="hljs-string">&#x27;opacity&#x27;</span>, <span class="hljs-built_in">this</span>.state.active ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>);
                    $(<span class="hljs-built_in">this</span>.namespace.toggle).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                        <span class="hljs-built_in">this</span>.state.active = !<span class="hljs-built_in">this</span>.state.active;
                    });
                </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;items&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;items&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            You can also add items from the console directly.<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
            Open your console and type: <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>Observer.proxy(document.state.todo).push({desc:&quot;New Item&quot;, active: true})<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                <span class="hljs-built_in">this</span>.namespace.title.innerHTML = <span class="hljs-built_in">document</span>.state.title;
                $(<span class="hljs-built_in">this</span>.namespace.items).itemize(<span class="hljs-built_in">document</span>.state.todo);
                <span class="hljs-built_in">this</span>.namespace.add.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
                    Observer.proxy(<span class="hljs-built_in">document</span>.state.todo).push({<span class="hljs-attr">desc</span>: prompt(<span class="hljs-string">&#x27;Task description&#x27;</span>, , <span class="hljs-string">&#x27;Task-&#x27;</span> + (<span class="hljs-built_in">document</span>.state.todo.length + <span class="hljs-number">1</span>)), <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,});
                });
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><a href="/html/tooling/oohtml/docs/learn/examples/todo.html" target="_blank">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

					</div>
				</template>

				<template name="tooling">
					<div exportgroup="readme">

						<h1 id="tooling-in-oohtml">Tooling In OOHTML</h1>
<p>This example shows how we could use a DOM abstraction library, like jQuery, from within Subscript code.</p>
<p>Turns out that this is naturally possible!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Tooling In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml@1.8.12/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                $(<span class="hljs-built_in">this</span>.namespace.message).html(<span class="hljs-built_in">this</span>.state.message || <span class="hljs-string">&#x27;Task pending...&#x27;</span>);
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// The alert</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).setState({
                    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;This task is now complete!&#x27;</span>,
                });
            }, <span class="hljs-number">3000</span>);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Tooling can also help us acheive more efficient DOM manipulation. Generally, surgically updating the DOM may have performance implications on the UI, as arising from layout thrashing (see <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">this article</a> on Web Fundamentals). But we also don't need as much as a <em>Virtual DOM</em> for this. A technique like that of <a href="https://github.com/wilsonpage/fastdom">fast DOM</a> could just suffice.</p>
<p>This technique is natively implemented by the <a href="/tooling/play-ui">Play UI</a> library which has a jQuery-like API. We will now use Play UI as a drop-in replacement for jQuery in the code above.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Tooling In OOHTML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/playui-js@0.3.10/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/oohtml@1.8.12/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
                <span class="hljs-comment">// The .html() method is asynchronous</span>
                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.state.message) <span class="hljs-keyword">return</span>;
                $(<span class="hljs-built_in">this</span>.namespace.message).htmlAsync(<span class="hljs-built_in">this</span>.state.message).then(<span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-comment">// Do something sync</span>
                });
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">// Make Play UI available globally</span>
            <span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.WebQit.$;

            <span class="hljs-comment">// The alert</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).setState({
                    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;This task is now complete!&#x27;</span>,
                });
            }, <span class="hljs-number">3000</span>);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><a href="/html/tooling/oohtml/docs/learn/examples/tooling.html" target="_blank">Check the live demo here</a> or copy and paste the code in a blank HTML page and view in your browser.</p>

					</div>
				</template>
			</template>
		</template>

		<template name="resources">
			<div exportgroup="readme">

				

			</div>

			<template name="ecosystem">
				<div exportgroup="readme">

					<h1 id="ecosystem">Ecosystem</h1>
<p>Available Tools for developing OOHTML-based UIs.</p>
<ul>
<li><p><strong><a href="/tooling/play-ui">Play UI</a></strong> - The <a href="/tooling/play-ui/docs/getting-started/overview#play-ui-javascript">Play UI JavaScript</a> library - a jQuery-like DOM and UI manipulation library - offers certain methods, e.g. <a href="/tooling/play-ui/docs/api/dom/itemize"><strong><code>.itemize()</code></strong></a>, for <em>rendering</em> OOHTML-based UIs.</p>
<p>Also, the <a href="/tooling/play-ui/docs/getting-started/overview#play-ui-command-line">Play UI Command-Line Interface</a> - a command-line tool for UI development - offers certain commands, e.g. <a href="/tooling/play-ui/docs/cli/bundle"><strong><code>playui bundle</code></strong></a>, for <em>composing</em> OOHTML-based UIs.</p></li>
</ul>

				</div>
			</template>

			<template name="meta-tag">
				<div exportgroup="readme">

					<h1 id="the-oohtml-meta-tag">The OOHTML Meta Tag</h1>
<p>OOHTML provides a meta tag for customizing its syntax or behaviour. It generally looks like this:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;prop1=val1; prop2=val2;&quot;</span>&gt;</span></code></pre>
<p><em>The actual configurable properties are documented alongside the various OOHTML features.</em></p>
<p>It is recommended (but not required) that you configure your usage of OOHTML using this meta tag. As an example, below is how the default OOHTML syntax looks like for the <em>HTML module, import and export</em> feature. What we want to do is <a href="/tooling/oohtml/docs/spec/html-imports#polyfill">use a custom <em>import</em> element</a> instead of the default <em>import</em> element.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export1&quot;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>On the meta tag, we would set the <code>element.import</code> directive to a custom element name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.import=html-import;&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export1&quot;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">html-import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html-import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>As another example, below is how the default OOHTML syntax looks like for the <em>scoped IDs</em> feature. What we want to do is <a href="/tooling/oohtml/docs/spec/namespaced-html#polyfill">use a custom attribute name</a> instead of the default <em>id</em> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scoped-id&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scoped-id&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>On the meta tag, we would set the <code>attr.id</code> directive to a custom attribute name.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id;&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;scoped-id&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;scoped-id&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>This way, even if the default syntax for these features should change on a future update (as should be expected of a new and fast-evolving technology like OOHTML), your configurations will keep your pages wokring.</p>
<p>Customization also lets you explore around the whole new idea. Feel free to bring your findings to OOHTML's <a href="https://github.com/webqit/oohtml/discussions">GitHub Discussions</a>.</p>

				</div>
			</template>

			<template name="the-observer-api">
				<div exportgroup="readme">

					<h1 id="the-observer-api">The Observer API</h1>
<p>The Observer API is a web-native reactivity API for JavaScript. Visit this project <a href="/tooling/observer">in WebQit</a> or <a href="https://github.com/webqit/observer">on github</a>.</p>

				</div>
			</template>
		</template>

		<template name="spec">
			<div exportgroup="readme">

				<h1 id="oohtml-specifications">OOHTML Specifications</h1>

			</div>

			<template name="html-imports">
				<div exportgroup="readme">

					<h1 id="html-imports">HTML Imports</h1>
<p>HTML Imports are a declarative way to use the <em>exports</em> of an <em><a href="/tooling/oohtml/docs/spec/html-modules">HTML Module</a></em> from anywhere in the main document.</p>
<blockquote>
  <p>Note that this is different from the HTML Imports that was spec'd with an early version of Web Components.</p>
</blockquote>
<p><em>HTML Imports</em> introduces an <code>&lt;import&gt;</code> element that lets us place <em>module exports</em> into any location on the DOM.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features described on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>An <code>&lt;import&gt;</code> element is used to place a <em>module export</em> using the <code>name</code> attribute as <em>import identifier</em>, and the <code>template</code> attribute as <em>module identifier</em>.</p>
<p>Below are some <em>module exports</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- part of export-1 --&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <span class="hljs-comment">&lt;!-- part of export-2 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- part of export-2 --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>And here's a typical <code>&lt;import&gt;</code> element that imports a corresponding <em>module export</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Place all of export-1 here --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><em>Resolution</em> takes place and the <code>&lt;import&gt;</code> element is replaced by the contents of the matched <em>module export</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;import&gt; element replaced --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>All elements in the matched <em>module export</em> go together into the same <em>import slot</em>. Below, the <em>import ID</em> would match two elements.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">question-element</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Place all of export-2 here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">question-element</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">question-element</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import&gt; element replaced --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">question-element</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Taking things further, multiple <code>&lt;import&gt;</code> elements within a block can be scoped to just one <em>module ID</em> declaration. And any element may declare a <em>module ID</em> this way (using the <code>template</code> attribute) and thus serve as a <em>resolution scope</em> for the <code>&lt;import&gt;</code> elements within its subtree.</p>
<pre><code class="hljs html language-html">&lt;body template=&quot;module1&quot;&gt;

    &lt;!-- Place all of export-1 here --&gt;
    &lt;import name=&quot;export-1&quot;&lt;/import&gt;
    &lt;question-element&gt;
        &lt;!-- Place all of export-2 here --&gt;
        &lt;import name=&quot;export-2&quot;&gt;&lt;/import&gt;
    &lt;/question-element&gt;

&lt;/body&gt;</code></pre>
<p>At the same time, other <code>&lt;import&gt;</code> elements within a <em>resolution scope</em> may still reference their own module.</p>
<pre><code class="hljs html language-html">&lt;body template=&quot;module1&quot;&gt;

    &lt;!-- Place all of export-1 here --&gt;
    &lt;import name=&quot;export-1&quot;&lt;/import&gt;
    &lt;question-element&gt;
        &lt;!-- Place all of export-2 here --&gt;
        &lt;import name=&quot;export-2&quot; template=&quot;module2&quot;&gt;&lt;/import&gt;
    &lt;/question-element&gt;

&lt;/body&gt;</code></pre>
<h3 id="default-exports-and-imports">Default Exports and Imports</h3>
<p>HTML Modules are allowed to have contents without an <em>export identifier</em> and these are known <a href="/tooling/oohtml/docs/spec/html-modules#default-exports">Default Exports</a>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module3&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Enter your email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <span class="hljs-comment">&lt;!-- This is part of the default export --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- This is part of the default export --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Now, these arbitrary contents are also imported without an identifier.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Place all of the default export here --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h3 id="dynamic-module-references">Dynamic Module References</h3>
<p>HTML Imports supports certain conventions that let us dynamically match modules.</p>
<ul>
<li><p><strong>The <code>exportsearch</code> attribute:</strong> <code>&lt;import&gt;</code> elements that reference nested modules may define a search expression using the <code>exportsearch</code> attribute. A search expression allows the import resolution to look into ancestor modules to find the specified <em>export</em>.</p>
<p>The expression below is to go up to 2 steps from the right to find <code>export-2</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-2&quot; template=&quot;module1/nonexistent/nonexistent&quot; exportsearch=&quot;-2&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<blockquote>
  <p>Above, the path <code>module1/nonexistent/nonexistent</code> is tried first, then, the parent path <code>module1/nonexistent</code>, then, the parent's parent path <code>module1</code>; whichever level produces <code>export-2</code> first.</p>
</blockquote>
<p>In the same way, the expression below is to go up to 2 steps from the right, to at most 1 step from the left, to find <code>export-2</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-2&quot; template=&quot;module1/nonexistent/nonexistent/nonexistent&quot; exportsearch=&quot;1-2&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<blockquote>
  <p>Above, the resolution stops at <code>module1/nonexistent</code> which is still <em>nonexisitent</em>. The <code>&lt;import&gt;</code> element is left unresolved.</p>
</blockquote></li>
<li><p><strong>Wildcards:</strong> While the <code>+</code> character is <a href="/tooling/oohtml/docs/spec/html-modules#module-referencing">forbidden in module IDs</a>, it can be used as wildcard modifiers in the module reference on <code>&lt;import&gt;</code> elements. The <code>+</code> character is used to match </p></li>
</ul>
<h2 id="dynamicity">Dynamicity</h2>
<p><em>Import slots</em> are resolved in realtime in response to a number of events.</p>
<ul>
<li><p>When the module reference - the <code>template</code> attribute - is changed, the <code>&lt;import&gt;</code> element is resolved again.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;import[template=&quot;module1&quot;]&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre>
<p>This also applies to all <code>&lt;import&gt;</code> elements within resolution scopes. Below, all <code>&lt;import&gt;</code> elements scoped to <code>&lt;body&gt;</code> will be resolved again.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;body&#x27;</span>).setAttribute(<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);</code></pre></li>
<li><p>On any event that gets its slot empty (i.e on deleting the last of its slotted elements), an <code>&lt;import&gt;</code> element is automatically restored.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Remove the first element slotted</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;label&#x27;</span>).remove();
<span class="hljs-comment">// Remove the last element slotted</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>).remove();
<span class="hljs-comment">// The original &lt;import&gt; element should now be restored</span></code></pre></li>
<li><p>When exports and modules are added to the document or removed, all <code>&lt;import&gt;</code> elements referencing them are reevaluated accordingly.</p>
<p>With the module addition below, all <code>&lt;import&gt;</code> elements referencing <code>module1/nonexistent</code> will now be resolved.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> nestedModule = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);
nestedModule.setAttribute(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;nonexistent&#x27;</span>);
nestedModule.content.append(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>));

<span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;template[name=&quot;module1&quot;]&#x27;</span>);
module1.content.append(nestedModule);</code></pre>
<p>With the module removal below, all <code>&lt;import&gt;</code> elements currently <em>resolved</em> from <code>module1</code> and its nested modules will now be restored.</p>
<pre><code class="hljs js language-js">module1.remove();</code></pre></li>
<li><p>When the external contents of a remote module become available, all <code>&lt;import&gt;</code> elements that depend on the loaded content will be resolved. (See <a href="/tooling/oohtml/docs/spec/html-modules#module-events">Module Events</a>.)</p>
<p><strong>Remote file: /bundle.html</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module-loaded&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><strong>Document:</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>template name=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module-remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>!-- This is resolved immediately --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-1&quot; template=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>!-- This is resolved as the targetted export becomes available --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-2&quot; template=&quot;module1/module-remote&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>!-- This is resolved as the targetted export becomes available --<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-3&quot; template=&quot;module1/module-remote/module-loaded&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="slot-inheritance">Slot Inheritance</h2>
<p>An <code>&lt;import&gt;</code> element is rendered as a regular element until it is resolved, that is, replaced. Useful default content, along with attributes, may be displayed on its slot this way.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- An ixport element with default attribute and content --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;max-width:50px&quot;</span>&gt;</span>No image<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>An <code>&lt;import&gt;</code> element's attributes and default content may also be inheritted by slotted elements to persist the semantics of the slot.</p>
<ul>
<li><p><strong>Attributes</strong> - All attributes of an <code>&lt;import&gt;</code> element (other than the <code>name</code>, <code>template</code> and <code>exportsearch</code> attributes) are inheritted by slotted elements.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module1&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!-- The slotted element now inherits the style attribute  --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>img exportgroup=&quot;export-1&quot; src=&quot;logo.png&quot; style=&quot;max-width:50px&quot; /<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>When the attribute to inherit already exists on the element being slotted, one of the following happens:</p>
<ul>
<li>If the attribute is of space-delimitted attributes, like the <code>class</code> attribute, inheritted non-duplicate values are placed after existing values on the element being slotted.</li>
<li>If the attribute is of key/value attributes, like the <code>style</code> attribute, inheritted declarations are placed after existing declarations on the element being slotted (making CSS cascading work for the <code>style</code> attribute).</li>
<li>If the attribute is of single-value attributes, like the <code>id</code> attribute, the inheritted attribute value is made to replace exisiting value on the element being slotted.</li>
<li>All other attribute types are treated as single-value attributes.</li></ul></li>
<li><p><strong>Content</strong> - To inherit the default content of an <code>&lt;import&gt;</code> element, we would again use the regular import/export convention. Here the elements inheriting the default contents of the slot will implement its own <code>&lt;import&gt;</code> elements that would pull up the specific part of the contents being inherited.</p>
<p>These second-level <em>imports</em> set their <code>template</code> attribute to the tilde <code>~</code> character to reference their destination slot as their source module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>template name=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>!--
    The element being slotted pointing to its destination slot
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>!--
        The <span class="hljs-symbol">&amp;lt;</span>import<span class="hljs-symbol">&amp;gt;</span> element that actually imports the contents of its destination slot
        --<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>import name=&quot;default-content&quot; template=&quot;~&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>On the slot side, the <code>&lt;import&gt;</code> element will be acting as a module and its contents can be defined as <em>module exports</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>!--
    The <span class="hljs-symbol">&amp;lt;</span>import<span class="hljs-symbol">&amp;gt;</span> element as a module
    --<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>import name=&quot;export-1&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;default-content&quot;<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/import<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The default content is thus persisted on resolving the above.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>div template=&quot;module2&quot;<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export-1&quot; template=&quot;@slot&quot;<span class="hljs-symbol">&amp;gt;</span>
        <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;default-content&quot;<span class="hljs-symbol">&amp;gt;</span>No results<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h2 id="isomorphic-rendering">Isomorphic Rendering</h2>
<p>When rendering happens on the server and has to be serialized for the browser to take over, <code>&lt;import&gt;</code> elements that are replaced on the server will need to be kept in some way in the serialized HTML output. This would enable the browser, on load, to <em>hydrate</em> the original <code>&lt;import&gt;</code> elements and map them in their replaced state to their currently slotted contents. With this, deleting a slot's contents, for example, should still trigger the restoration of the hydrated <code>&lt;import&gt;</code> element.</p>
<p>HTML Imports makes it possible to serialize <code>&lt;import&gt;</code> elements into <em>comment nodes</em> (<code>&lt;!-- &lt;import&gt;&lt;/import&gt; --&gt;</code>) when rendering on the server. HTML Imports in the browser can also be told to rehydrate the resolved <code>&lt;!-- &lt;import&gt;&lt;/import&gt; --&gt;</code> elements found in the server's serialized HTML output. This feature is turned on by setting the <code>isomorphic</code> directive to <code>1</code> or <code>true</code> on the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>.</p>
<p><strong>HTML to be rendered on the server</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>The serialized HTML output</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name=&quot;export-1&quot; id=&quot;headline&quot; style=&quot;color:red&quot;&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template=&quot;module1&quot; name=&quot;export-1&quot; style=&quot;color:blue&quot;&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><strong>Hydrated slots in the browser</strong></p>
<p>On loading the above serialized HTML output in the browser, find and delete the server-slotted element with ID <code>#headline</code>. The original <code>&lt;import&gt;</code> element should now be restored.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;isomorphic=true;&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot-1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>Default Headline<span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- &lt;import name=&quot;slot-1&quot; id=&quot;headline&quot; style=&quot;color:red&quot;&gt;Default Headline&lt;/import&gt; --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">import</span>=<span class="hljs-string">&quot;slot-1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;import template=&quot;module1&quot; name=&quot;slot-1&quot; style=&quot;color:blue&quot;&gt;&lt;/import&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill implementation</a> has full support for HTML Imports. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="#convention">element.import</a></strong> - The tag name for the <code>&lt;import&gt;</code> element. The standard <code>&lt;import&gt;</code> element is <code>&lt;import&gt;</code>. This can be changed where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.import=html-import;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">html-import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html-import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.importid</a></strong> - The <em>import ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.importid=data-name;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#module-reference-specificity">attr.templatespec</a></strong> - The <em>module specificity</em> attribute. The standard attribute is <code>exportsearch</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.templatespec=module-specificity;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span> <span class="hljs-attr">module-specificity</span>=<span class="hljs-string">&quot;0-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML META tag <a href="/tooling/oohtml/docs/resources/meta-tag">here</a>.</p>

				</div>
			</template>

			<template name="html-modules">
				<div exportgroup="readme">

					<h1 id="html-modules">HTML Modules</h1>
<p><em>HTML Modules</em> are a templating feature that lets us write reusable HTML markup using the <em>module</em>, <em>export</em> and  <em>import</em> paradigm. This feature establishes the standard <code>&lt;template&gt;</code> element as the foundation of a module infrastructure for HTML and introduces new attributes, properties and events that together closes the loop.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>An HTML module is a standard <code>&lt;template&gt;</code> element with a <code>name</code> attribute - which serves as the <em>module identifier</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The contents of a module are simply the <em>module exports</em>.</p>
<p>Now, exports may be more properly wrapped within an <code>&lt;export&gt;</code> element of a designated name - the <em>export identifier</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Or they may be individually <em>tagged</em> to an export identifier using the <code>exportgroup</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>How old are you?<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is another export<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>Contents not associated with an export identifier are regarded as <em>default exports</em>. They implicitly have 'default' as their export identifier.</p>
<h3 id="module-naming-guide">Module-Naming Guide</h3>
<ul>
<li>A module ID must not contain any special characters (e.g <code>~</code>, <code>#</code>, <code>/</code>, <code>&amp;</code>, <code>!</code>, <code>^</code>, <code>%</code>, <code>+</code>, <code>.</code>, etc) except the following: <code>@</code>, <code>-</code>, <code>_</code>.</li>
</ul>
<h3 id="module-nesting">Module Nesting</h3>
<p>For organizational purposes, modules may be nested.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is snippet 4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p>The full <em>module ID</em> of a nested module would be a path expression, e.g <code>module1/module_nested</code>.</p>
<p>Unnested modules are called <em>top-level modules</em>.</p>
<h3 id="module-referencing">Module Referencing</h3>
<p>Modules can be referenced by their module ID from anywhere in a page using the <code>template</code> attribute. Think Custom Elements that often depend on templates for their Shadow DOM's source markup. These dependencies would be simply declared using the <code>template</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Or in the case of a nested module.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1/module_nested&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>The internal JavaScript code for <code>&lt;my-prompt&gt;</code> would simply get a copy of the referenced module delivered via the <a href="#api">modules API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">const</span> myPrompt = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;my-prompt&#x27;</span>);
<span class="hljs-built_in">console</span>.log(myPrompt.template); <span class="hljs-comment">// HTMLTemplateElement {}</span></code></pre>
<blockquote>
  <p>The <code>template</code> attribute supports all of <a href="#module-reference-expressions">Module Reference Expressions</a>.</p>
</blockquote>
<h2 id="remote-content">Remote Content</h2>
<p>Template elements may reference remote content using the <code>src</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_remote&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p><strong>Remote file: /bundle.html</strong></p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_loaded&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p>Remote contents automatically become the template's content on load.</p>
<blockquote>
  <p>The <code>src</code> attribute isn't honoured when a template already has content.</p>
</blockquote>
<h2 id="api">API</h2>
<p><em>HTML Modules</em> offers a set of APIs that lets us access modules, imports and exports as JavaScript objects and properties. One advantage this gives us is that it minimizes selector-based queries.</p>
<ul>
<li><p><strong>document.templatesQuery(query): HTMLTemplateElement</strong> - This is a method on the <code>document</code> object for querying the document's module tree using a query expression. </p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1&#x27;</span>);
<span class="hljs-comment">// module1 = &quot;copy&quot; of document.templates.module1</span>
<span class="hljs-comment">// console.log(module1 === document.templates.module1); // false</span></code></pre>
<blockquote>
  <p>This method supports all of <a href="#module-reference-expressions">Module Reference Expressions</a>.</p>
</blockquote></li>
<li><p><strong>document.templates: Object</strong> - This is a <em>readonly</em> property on the <code>document</code> object that gives the document's top-level templates as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1; <span class="hljs-comment">// Returns the &quot;module1&quot; element in the markup somewhere above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.templates: Object</strong> - This is a <em>readonly</em> property on the <code>&lt;template&gt;</code> element that gives the template's own nested templates as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;
<span class="hljs-keyword">let</span> module_nested = module1.templates.module_nested; <span class="hljs-comment">// Returns the nested &quot;module_nested&quot; element above</span></code></pre></li>
<li><p><strong>HTMLTemplateElement.prototype.exports: Object</strong> - This is a <em>readonly</em> property on the <code>&lt;template&gt;</code> element that gives the template's <em>exports</em> as an object. Each export is given as an <em>array</em> of elements.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templates.module1;

<span class="hljs-comment">// Named exports</span>
<span class="hljs-keyword">let</span> questionExport = module1.exports.question; <span class="hljs-comment">// Returns the &quot;label&quot; and &quot;input&quot; elements above</span>
<span class="hljs-built_in">console</span>.log(questionExport.length); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">let</span> defaultExport = module1.exports.default; <span class="hljs-comment">// Returns the &quot;default&quot; export in the markup somewhere above</span>
<span class="hljs-built_in">console</span>.log(defaultExport.length); <span class="hljs-comment">// 1</span></code></pre></li>
<li><p><strong>Element.prototype.template: HTMLTemplateElement</strong> - This is a <em>readonly</em> property of any element that returns <em>a copy</em> of the element's referenced module - the <code>&lt;template&gt;</code> element that is referenced in its <code>template</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.template;
<span class="hljs-comment">// A copy of module1</span></code></pre>
<p>Here's how this could be used in the internal JavaScript code of the <code>&lt;my-prompt&gt;</code> custom element.</p>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-prompt&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// Get the referenced template element</span>
        <span class="hljs-keyword">let</span> moduleReference = <span class="hljs-built_in">this</span>.template;
        <span class="hljs-comment">// Clone its &quot;question&quot; export</span>
        <span class="hljs-keyword">let</span> shadowContent = moduleReference.exports.question.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.cloneNode(<span class="hljs-literal">true</span>));
        <span class="hljs-comment">// Create Shadow DOM and send in the content</span>
        <span class="hljs-keyword">let</span> shadow =  <span class="hljs-built_in">this</span>.attachShadow({<span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span>});
        shadow.append(...shadowContent);
    }
});</code></pre>
<p>Here's how the HTML consuming the component could look.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Flavour 1 of &lt;my-prompt&gt; --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Flavour 2 of &lt;my-prompt&gt; --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">my-prompt</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-prompt</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<h3 id="module-events">Module Events</h3>
<p>The following events are fired on <code>&lt;template&gt;</code> elements that load remote content.</p>
<ul>
<li><strong>load: Event</strong> - This event is fired on the <code>&lt;template&gt;</code> element on loading its remote content.</li>
<li><strong>loaderror: Event</strong> - This event is fired on the <code>&lt;template&gt;</code> element when there is an error loading its remote content.</li>
</ul>
<p>The following events are fired on the document object when the document's modules or their composition change.</p>
<ul>
<li><p><strong>templatemutation: Event</strong> - This event is fired on the <code>document</code> object when templates are added to or removed from the document, or when exports are added to or removed from a module. The <em>event</em> object has a <code>.detail</code> property that gives the details of the event.</p>
<ul>
<li><strong>event.detail.path: String</strong> - This gives the path to the event source, the module under which the event is fired. This is empty when top-level modules are added to or removed from the document.</li>
<li><strong>event.detail.addedExports: Array</strong> - This gives the list of exports added to a module. Each <em>entry</em> is an object describing the added export.<ul>
<li><strong>entry.name: String</strong> - The name of the export.</li>
<li><strong>entry.items: Array</strong> - Elements in the export.</li></ul></li>
<li><strong>event.detail.removedExports: Array</strong> - This gives the list of exports removed from a module. Each <em>entry</em> is an object describing the removed export.<ul>
<li><strong>entry.name: String</strong> - The name of the export.</li>
<li><strong>entry.items: Array</strong> - Elements in the export.</li></ul></li>
<li><strong>event.detail.addedTemplates: Array</strong> - This gives the list of templates added to a module or the top-level scope. Each <em>entry</em> is an object describing the added template.<ul>
<li><strong>entry.name: String</strong> - The name of the template.</li>
<li><strong>entry.item: HTMLTemplateElement</strong> - The template element.</li></ul></li>
<li><strong>event.detail.removedTemplates: Array</strong> - This gives the list of templates removed from a module or the top-level scope. Each <em>entry</em> is an object describing the removed template.<ul>
<li><strong>entry.name: String</strong> - The name of the template.</li>
<li><strong>entry.item: HTMLTemplateElement</strong> - The template element.</li></ul></li></ul>
<p>With the listener below, adding a new template to the document, or removing one, will be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;templatemutation&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>
<p>With the code below, the fired event's <code>.detail.path</code> property will be empty, while its <code>.detail.addedTemplates</code> property will give a list of one added template whose <em>name</em> is <code>module2</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> template = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);
template.setAttribute(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;module2&#x27;</span>);
<span class="hljs-built_in">document</span>.body.append(template);</code></pre>
<p>With the code below, when the nested module is done loading its contents, its exports are given in a <code>templatemutation</code> event on its <code>.detail.addedExports</code> property. If loaded contents include template elements themselves, they will be given in the event's <code>.detail.addedTemplates</code> property. The event's <code>.detail.path</code> property itself will be <code>module2/module_remote</code>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export5&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export6&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module_remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong>templatecontentloaded: Event</strong> - This event is fired on the <code>document</code> object when a template completes loading its remote content. The event object has a <code>.detail</code> property that gives the template element and its path.</p>
<p>With the code below, when the nested template is done loading its contents, a report is logged to the console with path being <code>module2/module_remote</code>.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;templatecontentloaded&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.detail.path, event.detail.template);
});</code></pre>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export5&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>div exportgroup=&quot;export6&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>

    <span class="hljs-symbol">&amp;lt;</span>template name=&quot;module_remote&quot; src=&quot;/bundle.html&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/template<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong>templatecontentloaderror: Event</strong> - This event is fired on the <code>document</code> object when a template fails loading its remote content. The event object has a <code>.detail</code> property that gives the template element and its path.</p></li>
</ul>
<h3 id="module-reference-expressions">Module Reference Expressions</h3>
<p>OOHTML supports expressions that make it easier to get to modules and their exports.</p>
<ul>
<li><p>Path expressions supported: <strong>/</strong>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1/module_nested&#x27;</span>);
<span class="hljs-comment">// module_nested = &quot;copy&quot; of document.templates.module1.templates.module_nested</span>
<span class="hljs-comment">// console.log(module_nested === document.templates.module1.templates.module_nested); // false</span></code></pre></li>
<li><p>Filters supported: <strong>:having()</strong>, <strong>:not-having()</strong>.</p>
<p><em>Assert that a module has an export.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1:having(:export5)/module_nested&#x27;</span>);</code></pre>
<p><em>Assert that a module has a nested module.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> moduleRemote = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1:having(module_nested)/module_remote&#x27;</span>);</code></pre></li>
<li><p>Logical and mathematical operators supported: <strong>|</strong>, <strong>+</strong>, <strong>*</strong>.</p>
<p><em>Return the first module if exists, otherwise, second module.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> moduleRemote = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1/module_nonexistent|module_remote&#x27;</span>);</code></pre>
<p><em>Return the joint contents of first module and second module. (Contents = both modules and exports.)</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> moduleJoint = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1/module_nonexistent+module_remote&#x27;</span>);</code></pre>
<p><em>Return the joint contents of all modules at given level. (Contents = both modules and exports.)</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> moduleJoint = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module1/*&#x27;</span>);</code></pre></li>
<li><p>Find a module deeply: <strong>:deep()</strong>, <strong>:deepest()</strong>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested_middle&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p><em>Return the deeply-first <code>module_nested</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_Deep = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_nested:deep()&#x27;</span>);</code></pre>
<p><em>Return the deeply-last <code>module_nested</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_Deepest = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_remote:deepest()&#x27;</span>);</code></pre></li>
<li><p>Optional chaining supported. <strong>?/</strong>.</p>
<p><em>Return the deeply-last module. (Expects: <code>module_nested_middle</code>)</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_middle = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;root?/module_nested?/module_nested_middle?/module_nonexistent?/module_nonexistent&#x27;</span>);</code></pre>
<p><em>(Equivalent accessor syntax)</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_middle = documents.templates.root?.templates.module_nested?.templates.module_nested_middle?.templates.module_nonexistent?.templates.module_nonexistent;</code></pre></li>
<li><p>Complex expression supported.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested_middle&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_nested&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_near_leaf_a&quot;</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_leaf_a&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_near_leaf_b&quot;</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module_leaf_b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<p><em>Return the deeply-last <code>module_nested:having(module_nested_middle)</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_Deep = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_remote:having(module_nested_middle):deepest()&#x27;</span>);</code></pre>
<p><em>Return the deeply-last <code>module_nested</code> if <code>:having(module_nested_middle)</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> not_found = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_remote:deepest():having(module_nested_middle)&#x27;</span>);
<span class="hljs-comment">// Not found. The order of the assertions matters</span></code></pre>
<p><em>Return <code>module_nested_middle</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_nested_middle = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_remote:having(module_nested_middle):deep()/module_nested_middle&#x27;</span>);</code></pre>
<p><em>Skip and skip until the level: <code>module_near_leaf_</code>, join their contents and return <code>module_leaf_a</code>.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module_leaf_a = <span class="hljs-built_in">document</span>.templatesQuery(<span class="hljs-string">&#x27;module_nested_middle:deep()/module_near_leaf_a:deep()+module_near_leaf_b:deep()/module_leaf_a&#x27;</span>);</code></pre></li>
</ul>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill implementation</a> has full support for the HTML Modules specification. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="#convention">attr.moduleid</a></strong> - The <em>module ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.moduleid=data-name;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">element.export</a></strong> - The tag name for the <code>&lt;export&gt;</code> element. The standard <code>&lt;export&gt;</code> element is <code>&lt;export&gt;</code>. This can be changed where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;element.export=html-export;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">html-export</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">html-export</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.exportid</a></strong> - The <em>export ID</em> attribute. The standard attribute is <code>name</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.exportid=data-name;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">export</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.exportgroup</a></strong> - The <em>exportgroup</em> attribute. The standard attribute is <code>exportgroup</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.exportgroup=data-exportgroup;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-exportgroup</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-exportgroup</span>=<span class="hljs-string">&quot;export-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.moduleref</a></strong> - The <em>module reference</em> attribute. The standard attribute is <code>template</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.moduleref=data-template;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-template</span>=<span class="hljs-string">&quot;module2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;export-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#api">api.templates</a></strong> - The <em>templates</em> property exposed on the document object and on HTML template elements. The standard property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.templates=templatelist;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">document</span>.templatelist.module1;</code></pre></li>
<li><p><strong><a href="#api">api.exports</a></strong> - The <em>exports</em> property exposed on HTML template elements. The standard property is <code>templates</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.exports=exportlist;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> export1 = module1.exportlist.export1;</code></pre></li>
<li><p><strong><a href="#api">api.moduleref</a></strong> - The <em>module reference</em> property exposed on HTML elements. The standard property is <code>template</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.moduleref=tpl;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> templateDependency = myPrompt.tpl;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/resources/meta-tag">here</a>.</p>

				</div>
			</template>

			<template name="namespaced-html">
				<div exportgroup="readme">

					<h1 id="namespaced-html">Namespaced HTML</h1>
<p>Namespacing provides a way to let an element establish its own naming context for descendant elements. This makes it possible to keep IDs scoped to a context other than the document's global scope; thus the ability to write collision-free IDs across a page.</p>
<p>Namespaced HTML is a document that is structured as a hierarchy of <em>scopes</em> and <em>subscopes</em>.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Namespaces are designated with the <code>namespace</code> <em>Boolean</em> attribute.</p>
<p>In the code below, the given ID is scoped to the element with the <code>namespace</code> attribute.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;some-id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>And below is a <strong>hierarchy of <em>namespaces</em> and <em>sub namespaces</strong></em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;continents&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;europe&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Europe<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Europe<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asia&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About Asia<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries&quot;</span>&gt;</span>Countries in Asia<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></code></pre>
<p>The above gives us a conceptual model of repeating objects, each encapsulating its IDs:</p>
<pre><code class="hljs html language-html">continents
 ├⏤europe
 │   ├⏤about
 │   ├⏤countries
 ├⏤asia
     ├⏤about
     ├⏤countries</code></pre>
<h2 id="namespaced-selectors">Namespaced Selectors</h2>
<p>Being able to layout elements in namespaces makes it possible to write collision-free CSS selectors. OOHTML introduces the concept of <em>Namespaced Selectors</em> which are regular CSS expressions written with a path notation.</p>
<p>Namespaced Selectors use the forward slash <code>/</code> to denote a namespace boundary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-id">#continents</span> / <span class="hljs-selector-id">#europe</span> / <span class="hljs-selector-id">#countries</span> {
    <span class="hljs-attribute">color</span>: darkblue;
}
<span class="hljs-selector-id">#continents</span> / <span class="hljs-selector-id">#asia</span> / <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">color</span>: orange;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>And this convention can be used with existing DOM Selector APIs.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> aboutAsia = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#continents / #asia / #about&#x27;</span>);
<span class="hljs-keyword">let</span> divsAsia = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#continents / #asia / div&#x27;</span>);</code></pre>
<h2 id="api">API</h2>
<p><em>Namespaced HTML</em> offers an API for traversing namespaces as object trees. One advantage this gives us is that it minimizes selector-based queries.</p>
<ul>
<li><p><strong>document.namespace: Object</strong> - This <em>readonly</em> property gives the document's namespaced IDs - IDs scoped to the document - as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents; <span class="hljs-comment">// Returns the &quot;#continents&quot; element in the markup above</span></code></pre></li>
<li><p><strong>Element.prototype.namespace: Object</strong> - This <em>readonly</em> property gives an element's namespaced IDs - IDs scoped to the element - as an object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.namespace.continents;

<span class="hljs-comment">// Access scoped IDs with the new &quot;namespace&quot; DOM property</span>
<span class="hljs-keyword">let</span> europe = continents.namespace.europe;
<span class="hljs-keyword">let</span> asia = continents.namespace.asia;

<span class="hljs-comment">// And for deeply-nested IDs...</span>
<span class="hljs-keyword">let</span> aboutAsia = continents.namespace.asia.namespace.about;</code></pre></li>
</ul>
<h2 id="namespace-observability">Namespace Observability</h2>
<p>The <code>document.namespace</code> property and the <code>Element.prototype.namespace</code> property are implemented as <em>live objects</em> that can be observed for realtime changes in the namespace tree. Live objects are observed using the <a href="/tooling/oohtml/docs/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(continents.namespace, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
    });
});</code></pre>
<p>We could as well specify just the path to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, <span class="hljs-string">&#x27;africa&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-comment">// We&#x27;re now also logging the event&#x27;s value, that is, the element</span>
    <span class="hljs-built_in">console</span>.log(e.type, e.value);
});</code></pre>
<p>With the code above, adding a new ID - <code>africa</code> - to the <code>continents</code> namespace would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> section = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;section&#x27;</span>);
section.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;africa&#x27;</span>);
continents.append(section);</code></pre>
<p>Removing this element would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js">continents.namespace.africa.remove();</code></pre>
<p>To observe changes down the namespace hierarchy, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path<span class="hljs-comment">/*watch this*/</span>, e.value);
    });
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(continents.namespace, [<span class="hljs-string">&#x27;africa&#x27;</span>, <span class="hljs-string">&#x27;namespace&#x27;</span>, <span class="hljs-string">&#x27;countries&#x27;</span>], <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.path, e.value));
});</code></pre>
<p>Other possibilities can be found in the Observer API documentation.</p>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill implementation</a> has good support for the Namespaced HTML Specification. With the exception of <a href="#namespaced-selectors">Namespaced Selectors</a>, all aspects of the specification are supported. The polyfill additionally makes it possible to customise the following areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="#convention">attr.namespace</a></strong> - The <em>namespace keyword</em> attribute. The standard <em>namespace keyword</em> attribute is <code>namespace</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.namespace=data-namespace;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#convention">attr.id</a></strong> - The <em>namespaced-ID</em> attribute. The standard <em>namespaced-ID</em> attribute is <code>id</code>, but you may use a custom attribute name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;attr.id=data-id;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">namespace</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;id01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;id02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></li>
<li><p><strong><a href="#api">api.namespace</a></strong> - The <em>namespace</em> property exposed on the document object and on elements. The standard <em>namespace</em> property is <code>namespace</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.namespace=ns;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Get the &quot;continents&quot; article</span>
<span class="hljs-keyword">let</span> continents = <span class="hljs-built_in">document</span>.ns.continents;</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/spec/meta-tag">here</a>.</p>

				</div>
			</template>

			<template name="subscript">
				<div exportgroup="readme">

					<h1 id="subscript">Subscript</h1>
<p>Subscript is a type of JavaScript runtime that lets us create scoped, <em>reactive</em> <code>&lt;script&gt;</code> elements across an HTML document. That gives us a UI binding language and the ability to write UI logic without involving actual JavaScript classes or files.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="convention">Convention</h2>
<p>Subscript lets us write <code>&lt;script&gt;</code> elements that are scoped to their host elements instead of the global browser scope. Below is such a <code>&lt;script&gt;</code> element, being scoped to the <code>#alert</code> element - its host element:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id); <span class="hljs-comment">// alert</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The <code>this</code> variable within subscript is a reference to the script's host element. In addition, variables declared within the script are available only within the script, and global variables are always available across all scripts.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Global scope</span>
    <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">&#x27;Task failed!&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = alertMessage; <span class="hljs-comment">// Task failed!</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>They keep their variables from leaking out to the global scope.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Global scope</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// undefined</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>This lets us place behaviours of any form just where across the page we need them!</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// Global variable</span>
        <span class="hljs-keyword">let</span> alertMessage = <span class="hljs-string">&#x27;Task failed!&#x27;</span>;
        <span class="hljs-comment">// The element&#x27;s state property</span>
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).state.message = <span class="hljs-string">&#x27;Task complete!&#x27;</span>;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message || alertMessage;
            <span class="hljs-built_in">console</span>.log(message);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Now, that was a bare-bones <code>#alert</code> component above! We could make it quite interactive by giving it a <em>remove</em> feature.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;close&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message;
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.message&#x27;</span>).innerHTML = message;
        <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.close&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<h2 id="runtime">Runtime</h2>
<p>Subscript is drastically different in behaviour from other JavaScript types (type="module", type="text/javascript", etc). The difference is that the script has the ability to observe the variables in its scope and respond to those changes. Changes that fire up the script this way are called <em>events</em>, and a script's response to these events is called the <em>event-based runtime</em>.</p>
<p>The event-based runtime can be understood from the code below. Take note of the first statement in the script which makes a reference to the <code>#alert</code> element's <code>.state.message</code> property.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">namespace</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;close&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Close this message.&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> message = <span class="hljs-built_in">this</span>.state.message;
        <span class="hljs-built_in">this</span>.namespace.message.innerHTML = message;
        <span class="hljs-built_in">this</span>.namespace.close.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">this</span>.remove();
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>This script will, at first, run top-down as with standard JavaScript. Then, it will begin to observe changes to the <code>this.state.message</code> reference - being an observable property. And when a change is detected, that particular statement will be reevaluated, and the new value is (re)assigned to the local <code>message</code> variable.</p>
<p>The following update to the element's state property will trigger that <em>event</em>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#alert&#x27;</span>).state.message = <span class="hljs-string">&#x27;Task restarted!&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Now, the same event that changed the script's local <code>message</code> variable will go further to fire up subsequent statements that depend on it, in this case, leading to the new message being rendered. The third statement in this script is left untouched as it does not depend on the current change.</p>
<p>Thus, when events happen, the dependency chain within the script is followed even when broken down into local variables.</p>
<h3 id="observability">Observability</h3>
<p>The event-based runtime uses the <a href="/tooling/oohtml/docs/spec/the-observer-api">Observer API</a> to observe objects in its scope whose properties can be observed. These are called <em>live objects</em>.</p>
<p>By default, the <code>this</code> object and the <code>document</code> object are observed. Thus, setting, updating or removing any of their properties using the Observer API will trigger the appropriate statement in a Subscript runtime.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global observableProperty:&#x27;</span>, <span class="hljs-built_in">document</span>.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own observableProperty:&#x27;</span>, <span class="hljs-built_in">this</span>.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;observableProperty&#x27;</span>, counter ++);
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(divElement, <span class="hljs-string">&#x27;observableProperty&#x27;</span>, counter2 ++);
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>But, as seen in the <code>#alert</code> example above, we can more easily set or remove observable properties using an element's <em>state object</em> (or the document's <em>state object</em>) as it internally uses the Observer API to apply property assignments and deletions.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global state.observableProperty:&#x27;</span>, <span class="hljs-built_in">document</span>.state.observableProperty);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own state.observableProperty:&#x27;</span>, <span class="hljs-built_in">this</span>.state.observableProperty);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">document</span>.state.observableProperty = counter ++;
    }, <span class="hljs-number">8000</span>);

    <span class="hljs-keyword">let</span> counter2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        divElement.state.observableProperty = counter2 ++;
    }, <span class="hljs-number">4000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>In any of the cases above, we could get deep object mutations to be caught by the Subscript runtime using the Observer API.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Global clock.time:&#x27;</span>, <span class="hljs-built_in">document</span>.clock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own state.clock.time:&#x27;</span>, <span class="hljs-built_in">this</span>.state.clock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Initial binding</span>
    Observer.set(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;clock&#x27;</span>, {});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(<span class="hljs-built_in">document</span>.clock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        Observer.set(divElement.state.clock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="bindings">Bindings</h3>
<p>While the <code>this</code> object and the <code>document</code> object are automatically observed from within an element's Subscript runtime, it is also possible to bind other objects to the script's scope. This is done using a <code>.bind()</code> method on the element - to bind locally, or on the <code>document</code> object - to bind globally for all scripts in the document.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Globally-bound clock time:&#x27;</span>, globallyBoundClock.time);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Own-bound clock time:&#x27;</span>, locallyBoundClock.time);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// Create a collection of variables</span>
    <span class="hljs-keyword">let</span> globallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
    <span class="hljs-comment">// Bind them to all Subscript scopes in the document</span>
    <span class="hljs-built_in">document</span>.subscript.bind({globallyBoundClock});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Update existing binding</span>
        Observer.set(globallyBoundClock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
        <span class="hljs-comment">// Create new ones on the fly anytime</span>
    }, <span class="hljs-number">100</span> * <span class="hljs-number">60</span>);

    <span class="hljs-keyword">let</span> divElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);
    <span class="hljs-comment">// Create a collection of variables</span>
    <span class="hljs-keyword">let</span> locallyBoundClock = {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
    <span class="hljs-comment">// Bind them to the current script</span>
    divElement.subscript.bind({locallyBoundClock});
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Update existing binding for the current script</span>
        Observer.set(locallyBoundClock, <span class="hljs-string">&#x27;time&#x27;</span>, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).toLocaleString());
        <span class="hljs-comment">// Create new ones on the fly anytime</span>
    }, <span class="hljs-number">100</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h4 id="api">API</h4>
<p>The following methods are used to dynamically bind observable variables to Subscript scopes.</p>
<ul>
<li><p><strong>document.subscript.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the document-level for all Subscript scopes across the document.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind globally for all Subscript scopes in the document.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update existing variables in Subscript's global scope from properties of the given object or establish the given object as Subscript new global scope. Default: <code>false</code> - establish as new global scope.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
<span class="hljs-built_in">document</span>.subscript.bind({
    <span class="hljs-attr">globallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
<span class="hljs-built_in">document</span>.subscript.bind({
    <span class="hljs-attr">globallyBoundClock2</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>document.subscript.unbind(): Void</strong> - This method lets us unbind any existing binding from the document.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
<span class="hljs-built_in">document</span>.subscript.unbind();</code></pre></li>
<li><p><strong>Element.prototype.subscript.bind(bindings[, params]): Void</strong> - This method lets us bind objects at the element-level. Objects bound here are automatically-observed in the element's <em>binding</em> script.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bindings: Object</code> - The object to bind to the element's Subscript scope.</li>
<li><code>params: Object</code> - (Optional) Binding options:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update existing variables in the element's local scope from properties of the given object or establish the given object as the element's local scope. Default: <code>false</code> - establish as new scope.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Undo previous binding, if exists</span>
divElement.subscript.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
});

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update previous binding, if exists</span>
divElement.subscript.bind({
    <span class="hljs-attr">locallyBoundClock</span>: {<span class="hljs-attr">time</span>: <span class="hljs-string">&#x27;00:00:00&#x27;</span>,};
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});</code></pre></li>
<li><p><strong>Element.prototype.subscript.unbind(): Void</strong> - This method lets us unbind any existing binding from an element's <em>binding</em> script.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind existing binding</span>
divElement.subscript.unbind();</code></pre></li>
</ul>
<h2 id="error-handling">Error Handling</h2>
<p>Subscript features a way to handle errors that may occur within scripts. By default, script errors are logged to the console. But they can be silently ignored by setting a <code>script.errors</code> directive on the <a href="/tooling/oohtml/docs/spec/meta-tag">OOHTML META tag</a>.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;chtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script.errors=0;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">this</span>.querySelectorSelectorSelector(<span class="hljs-string">&#x27;h1&#x27;</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Individual script tags may also be given an <code>errors</code> directive, to override the global <code>script.errors</code> directive for the script.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;chtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script.errors=0;&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;subscript&quot;</span> <span class="hljs-attr">binding</span> <span class="hljs-attr">errors</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="javascript">
            <span class="hljs-built_in">this</span>.querySelectorSelectorSelector(<span class="hljs-string">&#x27;h1&#x27;</span>).innerHTML = headline;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill implementation</a> has good support for Subscript. The polyfill additionally makes it possible to customise the follwoing areas of its implementation of the syntax using the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="#convention">selector.script</a></strong> - The CSS selector for matching the script element. The default selector is <code>script[type="subscript"]</code>. You may use a custom selector, like <code>script[is="my-script"][type="subscript"]</code>, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;selector.script=script[is=&#x27;my-script&#x27;][type=&#x27;reflex&#x27;];&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>    <span class="hljs-symbol">&amp;lt;</span>script is=&quot;my-script&quot; type=&quot;subscript&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>script is=&quot;my-script&quot; type=&quot;subscript&quot;<span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>

<span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/resources/meta-tag">here</a>.</p>

				</div>
			</template>

			<template name="the-state-api">
				<div exportgroup="readme">

					<h1 id="the-state-api">The State API</h1>
<p>The State API is a DOM API that lets us maintain application state at the document level and at individual element levels. It brings application state closer to the UI and makes it easy to keep the UI in sync with all the changes taking place.</p>
<blockquote>
  <p>OOHTML is <a href="https://discourse.wicg.io/t/proposal-chtml/4716">being proposed as a native browser technology</a> while currently available through a polyfill. Be sure to check the <a href="#polyfill-support">Polyfill Support</a> section below for the features on this page.</p>
</blockquote>
<h2 id="api">API</h2>
<p>This API exposes a document-level <em>state object</em> on a <code>document.state</code> property, and an element-level <em>state object</em> on an <code>element.state</code> property. Arbitrary values can be set and retrieved on <em>state objects</em> the same way we would with regular objects.</p>
<h3 id="document-level-state">Document-Level State</h3>
<p>Document-level state represents the global state of an application.</p>
<ul>
<li><p><strong>document.state: Object</strong> - This <em>readonly</em> property exposes a <em>state object</em> whose properties can be written to and read from - from any part of the page.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
<span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span></code></pre></li>
<li><p><strong>document.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on the <code>document.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Thanks for visiting.&#x27;</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    },
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Hello World!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// {main, aside}</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
<span class="hljs-built_in">document</span>.setState({
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Bonjour le Monde!&#x27;</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> pageTitle = <span class="hljs-built_in">document</span>.state.pageTitle; <span class="hljs-comment">// Bonjour le Monde!</span>
<span class="hljs-keyword">let</span> pageContent = <span class="hljs-built_in">document</span>.state.pageContent; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>document.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from the document's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
<span class="hljs-built_in">document</span>.clearState();</code></pre></li>
</ul>
<h3 id="element-level-state">Element-Level State</h3>
<p>Element-level state represents the local state of an element.</p>
<ul>
<li><p><strong>Element.prototype.state: Object</strong> - This <em>readonly</em> property exposes a <em>state object</em> for the element whose properties can written to and read as-is.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Assign properties</span>
myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// -------</span>

<span class="hljs-comment">// Example usage - a simple toggle</span>
myCollapsible.onclick = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (myCollapsible.state.collapsed) {
        myCollapsible.style.height = <span class="hljs-string">&#x27;auto&#x27;</span>;
    } <span class="hljs-keyword">else</span> {
        myCollapsible.style.height = <span class="hljs-string">&#x27;0px&#x27;</span>;
    }
    myCollapsible.state.collapsed = !myCollapsible.state.collapsed;
};</code></pre></li>
<li><p><strong>Element.prototype.setState(state[, params]): Void</strong> - This method provides a programmatic way to set data on an element's <code>.state</code> property. It lets us set multiple properties in a call, and gives us control over state mutation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: Object</code> - The object to set as state or whose properties to update existing state with.</li>
<li><code>params: Object</code> - (Optional) Parameters for controlling state mutation:<ul>
<li><code>update: Boolean</code> - Specifies whether to simply update properties of existing state or to establish the given object as new state. Default: <code>false</code> - establish object as new state.</li></ul></li></ul>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set object as state</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Update existing state object</span>
myCollapsible.setState({
    <span class="hljs-attr">inView</span>: <span class="hljs-literal">true</span>,
}, {<span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// false</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ----------</span>

<span class="hljs-comment">// Set new state object</span>
myCollapsible.setState({
    <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Access properties</span>
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView; <span class="hljs-comment">// undefined</span></code></pre></li>
<li><p><strong>Element.prototype.clearState(): Void</strong> - This method provides a programmatic way to clear existing data from an element's state object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Clear existing data</span>
myCollapsible.clearState();</code></pre></li>
</ul>
<h2 id="state-observability">State Observability</h2>
<p>State objects are a special kind of objects in that they support <em>observability</em>. The <code>document.state</code> property and the <code>Element.prototype.state</code> property are implemented as <em>live objects</em> that can be observed for property changes using the <a href="/tooling/oohtml/docs/spec/the-observer-api">Observer API</a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer API and use the Observer.observe() method</span>
Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
    });
});</code></pre>
<p>We could as well specify just the path to observe on the function's second parameter.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-string">&#x27;pageTitle&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
});</code></pre>
<p>With the code above, adding or updating the <code>pageTitle</code> property on the document's state object would be reported in the console.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.state.pageTitle = <span class="hljs-string">&#x27;Bonjour!&#x27;</span>;</code></pre>
<p>Deleting this property would trigger our observer in the same way.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">delete</span> <span class="hljs-built_in">document</span>.state.pageTitle;</code></pre>
<p>To observe changes down the state tree, we would set the observer's <code>params.subtree</code> to <code>true</code>.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path<span class="hljs-comment">/*watch this*/</span>, e.value);
    });
}, {<span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>We could as well specify just the path to observe.</p>
<pre><code class="hljs js language-js">Observer.observe(<span class="hljs-built_in">document</span>.state, [<span class="hljs-string">&#x27;pageContent&#x27;</span>, <span class="hljs-string">&#x27;aside&#x27;</span>], <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(e.type, e.name, e.path, e.value);
});</code></pre>
<p>With the code above, mutating a nested property would trigger the observer.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// State object</span>
<span class="hljs-keyword">let</span> data = {
    <span class="hljs-attr">pageTitle</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,
    <span class="hljs-attr">pageContent</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;Thanks for visiting.&#x27;</span>,
        <span class="hljs-attr">aside</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    },
};
<span class="hljs-built_in">document</span>.setState(data);

<span class="hljs-comment">// Mutate pageContent afterwards...</span>
Observer.set(data.pageContent, <span class="hljs-string">&#x27;aside&#x27;</span>, <span class="hljs-string">&#x27;Related content...&#x27;</span>);</code></pre>
<h3 id="a-custom-element-example">A Custom Element Example</h3>
<p>The following example demonstrates state observability in a custom element. Our logic below helps keep the UI and application state in sync. Noteworthy is that we are reflecting the <code>collapsed</code> state in the <code>data-collapsed</code> attribute and keeping a part of that state - <code>content</code> - <em>bound</em> to a descendant element.</p>
<pre><code class="hljs js language-js">customElements.define(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

    <span class="hljs-comment">/**
     * Creates the Shadow DOM
     */</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-keyword">let</span> contentElement = <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.content&#x27;</span>);

        <span class="hljs-comment">// Observe state and get the UI synced</span>
        Observer.observe(<span class="hljs-built_in">this</span>.state, <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
            events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
                <span class="hljs-keyword">switch</span>(event.name) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;collapsed&#x27;</span>:
                        <span class="hljs-built_in">this</span>.style.height = event.value ? <span class="hljs-string">&#x27;0px&#x27;</span> : <span class="hljs-string">&#x27;auto&#x27;</span>;
                        <span class="hljs-built_in">this</span>.setAttribute(<span class="hljs-string">&#x27;data-active&#x27;</span>, event.value ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>);
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;inView&#x27;</span>:
                        <span class="hljs-built_in">this</span>.style.animation = event.value ? <span class="hljs-string">&#x27;fadein 440ms&#x27;</span> : <span class="hljs-string">&#x27;fadeout 440ms&#x27;</span>;
                    <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;content&#x27;</span>:
                        contentElement.setState(event.value);
                    <span class="hljs-keyword">break</span>;
                }
            });
        });

        <span class="hljs-comment">// Implement the logic for toggling collapsion</span>
        <span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            <span class="hljs-built_in">this</span>.state.collapsed = !<span class="hljs-built_in">this</span>.state.collapsed;
        });

        <span class="hljs-comment">// Implement the logic for detecting when in view</span>
        <span class="hljs-keyword">let</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">entries</span>) </span>{
            <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].isIntersecting) {
                <span class="hljs-built_in">this</span>.state.inView = entries[<span class="hljs-number">0</span>].intersectionRatio;
            }
        });
        io.observe(<span class="hljs-built_in">this</span>);
    }

});</code></pre>
<p>External code gets a standard way to infer the state of the <code>&lt;my-collapsible&gt;</code> element.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> myCollapsible = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;my-collapsible&#x27;</span>);
<span class="hljs-keyword">let</span> isCollapsed = myCollapsible.state.collapsed;
<span class="hljs-keyword">let</span> inView = myCollapsible.state.inView;</code></pre>
<p>External code gets a standard way to control state.</p>
<pre><code class="hljs js language-js">myCollapsible.state.collapsed = <span class="hljs-literal">true</span>;</code></pre>
<h2 id="polyfill-support">Polyfill Support</h2>
<p>The current <a href="/tooling/oohtml/docs/getting-started/polyfill">OOHTML polyfill implementation</a> has full support for The State API. The polyfill additionally makes it possible to customise following areas of its implementation of the API using the <a href="/tooling/oohtml/docs/resources/meta-tag">OOHTML META tag</a>:</p>
<ul>
<li><p><strong><a href="#api">api.state</a></strong> - The property name for exposing the <em>state object</em> on DOM elements and the document object. The standard property name is <code>state</code>, but you may use a custom property name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.state=stateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js">myCollapsible.stateObject.collapsed = <span class="hljs-literal">true</span>;</code></pre></li>
<li><p><strong><a href="#api">api.setState</a></strong> - The <em>method name</em> for setting data on <em>state objects</em>. The standard <em>method name</em> is <code>setState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.setState=setStateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.setStateObject(data);</code></pre></li>
<li><p><strong><a href="#api">api.clearState</a></strong> - The <em>method name</em> for clearing data from <em>state objects</em>. The standard <em>method name</em> is <code>clearState</code>, but you may use a custom method name, where necessary.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;oohtml&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;api.clearState=clearStateObject;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">document</span>.clearStateObject();</code></pre></li>
</ul>
<p>Learn more about customization and the OOHTML meta tag <a href="/tooling/oohtml/docs/resources/meta-tag">here</a>.</p>

				</div>
			</template>
		</template>
	</template>

	
