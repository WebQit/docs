
	<div exportgroup="readme">

		<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/observer" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/observer.svg" alt="NPM version" /></a></span> <span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/observer" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/observer.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<h2 id="a-utility-first-reactivity-api">A Utility-First Reactivity API</h2>
<p>Observe and intercept operations on any type of JavaScript objects and arrays, using a uniquely  web-native API! The Observer API is notably lightweight, completely transparent and synchronous, but magical!</p>
<h2 id="getting-started">Getting Started</h2>
<p><a href="/tooling/observer/docs">Visit the docs</a> for an overview, the API and usage guides.</p>
<p><html-import data-id="quickstart" template="@layout/quickstart"></html-import></p>
<p>Also, <a href="https://github.com/webqit/observer/discussions">join the Github Discussions</a> for Observer.</p>
<h2 id="contributing-to-the-project">Contributing to the Project</h2>
<p>Help report bugs, or request features; or join in the development.</p>
<ul>
<li><a href="https://github.com/webqit/observer">Visit this project on github</a>.</li>
<li><a href="https://github.com/webqit/webqit-tooling.docs/edit/master/observer/docs">Contribute to the docs on github</a>.</li>
</ul>
<h2 id="license">License</h2>
<p>The MIT license.</p>

	</div>

	

	<template name="docs">
		<div exportgroup="readme">

			<h1 id="the-observer-api-docs">The Observer API Docs</h1>
<p>Welcome to the Observer API documentation. We hope you find it easy to understand and navigate.</p>
<p>If you have questions about anything related to the Observer API, you're always welcome to ask on our <a href="https://github.com/webqit/observer/discussions">GitHub Discussions</a>.</p>
<h2 id="explore-the-docs">Explore the Docs</h2>

		</div>

		<template name="api">
			<div exportgroup="readme">

				<h1 id="api-reference">API Reference</h1>
<p>Explore the API Reference.</p>

			</div>

			<template name="core">
				<template name="OperatorParams">
					<div exportgroup="readme">

						<h1 id="operatorparams"><code>OperatorParams</code></h1>
<p>This is an object of additional parameters that may be passed with any <em>operator</em>; e.g. <code>Observer.set()</code>,  <code>Observer.deleteProperty()</code>, etc.</p>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>detail:   Any</code></strong> - An optional value to pass to observers. <em>See <a href="#passing-a-value-to-observers">Passing a Value to Observers</a> below.</em></li>
<li><strong><code>responseObject:   Boolean</code></strong> - Whether to return the <em>responseObject</em> for the operation. <em>See the section <a href="/tooling/observer/docs/api/subscribers/observe#returning-responses-back-to-operators">Returning Responses Back to Operators</a> at <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</em></li>
<li><strong><code>cancellable:      Boolean</code></strong> - Whether the default taken after this operation is cancellable by observers. <em>See the section <a href="/tooling/observer/docs/api/subscribers/observe#returning-responses-back-to-operators">Returning Responses Back to Operators</a> at <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</em></li>
</ul>
<h2 id="passing-a-value-to-observers">Passing a Value to Observers</h2>
<p>The <code>params.detail</code> property can be used to pass a value specifically to observers that might be responding to an operation like the <em>deleteProperty</em> operation. Any type of value can be passed.</p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">detail</span>: <span class="hljs-string">&#x27;This is observer-specific detail&#x27;</span>,
});</code></pre>
<p>The <em>detail</em> above would now be available to every observer.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>

					</div>
				</template>

				<div exportgroup="readme">

					<h1 id="core">Core</h1>

				</div>

				<template name="getobservers">
					<div exportgroup="readme">

						<h1 id="observergetobservers"><code>Observer.getObservers)</code></h1>
<p>This function is used to obtain an object's internal observers list - an <code>ObserversList</code> instance. The returned <code>ObserversList</code> instance could then be programatically fired with some custom events.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj, createIfNotExists = <span class="hljs-literal">true</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:                 Object|Array</code> - an object or array.</li>
<li><code>createIfNotExists:   Boolean</code> - when <em>true</em>, creates an empty list when no observers exist on the object.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>ObserversList</code> - when observers exist on the object.</li>
<li><code>undefined</code> - when no observers exist on the object and the <code>createIfNotExists</code> parameter is false.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The object</span>
<span class="hljs-keyword">let</span> obj = {};

<span class="hljs-comment">// We observe the &#x27;someProperty&#x27;</span>
Observer.observe(obj, <span class="hljs-string">&#x27;someProperty&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});

<span class="hljs-comment">// Get observers list</span>
<span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj);

<span class="hljs-comment">// Programatically fire some custom events</span>
observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});</code></pre>
<h3 id="returning-responses-back-from-firing-observers">Returning Responses Back from Firing Observers</h3>
<p>When an event is fired, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the event to skip the <em>default action</em> that it takes, if any, after firing the given event. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the event to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function">() =&gt;</span> {
    });
}</code></pre>

					</div>
				</template>
			</template>

			<template name="hierarchy">
				<div exportgroup="readme">

					<h1 id="hierarchy">Hierarchy</h1>

				</div>

				<template name="build">
					<div exportgroup="readme">

						<h1 id="getobservers"><code>.getObservers)</code></h1>
<p>This function is used to obtain an object's internal observers list - an <code>ObserversList</code> instance. The returned <code>ObserversList</code> instance could then be programatically fired with some custom events.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj, createIfNotExists = <span class="hljs-literal">true</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:                 Object|Array</code> - an object or array.</li>
<li><code>createIfNotExists:   Boolean</code> - when <em>true</em>, creates an empty list when no observers exist on the object.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>ObserversList</code> - when observers exist on the object.</li>
<li><code>undefined</code> - when no observers exist on the object and the <code>createIfNotExists</code> parameter is false.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The object</span>
<span class="hljs-keyword">let</span> obj = {};

<span class="hljs-comment">// We observe the &#x27;someProperty&#x27;</span>
Observer.observe(obj, <span class="hljs-string">&#x27;someProperty&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});

<span class="hljs-comment">// Get observers list</span>
<span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj);

<span class="hljs-comment">// Programatically fire some custom events</span>
observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});</code></pre>
<h3 id="returning-responses-back-from-firing-observers">Returning Responses Back from Firing Observers</h3>
<p>When an event is fired, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the event to skip the <em>default action</em> that it takes, if any, after firing the given event. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the event to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function">() =&gt;</span> {
    });
}</code></pre>

					</div>
				</template>

				<template name="link">
					<div exportgroup="readme">

						<h1 id="observergetobservers"><code>Observer.getObservers)</code></h1>
<p>This function is used to obtain an object's internal observers list - an <code>ObserversList</code> instance. The returned <code>ObserversList</code> instance could then be programatically fired with some custom events.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj, createIfNotExists = <span class="hljs-literal">true</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:                 Object|Array</code> - an object or array.</li>
<li><code>createIfNotExists:   Boolean</code> - when <em>true</em>, creates an empty list when no observers exist on the object.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>ObserversList</code> - when observers exist on the object.</li>
<li><code>undefined</code> - when no observers exist on the object and the <code>createIfNotExists</code> parameter is false.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The object</span>
<span class="hljs-keyword">let</span> obj = {};

<span class="hljs-comment">// We observe the &#x27;someProperty&#x27;</span>
Observer.observe(obj, <span class="hljs-string">&#x27;someProperty&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});

<span class="hljs-comment">// Get observers list</span>
<span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj);

<span class="hljs-comment">// Programatically fire some custom events</span>
observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});</code></pre>
<h3 id="returning-responses-back-from-firing-observers">Returning Responses Back from Firing Observers</h3>
<p>When an event is fired, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the event to skip the <em>default action</em> that it takes, if any, after firing the given event. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the event to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function">() =&gt;</span> {
    });
}</code></pre>

					</div>
				</template>

				<template name="unlink">
					<div exportgroup="readme">

						<h1 id="observergetobservers"><code>Observer.getObservers)</code></h1>
<p>This function is used to obtain an object's internal observers list - an <code>ObserversList</code> instance. The returned <code>ObserversList</code> instance could then be programatically fired with some custom events.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj, createIfNotExists = <span class="hljs-literal">true</span>);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:                 Object|Array</code> - an object or array.</li>
<li><code>createIfNotExists:   Boolean</code> - when <em>true</em>, creates an empty list when no observers exist on the object.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>ObserversList</code> - when observers exist on the object.</li>
<li><code>undefined</code> - when no observers exist on the object and the <code>createIfNotExists</code> parameter is false.</li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The object</span>
<span class="hljs-keyword">let</span> obj = {};

<span class="hljs-comment">// We observe the &#x27;someProperty&#x27;</span>
Observer.observe(obj, <span class="hljs-string">&#x27;someProperty&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});

<span class="hljs-comment">// Get observers list</span>
<span class="hljs-keyword">let</span> observersList = Observer.getObservers(obj);

<span class="hljs-comment">// Programatically fire some custom events</span>
observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});</code></pre>
<h3 id="returning-responses-back-from-firing-observers">Returning Responses Back from Firing Observers</h3>
<p>When an event is fired, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the event to skip the <em>default action</em> that it takes, if any, after firing the given event. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> cancellable = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,}, cancellable);
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the event to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, response</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the event may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = observersList.fire({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;customEvent&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;someProperty&#x27;</span>,});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function">() =&gt;</span> {
    });
}</code></pre>

					</div>
				</template>
			</template>

			<template name="operators">
				<div exportgroup="readme">

					<h1 id="operators">Operators</h1>

				</div>

				<template name="accessorize">
					<div exportgroup="readme">

						<h1 id="accessorize"><code>.accessorize()</code></h1>
<p>This function is used to create property <em>setters</em> and <em>getters</em> on that use <code>Observer.set()</code> and <code>Observer.get()</code> respectively behind the scene. This gives us the benefit of using JavaScript's assignment and accessor syntax reactively.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Accessorize a single property</span>
<span class="hljs-keyword">let</span> successFlag = Observer.accessorize(obj, propertyName[, params = {}]);

<span class="hljs-comment">// Accessorize multiple properties</span>
<span class="hljs-keyword">let</span> successFlags = Observer.accessorize(obj, [ propertyName, ... ][, params = {}]);

<span class="hljs-comment">// Accessorize all existing properties</span>
<span class="hljs-keyword">let</span> successFlags = Observer.accessorize(obj[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:    String</code></strong> - The property to <em>accessorize</em>.</li>
<li><strong><code>params:          Object</code></strong> - Additional parameters for the method.<ul>
<li><strong><code>configurable:          Boolean</code></strong> - Whether the property should be defined with a <em>configurable</em> flag. Defaults to <code>true</code>. Set to <code>false</code> to prevent the property from being deleted or reconfigured.</li></ul></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>successFlag:     Boolean</code></strong> - A flag that tells whether or not the given property was successfully accessorized.</li>
<li><strong><code>successFlags:     Array</code></strong> - A list of flags for each property that tells whether or not the property was successfully accessorized.</li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>An observer:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// We observe the &#x27;preferences&#x27; property</span>
Observer.observe(obj, <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
});</code></pre>
<p><em>Case 1 - Accessorize a property - on an empty object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};</code></pre>
<p><em>The accessorize method:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Now we accessorize this property</span>
Observer.accessorize(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>);</code></pre>
<p>Now, assigning something to the property will fire our observer.</p>
<pre><code class="hljs js language-js">obj.preferences = {};</code></pre>
<p><em>Case 2 - Accessorize all existing properties - on an object with existing properties:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>: <span class="hljs-string">&#x27;Mango&#x27;</span>,
    <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>,
};</code></pre>
<p><em>The accessorize method:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Now we accessorize this property</span>
Observer.accessorize(obj);</code></pre>
<p>Now, assigning something to any of the properties will fire our observer.</p>
<pre><code class="hljs js language-js">obj.fruit = <span class="hljs-string">&#x27;Orange&#x27;</span>;</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/operators/unaccessorize"><code>Observer.unaccessorize()</code></a></li>
</ul>

					</div>
				</template>

				<template name="defineproperty">
					<div exportgroup="readme">

						<h1 id="defineproperty"><code>.defineProperty()</code></h1>
<p>This method is used to reactively define a property on an object or array or reconfigures an existing property. It corresponds to the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty"><code>Reflect.defineProperty()</code></a>. <code>Observer.defineProperty()</code> offers reactivity over this operation.</p>
<p>The <code>Observer.def()</code> function is an alias of this function and can be used interchangeably.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Define a property</span>
Observer.defineProperty(obj, propertyName, propertyDescriptor[, params = {}]);

<span class="hljs-comment">// Define a list of properties</span>
Observer.defineProperty(obj, [ propertyName, ... ], propertyDescriptor[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:                 Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:        String</code></strong> - The property to define. If multiple, all listed properties will be defined with the same <em>propertyDescriptor</em>.</li>
<li><strong><code>propertyDescriptor:  Object</code></strong> - The property descriptor as specified for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty"><code>Reflect.defineProperty()</code></a>.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. *See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong>Boolean</strong> - This is either <code>true</code> or <code>false</code> on the outcome of the operation.</li>
<li><strong>Response</strong> - The returned <a href="/tooling/observer/docs/core/Response">Response</a> object for the operation, where the <code>params.responseObject</code> is set to <code>true</code>. <em>See the section <a href="/tooling/observer/docs/api/subscribers/observe#returning-responses-back-to-operators">Returning Responses Back to Operators</a> at <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</em></li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>Case 1 - Define a specific property:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.defineProperty(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, { <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;orange&#x27;</span> });</code></pre>
<p><em>Case 2 - Define a list of properties:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.defineProperty(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ], { <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;orange&#x27;</span> });</code></pre>
<h2 id="usage-as-a-traps-defineproperty-handler">Usage as a Trap's defineProperty Handler</h2>
<p><code>Observer.defineProperty()</code> returns a <em>Boolean</em> value by default, and can, therefore, be used as the "defineProperty" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">defineProperty</span>: Observer.defineProperty});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">defineProperty</span>: Observer.defineProperty});</code></pre>
<p><em>Define</em> operations will now be forwarded to <code>Observer.defineProperty()</code>, triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> and <a href="/tooling/observer/docs/core/overview/observers"><em>observers</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">Reflect</span>.defineProperty(_obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, { <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;apple&#x27;</span> });</code></pre>
<h2 id="intercepting-observerdefineproperty">Intercepting <code>Observer.defineProperty()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.defineProperty()</code>. During a "defineProperty" operation, interceptors will receive an event object containing the property name being defined and the descriptor object.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.descriptor);

    <span class="hljs-comment">// Reconfigure the descriptor that the next</span>
    <span class="hljs-comment">// interceptor (or the default handler) sees</span>
    <span class="hljs-keyword">let</span> _descriptor = { ...event.descriptor };
    <span class="hljs-keyword">if</span> (_descriptor.configurable === <span class="hljs-literal">true</span>) {
        _descriptor.configurable = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> next(_descriptor);
});</code></pre>
<pre><code class="hljs js language-js">Observer.defineProperty(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, {
    <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
});</code></pre>
<p>The interceptor is expected to return <em>true</em> if the custom operation was successful; <em>false</em> otherwise.</p>
<p>When the "defineProperty" operation is of multiple properties, the interceptor gets fired for each property while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.related);

    <span class="hljs-comment">// Just forward the operation</span>
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ], { <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;apple&#x27;</span> });</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>['fruit', 'brand']</code> each time.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="deleteproperty">
					<div exportgroup="readme">

						<h1 id="deleteproperty"><code>.deleteProperty()</code></h1>
<p>This method is used to reactively delete a property from an object. It corresponds to the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty"><code>Reflect.deleteProperty()</code></a> function, which is itself the programmatic alternative to the <code>delete</code> keyword â€“ <code>delete object.property</code>. <code>Observer.deleteProperty()</code> offers reactivity over this operation.</p>
<p>The <code>Observer.del()</code> function is an alias of this function and can be used interchangeably.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Delete a specific property</span>
Observer.deleteProperty(obj, propertyName[, params = {}]);

<span class="hljs-comment">// Delete a list of properties</span>
Observer.deleteProperty(obj, [ propertyName, ... ][, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:                 Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:        String</code></strong> - The property to delete.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. *See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong>Boolean</strong> - This is either <code>true</code> or <code>false</code> on the outcome of the operation.</li>
<li><strong>Response</strong> - The returned <a href="/tooling/observer/docs/core/Response">Response</a> object for the operation, where the <code>params.responseObject</code> is set to <code>true</code>. <em>See the section <a href="/tooling/observer/docs/api/subscribers/observe#returning-responses-back-to-operators">Returning Responses Back to Operators</a> at <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</em></li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>Case 1 - Delete a specific property:</em></p>
<p><em>On an object:</em></p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<p><em>On an array:</em></p>
<pre><code class="hljs js language-js">Observer.deleteProperty(arr, <span class="hljs-number">0</span>);</code></pre>
<p><em>Case 2 - Delete a list of properties:</em></p>
<p><em>On an object:</em></p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ]);</code></pre>
<p><em>On an array:</em></p>
<pre><code class="hljs js language-js">Observer.deleteProperty(arr, [ <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ]);</code></pre>
<h2 id="usage-as-a-traps-deleteproperty-handler">Usage as a Trap's "deleteProperty" Handler</h2>
<p><code>Observer.deleteProperty()</code> returns a <em>Boolean</em> value by default, and can, therefore, be used as the "deleteProperty" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">deleteProperty</span>: Observer.deleteProperty});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">deleteProperty</span>: Observer.deleteProperty});</code></pre>
<p>Delete operations will now be forwarded to <code>Observer.deleteProperty()</code>, triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> and <a href="/tooling/observer/docs/core/overview/observers"><em>observers</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">delete</span> _obj.fruit;
<span class="hljs-keyword">delete</span> _arr[<span class="hljs-number">2</span>];</code></pre>
<h2 id="intercepting-observerdeleteproperty">Intercepting <code>Observer.deleteProperty()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.deleteProperty()</code>. During a "deleteProperty" operation, interceptors will receive an event object containing the property name being deleted.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);

    <span class="hljs-comment">// We can actually prevent the deletion of the property</span>

    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});</code></pre>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<p>The interceptor is expected to return <em>true</em> if the custom operation was successful; <em>false</em> otherwise.</p>
<p>When the "deleteProperty" operation is of multiple properties, the interceptor gets fired for each property while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, recieved, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.related);

    <span class="hljs-comment">// The delete operation</span>
    <span class="hljs-keyword">delete</span> obj[event.name];

    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});</code></pre>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ]);</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>['fruit', 'brand']</code> in each case.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="get">
					<div exportgroup="readme">

						<h1 id="get"><code>.get()</code></h1>
<p>This method is used to return the value of a property. It corresponds to the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get"><code>Reflect.get()</code></a> function, which is itself the programmatic alternative to the object accessor syntax â€“ <code>obj.property; obj[property]</code>. <code>Observer.get()</code> offers reactivity over this operation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Read a specific property.</span>
<span class="hljs-comment">// The return value will be the value of the property</span>
<span class="hljs-keyword">var</span> value = Observer.get(obj, propertyName[, params = {}]);

<span class="hljs-comment">// Read a list of properties</span>
<span class="hljs-comment">// The return value will be a key/value map of the listed properties</span>
<span class="hljs-keyword">var</span> values = Observer.get(obj, [ propertyName, ... ][, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:    String</code></strong> - The property to read.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.get()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>value:   Any</code></strong> - The value of the property.</li>
<li><strong><code>values:  Object</code></strong> - A key/value map of the listed properties in the second syntax above.</li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>Case 1 - read a specific property:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
};</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> fruit = Observer.get(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<p><em>Case 2 - Read a list of properties:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
};</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> fruits = Observer.get(obj, [<span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span>]);</code></pre>
<h2 id="usage-as-a-traps-get-handler">Usage as a Trap's "get" Handler</h2>
<p><code>Observer.get()</code> can be used as the "get" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, { <span class="hljs-attr">get</span>: Observer.get });
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, { <span class="hljs-attr">get</span>: Observer.get });</code></pre>
<p><em>Get</em> operations will now be forwarded to <code>Observer.get()</code>, triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> fruit = _obj.fruit;
<span class="hljs-keyword">let</span> value = _arr[<span class="hljs-number">2</span>];</code></pre>
<h2 id="usage-with-property-getters">Usage with Property Getters</h2>
<p>It is possible to implement <em>property getters</em> that use <code>Observer.get()</code> behind the scene. This gives us the benefit of using JavaScript's accessor syntax reactively.</p>
<p>This is automatically done by the <a href="/tooling/observer/docs/api/operators/accessorize"><code>Observer.accessorize()</code></a> function.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize a property or multiple properties</span>
Observer.accessorize(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);
Observer.accessorize(obj, [<span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span>]);</code></pre>
<p>Now accessing the properties will trigger any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Now we can do without Observer.get</span>
<span class="hljs-keyword">let</span> fruit = obj.fruit;
<span class="hljs-keyword">let</span> brand = obj.brand;</code></pre>
<h2 id="intercepting-observerget">Intercepting <code>Observer.get()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.get()</code>. During a "deleteProperty" operation, interceptors will receive an event object containing the property name being accessed.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);

    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> obj[event.name];
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> value = Observer.get(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<p>When the "get" operation is of multiple properties, the interceptor gets fired for each property while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.related);

    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> obj[event.name];
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> values = Observer.get(obj, [<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>]);</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>[ 'fruit', 'brand' ]</code> each time.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="has">
					<div exportgroup="readme">

						<h1 id="has"><code>.has()</code></h1>
<p>This method is used to test property presence. It corresponds to the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has"><code>Reflect.has()</code></a> function, which is itself the programmatic alternative to the JavaScript <em>in</em> operator â€“ <code>property in obj</code>. <code>Observer.has()</code> offers reactivity over this operation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Test the presence of a property.</span>
<span class="hljs-keyword">let</span> exists = Observer.has(obj, propertyName[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:    String</code></strong> - The property to assert.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.has()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong>`exists:          Boolean</strong></li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>An object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
};</code></pre>
<p><em>The assertion:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> exists = Observer.has(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<h2 id="usage-as-a-traps-has-handler">Usage as a Trap's "has" Handler</h2>
<p><code>Observer.has()</code> can be used as the "has" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, { <span class="hljs-attr">has</span>: Observer.has });
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, { <span class="hljs-attr">has</span>: Observer.has });</code></pre>
<p><em>Has</em> operations will now be forwarded to <code>Observer.has()</code>, triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> exists = <span class="hljs-string">&#x27;fruit&#x27;</span> <span class="hljs-keyword">in</span> _obj;
<span class="hljs-keyword">let</span> exists = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> _arr;</code></pre>
<h2 id="intercepting-observerhas">Intercepting <code>Observer.has()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.has()</code>. During a "has" operation, interceptors will receive an event object containing the property name being asserted.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;has&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);

    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> event.name <span class="hljs-keyword">in</span> obj;
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> exists = Observer.has(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="ownkeys">
					<div exportgroup="readme">

						<h1 id="ownkeys"><code>.ownKeys()</code></h1>
<p>This method is used to get an object's list of direct properties. It corresponds to the JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys"><code>Reflect.ownKeys()</code></a> function. <code>Observer.ownKeys()</code> offers reactivity over this operation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Show all keys.</span>
<span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - an object or array.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.ownKeys()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>keys:            Array</code></strong></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
};</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj);</code></pre>
<h2 id="usage-as-a-traps-ownkeys-handler">Usage as a Trap's "ownKeys" Handler</h2>
<p><code>Observer.ownKeys()</code> can be used as the "ownKeys" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, { <span class="hljs-attr">ownKeys</span>: Observer.ownKeys });
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, { <span class="hljs-attr">ownKeys</span>: Observer.ownKeys });</code></pre>
<p><em>Show keys</em> operations will now be forwarded to <code>Observer.ownKeys()</code> , triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(_obj);
<span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(_arr);</code></pre>
<h2 id="intercepting-observerownkeys">Intercepting <code>Observer.ownKeys()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.ownKeys()</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;keys&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj);
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="proxy">
					<div exportgroup="readme">

						<h1 id="proxy"><code>.proxy()</code></h1>
<p>This function is used to wrap an object or array in a reactive proxy that forwards all operations to the appropriate <a href="/tooling/observer/docs/api/subscribers/interceptors"><em>interceptors</em></a>, and announces them to <a href="/tooling/observer/docs/api/subscribers/observe"><em>observers</em></a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Wrap an object</span>
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - an object or array.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.proxy()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>_obj:            Proxy</code></strong></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The observed object/array</span>
<span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The proxy</span>
Observer.proxy(arr).push(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>);</code></pre>
<p>The above operation above will notify our observer <em>three times</em> each for a <em>set</em> operation on the properties <code>0</code>, <code>1</code>, <code>length</code>.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/operators/unproxy"><code>Observer.unproxy()</code></a></li>
<li><a href="/tooling/observer/docs/api/operators/accessorize"><code>Observer.accessorize()</code></a></li>
</ul>

					</div>
				</template>

				<template name="set">
					<div exportgroup="readme">

						<h1 id="set"><code>.set()</code></h1>
<p>This method is used to reactively set the value of an object's property. It corresponds to the JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set"><code>Reflect.set()</code></a> function, which is itself the programmatic alternative to the assignment expression â€“ <code>object.property = value</code>. <code>Observer.set()</code> offers reactivity over this operation.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set or modify a specific property</span>
Observer.set(obj, propertyName, value[, params = {}]);

<span class="hljs-comment">// Set or modify a list of properties with the same value</span>
Observer.set(obj, propertyNames, value[, params = {}]);

<span class="hljs-comment">// Perform multiple key/value assignments</span>
Observer.set(obj, keyValueMap[, = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - An object or array.</li>
<li><strong><code>propertyName:    String|Number</code></strong> - The property to create or update.</li>
<li><strong><code>propertyNames:   Array</code></strong> - A list of properties to create or update. <em>These will be assigned the same value.</em></li>
<li><strong><code>value:           Any</code></strong> - The value to set.</li>
<li><strong><code>keyValueMap:     Object</code></strong> - An object of key/value pairs.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. *See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong>Boolean</strong> - This is either <code>true</code> or <code>false</code> on the outcome of the operation.</li>
<li><strong>Response</strong> - The returned <a href="/tooling/observer/docs/core/Response">Response</a> object for the operation, where the <code>params.responseObject</code> is set to <code>true</code>. <em>See the section <a href="/tooling/observer/docs/api/subscribers/observe#returning-responses-back-to-operators">Returning Responses Back to Operators</a> at <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</em></li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>Case 1 - Setting a specific property:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an array</span>
Observer.set(arr, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;orange&#x27;</span>);</code></pre>
<p><em>Case 2 - Setting multiple properties:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>
});</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an array</span>
<span class="hljs-comment">// Provide key/value as an object</span>
Observer.set(arr, {
    <span class="hljs-number">0</span>:<span class="hljs-string">&#x27;apple&#x27;</span>,
    <span class="hljs-number">3</span>:<span class="hljs-string">&#x27;apple&#x27;</span>
});</code></pre>
<p><em>Case 3 - Setting multiple properties - with a shared value:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ], <span class="hljs-string">&#x27;apple&#x27;</span>);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an array</span>
Observer.set(arr, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&#x27;apple&#x27;</span>);</code></pre>
<h2 id="usage-as-a-traps-set-handler">Usage as a Trap's "set" Handler</h2>
<p><code>Observer.set()</code> returns a <em>Boolean</em> value for <em>set</em> operations and can, therefore, be used as the "set" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">set</span>: Observer.set});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">set</span>: Observer.set});</code></pre>
<p>Assignment operations will now be forwarded to <code>Observer.set()</code> and triggering any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> and <a href="/tooling/observer/docs/core/overview/observers"><em>observers</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js">_obj.fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;
_arr[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;Item 3&#x27;</span>;</code></pre>
<h2 id="usage-with-property-setters">Usage with Property Setters</h2>
<p>It is possible to implement <em>property setters</em> that use <code>Observer.set()</code> behind the scene. This gives us the benefit of using JavaScript's assignment syntax reactively.</p>
<p>This is automatically done by the <a href="/tooling/observer/docs/api/operators/accessorize"><code>Observer.accessorize()</code></a> method.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize a property or multiple properties</span>
Observer.accessorize(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>);
Observer.accessorize(obj, [ <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;brand&#x27;</span> ]);</code></pre>
<p>Now assigning on the properties will trigger any <a href="/tooling/observer/docs/core/overview/interceptors"><em>interceptors</em></a> and <a href="/tooling/observer/docs/core/overview/observers"><em>observers</em></a> that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Now we can do without Observer.set</span>
obj.fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;
obj.brand = <span class="hljs-string">&#x27;apple&#x27;</span>;</code></pre>
<h2 id="intercepting-observerset">Intercepting <code>Observer.set()</code></h2>
<p>Using <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.set()</code>. During a "set" operation, interceptors will receive an event object containing the property name being set and the assignable value.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.value);

    <span class="hljs-comment">// The assignment operation</span>
    obj[event.name] = event.value;

    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});</code></pre>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>);</code></pre>
<p>The interceptor is expected to return <em>true</em> if the custom operation was successful; <em>false</em> otherwise.</p>
<p>When the "set" operation is of multiple key/value assignments, an interceptor will get fired for each pair while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {

    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.value, event.related);

    <span class="hljs-comment">// The assignment operation</span>
    obj[event.name] = event.value;

    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});</code></pre>
<pre><code class="hljs js language-js">Observer.set(obj, {<span class="hljs-attr">fruit</span>: <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-attr">brand</span>:<span class="hljs-string">&#x27;apple&#x27;</span>});</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>[ 'fruit', 'brand' ]</code> each time.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="unaccessorize">
					<div exportgroup="readme">

						<h1 id="unaccessorize"><code>.unaccessorize()</code></h1>
<p>This function is used to restore an object's accessorized properties to their original state.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unaccessorize a single property</span>
<span class="hljs-keyword">let</span> successFlag = Observer.unaccessorize(obj, propertyname[, params = {}]);

<span class="hljs-comment">// Unaccessorize multiple properties</span>
<span class="hljs-keyword">let</span> successFlags = Observer.unaccessorize(obj, [propertyname, ...][, params = {}]);

<span class="hljs-comment">// Unaccessorize all previously accessorized properties</span>
<span class="hljs-keyword">let</span> successFlags = Observer.unaccessorize(obj[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - an object or array.</li>
<li><strong><code>propertyName:    String</code></strong> - the property to <em>unaccessorize</em>.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.unaccessorize()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>successFlag:     Boolean</code></strong> - A flag that tells whether or not the given property was successfully unaccessorized.</li>
<li><strong><code>successFlags:     Array</code></strong> - A list of flags for each property that tells whether or not the property was successfully unaccessorized.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Unaccessorizing an initially accessorized property.</p>
<p><em>An observer:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
});</code></pre>
<p><em>Accessorizing the property:</em></p>
<pre><code class="hljs js language-js">Observer.accessorize(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>);</code></pre>
<p><em>Assigning something to the property with reactivity:</em></p>
<pre><code class="hljs js language-js">obj.preferences = {};</code></pre>
<p><em>Unaccessorizing the property:</em></p>
<pre><code class="hljs js language-js">Observer.unaccessorize(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>);</code></pre>
<p><em>Now, zero reactivity on further assignments:</em></p>
<pre><code class="hljs js language-js">obj.preferences = {};</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/operators/accessorize"><code>Observer.accessorize()</code></a></li>
</ul>

					</div>
				</template>

				<template name="unproxy">
					<div exportgroup="readme">

						<h1 id="unproxy"><code>.unproxy()</code></h1>
<p>This function is used to obtain the original object or array previously wrapped in a reactive proxy using <a href="/tooling/observer/docs/api/operators/proxy"><code>Observer.proxy()</code></a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unwrap an object</span>
<span class="hljs-keyword">let</span> obj = Observer.unproxy(_obj[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>_obj: Proxy</code></strong> - a Proxy object generated by <a href="/tooling/observer/docs/api/operators/proxy"><code>Observer.proxy()</code></a>.</li>
<li><strong><code>params:          OperatorParams</code></strong> - Additional parameters for the operation. <em>See <a href="/tooling/observer/docs/api/core/OperatorParams">OperatorParams</a>. Note that the <code>params.responseObject</code> parameter cannot be used with <code>Observer.unproxy()</code>.</em></li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>obj: Object|Array</code></strong></li>
</ul>
<h2 id="usage">Usage</h2>
<p><em>A proxied object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj);</code></pre>
<p><em>Obtaining the original object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = Observer.unproxy(_obj);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/operators/proxy"><code>Observer.proxy()</code></a></li>
</ul>

					</div>
				</template>
			</template>

			<template name="subscribers">
				<div exportgroup="readme">

					<h1 id="subscribers">Subscribers</h1>

				</div>

				<template name="closure">
					<div exportgroup="readme">

						<h1 id="closure"><code>.closure()</code></h1>
<p>This method is used to create an <em>observer-aware</em> context under which to execute code that could potentially mutate an object or array. Under this context, all mutations made to the object will be detected and <a href="/tooling/observer/docs/concepts#observers"><em>observers</em></a> that may be bound to the object will be notified.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Establish a closure on one or more objects</span>
Observer.closure(callback, object[, object[, â€¦ ]]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>callback:    Function</code></strong> - The closure's callback function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...objects</span>) </span>{}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>...objects:    Array</code></strong> - The objects originally given in the call to <code>Observer.closure()</code>, passed in in the order they were recieved.</li></ul>
<p><strong>Return Value</strong></p>
<p>Any value may be returned by this callback, and it will, in turn, be the return value of the call to <code>Observer.closure()</code>. If this turns out to be a <em>Promise</em>, <code>Observer.closure()</code> will wait until it is resolved before going further to evaluate the objects for changes and firing events.</p></li>
<li><p><strong><code>...objects:    Array</code></strong> - A list of objects to observe for the operation in the closure.</p></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="usage">Usage</h2>
<p>The objects and their observer.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The observed object/array</span>
<span class="hljs-keyword">let</span> arr = [], obj = {};
Observer.observe(arr, <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.target, delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
});</code></pre>
<p>The closure, where objects are manipulated.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The closure</span>
Observer.closure(<span class="hljs-function">(<span class="hljs-params">arr, obj</span>) =&gt;</span> {
    arr.push(<span class="hljs-string">&#x27;one&#x27;</span>);
    arr.push(<span class="hljs-string">&#x27;two&#x27;</span>);
    arr.push(<span class="hljs-string">&#x27;three&#x27;</span>);
    arr.push(<span class="hljs-string">&#x27;four&#x27;</span>);
    arr.shift();
}, arr, obj);</code></pre>
<p>The operation above will notify our observer <em>once</em> for a <em>set</em> operation on the properties <code>0</code>, <code>1</code>, <code>2</code>, <code>length</code> of the array - which is what is given in <code>delta.target</code>.</p>
<p>Notice that changes are detected and reported by <em>observers</em> after the closure runs. These changes are detected by comparing the state of the objects before and after the transaction. Intermediate changes, therefore, do not get caught. Also, <em><a href="/tooling/observer/docs/overview#interceptors">interceptors</a></em> that may have been bound to the objects don't get fired. (Compare <a href="/tooling/observer/docs/api/operators/proxy"><code>Observer.proxy()</code></a>.)</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/operators/proxy"><code>Observer.proxy()</code></a></li>
</ul>

					</div>
				</template>

				<template name="intercept">
					<div exportgroup="readme">

						<h1 id="intercept"><code>.intercept()</code></h1>
<p>This method is used to intercept operations performed on an object or array with custom handlers. Operations like <em>set</em>, <em>deleteProperty</em>, <em>get</em> and <em>has</em> are trapped and forwarded to these custom handlers.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Intercept all operations or queries</span>
Observer.intercept(obj, handler[, params = {}]);

<span class="hljs-comment">// Intercept a specific operation</span>
Observer.intercept(obj, type, handler[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>obj:     Object|Array</code></strong> - An object or array.</p></li>
<li><p><strong><code>type:    String</code></strong> - The type of operation to intercept.</p></li>
<li><p><strong><code>handler: Function</code></strong> - A function that handles the operation.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, previous, next</span>) </span>{}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>event:       Event</code></strong> - An object containing details of the ongoing operation.</li>
<li><strong><code>previous:    Any</code></strong> - The value passed by a previous handler in the list, if any. <code>undefined</code> if none.</li>
<li><strong><code>next:        Function</code></strong> - A function that calls the next handler in the list, if any.</li></ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#handler-return-value">Handler Return Value</a> below.</em></p></li>
<li><p><strong><code>params:  Object</code></strong> - Additional parameters for the method.</p>
<ul>
<li><strong><code>tags:    Array</code></strong> - <em>See <a href="#tagging-an-interceptor">Tagging an Interceptor</a></em>.</li></ul></li>
</ul>
<p><strong>Return Value</strong></p>
<p>An <a href="#the-returned-interceptor-instance"><em>Interceptor</em> instance</a>.</p>
<h2 id="usage">Usage</h2>
<p><em>Case 1 - An imaginary product, with a computed <code>likes</code> property - a record of "user likes" -  calculated ondemand.</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> product = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Product Name&#x27;</span>, <span class="hljs-attr">likes</span>: <span class="hljs-literal">null</span> };</code></pre>
<p>Below, we're intercepting the <em>get</em> operation that accesses this property and doing the computation on the first access.</p>
<pre><code class="hljs js language-js">Observer.intercept(product, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">&#x27;get&#x27;</span>) {
        <span class="hljs-keyword">let</span> propertyName = event.name;
        <span class="hljs-keyword">if</span> (propertyName === <span class="hljs-string">&#x27;likes&#x27;</span> &amp;&amp; product[propertyName] === <span class="hljs-literal">null</span>) {
            product[propertyName] =  getProductLikes(); <span class="hljs-comment">// 50</span>
        }
        <span class="hljs-keyword">return</span> product[propertyName];
    }
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<p>Now, let's see what we get for each property we access.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(Observer.get(product, <span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// &#x27;Product Name&#x27;</span>
<span class="hljs-built_in">console</span>.log(Observer.get(product, <span class="hljs-string">&#x27;likes&#x27;</span>)); <span class="hljs-comment">// 50</span></code></pre>
<p><em>Case 2 - Transforming an incoming value for a specific property.</em> We'd intercept the "set" operation, this time, explicitly using the <code>type</code> parameter to specify that.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.name === <span class="hljs-string">&#x27;url&#x27;</span> &amp;&amp; event.value.startsWith(<span class="hljs-string">&#x27;http:&#x27;</span>)) {
        <span class="hljs-comment">// Continue with the flow until the set operation completes</span>
        <span class="hljs-comment">// The next interceptor, if any, will recieve the transformed URL</span>
        <span class="hljs-comment">// if none, the default handler for &quot;set&quot; operations will recieve the transformed URL</span>
        <span class="hljs-keyword">return</span> next(event.value.replace(<span class="hljs-string">&#x27;http:&#x27;</span>, <span class="hljs-string">&#x27;https:&#x27;</span>));
    }
    <span class="hljs-comment">// Forward all other operation to their default handlers</span>
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<p>Now, let's attempt setting different URLs on our object.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(Observer.set(obj, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;https://example.com&#x27;</span>)); <span class="hljs-comment">// Set as-is</span>
<span class="hljs-built_in">console</span>.log(Observer.set(obj, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;http://example.com&#x27;</span>)); <span class="hljs-comment">// Transformed before being set</span></code></pre>
<h2 id="handler-return-value">Handler Return Value</h2>
<p>The return value expected of a handler function depends on the operation being intercepted. For mutation operations - <code>set</code>, <code>defineProperty</code>, <code>deleteProperty</code> - a <em>Boolean</em> <code>true/false</code> is what is expected as a return value to indicate the outcome of the operation. For all other operations - <code>keys</code>, <code>has</code>, <code>get</code>, etc - the return value must correspond to the result defined for the operation. For example, the return value must be an array for <code>keys</code>, a Boolean for <code>has</code>, any value for <code>get</code>, and so on.</p>
<h2 id="tagging-an-interceptor">Tagging an Interceptor</h2>
<p>The <code>params.tags</code> parameter can be used to tag an interceptor. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be used to uniquely identify the interceptor for later retrieval. <em>See <a href="/tooling/observer/docs/api/subscribers/unintercept"><code>Observer.unintercept()</code></a>.</em></p>
<pre><code class="hljs js language-js">Observer.intercept(obj, handler, { <span class="hljs-attr">tags</span>: [ <span class="hljs-string">&#x27;#tag&#x27;</span> ] });</code></pre>
<h2 id="cascading-multiple-interceptors">Cascading Multiple Interceptors</h2>
<p>Multiple interceptors can be applied to an object. Each interceptor will forward events to the next.</p>
<p>An interceptor is called with <code>previous</code> - whatever value is passed from the <em>previous</em> interceptor (or <em>undefined</em> where there is no previous interceptor), and <code>next</code> - a function that calls the <em>next</em> interceptor (or the default handler where there is no next interceptor). This <code>next</code> function can be used to pass a value to the next handler.</p>
<p>Below, we set an additional interceptor to handle setting the <code>url</code> property. But this time, we wouldn't bother if the previous interceptor has handled the URL transformation.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {
    If (previous) {
        <span class="hljs-comment">// A previous handler has handled this!</span>
        <span class="hljs-keyword">return</span> next(previous);
    }
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<h2 id="the-returned-interceptor-instance">The Returned Interceptor Instance</h2>
<p>The <code>Observer.intercept()</code> method returns an <em>Interceptor</em> instance with certain useful methods.</p>
<p><em>Obtain the Interceptor instance:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> instance = Observer.intercept(obj, handler);</code></pre>
<p><em>Synthetically fire the interceptor handler:</em></p>
<pre><code class="hljs js language-js">instance.fire({
    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;set&#x27;</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;propertyName&#x27;</span>
    <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;...&#x27;</span>,
});</code></pre>
<p><em>Disconnect the interceptor:</em></p>
<pre><code class="hljs js language-js">instance.disconnect();</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/unintercept"><code>Observer.unintercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="observe">
					<div exportgroup="readme">

						<h1 id="observe"><code>.observe()</code></h1>
<p>This method is used to observe operations on an object or array.</p>
<ul>
<li><a href="#a-observe-all-properties">Observe All Properties</a></li>
<li><a href="#b-observe-a-path">Observe a Path</a></li>
<li><a href="#c-observe-multiple-paths">Observe Multiple Paths</a></li>
</ul>
<h2 id="a-observe-all-properties">a. Observe All Properties</h2>
<p>Here, a callback is used to observe operations on all properties of an object or array.</p>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Observe all properties</span>
Observer.observe(obj, callback[, params = {}]);</code></pre>
<ul>
<li><p><strong><code>obj:         Object|Array</code></strong> - An object or array.</p></li>
<li><p><strong><code>callback:    Function</code></strong> - A callback function that receives the change events.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">deltas, response</span>) </span>{}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>deltas: Array</code></strong> - An array of <em><a href="/tooling/observer/docs/api/core/Delta">Delta</a> objects</em> that each contains the details of a change.</li>
<li><strong><code>response: Response</code></strong> - A <em><a href="/tooling/observer/docs/api/core/Response">Response</a></em> object.</li></ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#returning-responses-back-to-operators">Returning Responses Back to Operators</a> below.</em></p></li>
<li><p><strong><code>params:      Object</code></strong> - Additional parameters for the method.</p>
<ul>
<li><strong><code>type:    Boolean</code></strong> - The mutation type to observe. <em>See <a href="#specifying-a-mutation-type">Specifying a Mutation Type</a> below</em>.</li>
<li><strong><code>subtree:    Boolean</code></strong> - Whether to observe deep-tree changes. <em>See <a href="#using-the-paramssubtree-parameter">Using the <code>params.subtree</code> Parameter</a> below</em>.</li>
<li><strong><code>tags:    Array</code></strong> - Observer tags. <em>See <a href="#tagging-an-observer">Tagging an Observer</a> below</em>.</li></ul></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#the-returned-observer-instance">return value</a> below.</em></p>
<h3 id="usage">Usage</h3>
<p><em>The callback function:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
};</code></pre>
<p><em>Case 1 - An object observer:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, callback);</code></pre>
<p>The code above will report changes as the <em>object</em> gets modified on any of its properties.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">&#x27;fruit&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>);</code></pre>
<p>With the <em>set</em> operation above, the value of <code>delta.name</code> and <code>delta.path</code> in the console will be <code>'fruit'</code> and <code>[ 'fruit' ]</code> respectively.</p>
<p><em>Case 2 - An array observer:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, callback);</code></pre>
<p>The code above will report changes as entries are added to, or removed from the <em>array</em>.</p>
<pre><code class="hljs js language-js">Observer.set(arr, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;apple&#x27;</span>);</code></pre>
<p>With the <em>set</em> operation above, the value of <code>delta.name</code> and <code>delta.path</code> in the console will be <code>0</code> and <code>[ 0 ]</code> respectively.</p>
<p>If we made multiple changes in one batch, our observer would recieve multiple events at once - <code>deltas.length &gt; 1</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj, {
    <span class="hljs-attr">fruit</span>: <span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;apple&#x27;</span>,
});</code></pre>
<h4 id="using-the-paramssubtree-parameter">Using the <code>params.subtree</code> Parameter</h4>
<p>To observe changes on nested objects or arrays, we would use <em>the <code>params.subtree</code> parameter</em>.</p>
<p><em>The object tree:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {},
};</code></pre>
<p><em>The <code>params.subtree</code> parameter:</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, callback, { <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span> });</code></pre>
<p>The code above will report changes happening down the object tree.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">&#x27;fruits&#x27;</span>, []);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>delta.name</code> and <code>delta.path</code> in the console will be <code>'preferences'</code> and <code>[ 'preferences', 'fruits' ]</code> respectively.</p>
<p>And we could specify the maximum depth in the subtree to be observed by setting the <code>params.subtree</code> to a number.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, callback, { <span class="hljs-attr">subtree</span>: <span class="hljs-number">1</span> });</code></pre>
<p>Now, changes happening further deep will not be reported.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.fruits, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>);</code></pre>
<h2 id="b-observe-a-path">b. Observe a Path</h2>
<p>An observer can be made to observe changes on a specific property - using a <em>property name</em>, or along a specific path in the object tree - using a <em>path expression</em>.</p>
<h3 id="syntax-1">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Observe a propertyName</span>
Observer.observe(obj, propertyName, callback[, params = {}]);

<span class="hljs-comment">// Observe a path</span>
Observer.observe(obj, path, callback[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>obj:          Object|Array</code></strong> - An object or array.</p></li>
<li><p><strong><code>propertyName: String</code></strong> - A property name to observe.</p></li>
<li><p><strong><code>path:         Array</code></strong> - A deep path to observe.</p></li>
<li><p><strong><code>callback:    Function</code></strong> - A callback function that receives the change events.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">delta, response</span>) </span>{}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>delta: Delta</code></strong> - A <em><a href="/tooling/observer/docs/api/core/Delta">Delta</a> object</em> that contains the details of a change.</li>
<li><strong><code>response: Response</code></strong> - A <em><a href="/tooling/observer/docs/api/core/Response">Response</a></em> object.</li></ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#handler-return-value">handler return value</a> below.</em></p></li>
<li><p><strong><code>params:      Object</code></strong> - Additional parameters for the method.</p>
<ul>
<li><strong><code>type:    Boolean</code></strong> - The mutation type to observe. <em>See <a href="#specifying-a-mutation-type">Specifying a Mutation Type</a> below</em>.</li>
<li><strong><code>subtree:    Boolean</code></strong> - Whether to observe deep-tree changes. <em>See <a href="#using-the-paramssubtree-parameter">Using the <code>params.subtree</code> Parameter</a> below</em>.</li>
<li><strong><code>suptree:    Boolean</code></strong> - Whether to observe ancestor-level changes. <em>See <a href="#using-the-paramssuptree-parameter">Using the <code>params.suptree</code> Parameter</a> below</em>.</li>
<li><strong><code>tags:    Array</code></strong> - Observer tags. <em>See <a href="#tagging-an-observer">Tagging an Observer</a> below</em>.</li></ul></li>
</ul>
<p><em>See <a href="#the-returned-observer-instance">return value</a> below.</em></p>
<h3 id="usage-1">Usage</h3>
<p><em>The callback function:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
};</code></pre>
<p><em>The object tree:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {},
};</code></pre>
<p><em>The path expression:</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span> ], callback);</code></pre>
<p>The code above will report changes that occur at the specified path - <code>[ 'preferences', 'fruits' ]</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">&#x27;fruits&#x27;</span>, []);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>delta.name</code> and <code>delta.path</code> in the console will be <code>'preferences'</code> and <code>[ 'preferences', 'fruits' ]</code> respectively.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">&#x27;brands&#x27;</span>, []);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>delta.name</code> and <code>delta.path</code> will be <code>'preferences'</code> and <code>[ 'preferences', 'brands' ]</code> respectively. This time, the change isn't happening along the path we're observing. And we don't see anything in the console.</p>
<h4 id="using-the-paramssubtree-parameter-1">Using the <code>params.subtree</code> Parameter</h4>
<p>To observe changes even deeper down the path, we would use <em>the <code>params.subtree</code> parameter</em>. In this mode, the argument passed to an observer would be an array of <em>delta objects</em> instead of just a <em>delta object</em>.</p>
<p><em>The callback function:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
};</code></pre>
<p><em>The object tree:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {
        <span class="hljs-attr">fruits</span>: [],
        <span class="hljs-attr">brands</span>: [],
    },
};</code></pre>
<p><em>The <code>params.subtree</code> parameter:</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span> ], callback, { <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span> });</code></pre>
<p>The code above will report changes happening at <code>[ 'preferences', 'fruits' ]</code> and further down.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.fruits, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Orange&#x27;</span>);</code></pre>
<p>With the <em>set</em> operation at level 3 above, the value of <code>delta.name</code> and <code>delta.path</code> in the console will be <code>'preferences'</code> and <code>[ 'preferences', 'fruits', 0 ]</code> respectively.</p>
<p>If we made multiple changes in one batch, our observer would recieve multiple events at once - <code>deltas.length &gt; 1</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.fruits, {
    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;apple&#x27;</span>,
});</code></pre>
<p>And we could specify the maximum depth in the subtree to be observed.</p>
<p><em>Setting the <code>params.subtree</code> to a number:</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span> ], callback, { <span class="hljs-attr">subtree</span>: <span class="hljs-number">1</span> });</code></pre>
<p>Now, changes happening further deep will not be reported.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.brands, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>);</code></pre>
<h4 id="using-the-paramssuptree-parameter">Using the <code>params.suptree</code> Parameter</h4>
<p>With a path, it is not only possible to observe <em>subtree</em> changes using <em>the <code>params.subtree</code> parameter</em>, we could also observe <em>super-tree</em> changes - changes happening up the path - using the <code>params.suptree</code> parameter.</p>
<p>For example, if we observed the path <code>[ 'preferences', 'fruits' ]</code>, any changes made to the root <code>[ 'preferences' ]</code> path itself would not be reported. But the <code>params.suptree</code> parameter will enable just that.</p>
<p><em>An empty object:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};</code></pre>
<p><em>The <code>params.suptree</code> parameter:</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span> ], callback, { <span class="hljs-attr">suptree</span>: <span class="hljs-literal">true</span> });</code></pre>
<p>Now, changes happening earlier in the path will be reported.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>, {});</code></pre>
<p>Changes happening at the exact path will also be reported, as expected.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">&#x27;fruits&#x27;</span>, []);</code></pre>
<p>Now, as with the <code>params.subtree</code> parameter, we could also specify a number, this time, as the upper threshold for the <em>super-tree</em> observation.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span>, <span class="hljs-number">0</span> ], callback, { <span class="hljs-attr">suptree</span>: <span class="hljs-number">1</span> });</code></pre>
<p>Now, changes happening beyond this threshold will not be reported.</p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, <span class="hljs-string">&#x27;preferences&#x27;</span>);</code></pre>
<h2 id="c-observe-multiple-paths">c. Observe Multiple Paths</h2>
<p>Multiple paths can be observed at once by specifying an array of path expressions. The observer is called with the paths along which an event happens.</p>
<h3 id="syntax-2">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Observe a path</span>
Observer.observe(obj, [ path, ... ], callback[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>obj:          Object|Array</code></strong> - An object or array.</p></li>
<li><p><strong><code>path:         Array</code></strong> - A deep path to observe.</p></li>
<li><p><strong><code>callback:     Function</code></strong> - A callback function that receives the change events.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">deltas, response</span>) </span>{}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>deltas: Array</code></strong> - An array of <em><a href="/tooling/observer/docs/api/core/Delta">Delta</a> objects</em> that each contains the details of a change.</li>
<li><strong><code>response: Response</code></strong> - A <em><a href="/tooling/observer/docs/api/core/Response">Response</a></em> object.</li></ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#handler-return-value">handler return value</a> below.</em></p></li>
<li><p><strong><code>params:      Object</code></strong> - Additional parameters for the method.</p>
<ul>
<li><strong><code>type:    Boolean</code></strong> - The mutation type to observe. <em>See <a href="#specifying-a-mutation-type">Specifying a Mutation Type</a> below</em>.</li>
<li><strong><code>subtree:    Boolean</code></strong> - Whether to observe deep-tree changes. <em>See <a href="#using-the-paramssubtree-parameter">Using the <code>params.subtree</code> Parameter</a> below</em>.</li>
<li><strong><code>suptree:    Boolean</code></strong> - Whether to observe ancestor-level changes. <em>See <a href="#using-the-paramssuptree-parameter">Using the <code>params.suptree</code> Parameter</a> below</em>.</li>
<li><strong><code>tags:    Array</code></strong> - Observer tags. <em>See <a href="#tagging-an-observer">Tagging an Observer</a> below</em>.</li></ul></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>See <a href="#the-returned-observer-instance">return value</a> below.</em></p>
<h3 id="usage-2">Usage</h3>
<p><em>The callback function:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">deltas</span> =&gt;</span> {
    deltas.forEach(<span class="hljs-function"><span class="hljs-params">delta</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(delta.type, delta.name, delta.path, delta.value, delta.oldValue);
    });
};</code></pre>
<p><em>The object tree:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {
        <span class="hljs-attr">fruits</span>: [],
        <span class="hljs-attr">brands</span>: [],
    },
};</code></pre>
<p><em>The paths:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
<span class="hljs-keyword">let</span> path1 = [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;fruits&#x27;</span> ];
<span class="hljs-keyword">let</span> path2 = [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-string">&#x27;brands&#x27;</span>, <span class="hljs-number">1</span> ];
Observer.observe(obj, [
    path1,
    path2
], callback);</code></pre>
<p>The code above will report changes as any of the paths recieve a change.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">&#x27;fruits&#x27;</span>, []);</code></pre>
<p>If we made multiple changes in one batch, our observer would recieve multiple events at once - <code>deltas.length &gt; 1</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, {
    <span class="hljs-attr">fruits</span>: [ <span class="hljs-string">&#x27;orange&#x27;</span> ],
    <span class="hljs-attr">brands</span>: [ <span class="hljs-string">&#x27;apple&#x27;</span> ],
});</code></pre>
<h4 id="using-wildcard-paths">Using Wildcard Paths</h4>
<p>It is possible to observe multiple paths dynamically using one <em>wildcard path</em> expression. Wildcard paths are paths with empty slots, designed to match <em>event paths</em> as they happen.</p>
<p><em>The object tree:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {
        <span class="hljs-attr">fruits</span>: [],
        <span class="hljs-attr">brands</span>: [],
    },
};</code></pre>
<p><em>The wildcard path (notice below that this is a 3-level path but with an empty middle slot):</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, [ <span class="hljs-string">&#x27;preferences&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span> ], callback);</code></pre>
<p>The code above will report changes when an event fires at a path that fulfills our wildcard path. Now, both <code>[ 'preferences', 'fruits', 0 ]</code> and <code>[ 'preferences', 'brands', 0 ]</code> would do just that.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.fruits, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mango&#x27;</span>);</code></pre>
<p>If we made multiple changes in one batch, our observer would recieve multiple events at once - <code>deltas.length &gt; 1</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.fruits, {
    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;orange&#x27;</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;apple&#x27;</span>,
});</code></pre>
<!--
## Automatic Subtree Observability
-->
<h2 id="specifying-mutation-types">Specifying Mutation Types</h2>
<p>The <code>params.type</code> parameter can be used to tell an observer to respond to a specific mutation types like "set" and "del".</p>
<pre><code class="hljs js language-js">Observer.observe(obj, path, callback, { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;del&#x27;</span> });</code></pre>
<h2 id="tagging-an-observer">Tagging an Observer</h2>
<p>The <code>params.tags</code> parameter can be used to tag an observer. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be used to uniquely identify the observer for later retrieval. <em>See <a href="/tooling/observer/docs/api/subscribers/unobserve"><code>Observer.unobserve()</code></a>.</em></p>
<pre><code class="hljs js language-js">Observer.observe(obj, path, callback, { <span class="hljs-attr">tags</span>: [ <span class="hljs-string">&#x27;#tag&#x27;</span> ] });</code></pre>
<h2 id="the-returned-observer-instance">The Returned Observer Instance</h2>
<p>The <code>Observer.observe()</code> method returns an <em>Observer</em> instance with certain useful methods.</p>
<p><em>Obtain the Observer instance:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> instance = Observer.observe(obj, callback);</code></pre>
<p><em>Synthetically fire the Observer handler:</em></p>
<pre><code class="hljs js language-js">instance.fire({
    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;set&#x27;</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;propertyName&#x27;</span>
    <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;...&#x27;</span>,
});</code></pre>
<p><em>Disconnect the observer:</em></p>
<pre><code class="hljs js language-js">instance.disconnect();</code></pre>
<h2 id="returning-responses-back-to-operators">Returning Responses Back to Operators</h2>
<p>Observers may respond to an event from their callback functions by calling an appropriate method on the <a href="/tooling/observer/docs/api/core/Response">Response</a> object they recieve on their second parameter, or by returning an equivalent return value. The initiator of the operation may obtain the <em>Response</em> object to inspect the state of the object.</p>
<p><strong><code>response.stopPropagation()</code>:</strong> Calling this method stops further processing of the operation, that is, stops the event from reaching other event handlers, and prevents the initiator of the operation from taking any default action that it normally would take after the operation. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, <span class="hljs-function">(<span class="hljs-params">delta, response</span>) =&gt;</span> {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the operation would need to have flagged the event as <em>cancellable</em> for the above to be honoured.</p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>,
});</code></pre>
<p>The initiator may also obtain the response object to determine the state of the responses made by observers. Notice the <code>params.responseObject</code> parameter that tells <code>Observer.deleteProperty()</code> to return a <em>response object</em> for use.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});</code></pre>
<p><em>Now, it determines the state of the responses made by observers:</em></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong><code>response.preventDefault()</code>:</strong> Calling this method prevents the initiator of the operation from taking any default action that it normally would take after the operation. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, <span class="hljs-function">(<span class="hljs-params">delta, response</span>) =&gt;</span> {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the operation may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> Calling this method tells the initiator of the operation to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, <span class="hljs-function">(<span class="hljs-params">delta, response</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the operation may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers respond with a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function">() =&gt;</span> {
    });
}</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/unobserve"><code>Observer.unobserve()</code></a></li>
</ul>

					</div>
				</template>

				<template name="unintercept">
					<div exportgroup="readme">

						<h1 id="unintercept"><code>.unintercept()</code></h1>
<p>This method is used to unbind interceptors previously bound with <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a>.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all interceptors bound to the following property name</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unintercept(obj, type);

<span class="hljs-comment">// Unbind the interceptor bound with the following handler function</span>
Observer.unintercept(obj, type, originalHandler);

<span class="hljs-comment">// Unbind the interceptor bound with the following handler function and tags</span>
Observer.unintercept(obj, type, originalHandler, {<span class="hljs-attr">tags</span>:[...originalTags]});

<span class="hljs-comment">// Unbind all interceptors bound with the following tags</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unintercept(obj, type, <span class="hljs-literal">null</span>, {<span class="hljs-attr">tags</span>:[...originalTags]});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>obj:             Object|Array</code></strong> - an object or array.</li>
<li><strong><code>type:            String</code></strong> - if not <code>null</code>, the operation type used on <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
<li><strong><code>originalHandler: Function</code></strong> - if not <code>null</code>, the <em>original</em> callback function used on <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
<li><strong><code>params.tags:     Array</code></strong> - if not <code>null</code>, the list of <em>tags</em> (in any order) used on <a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/intercept"><code>Observer.intercept()</code></a></li>
</ul>

					</div>
				</template>

				<template name="unobserve">
					<div exportgroup="readme">

						<h1 id="unobserve"><code>.unobserve()</code></h1>
<p>This method is used to unbind <em>observers</em> previously bound with the <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a> method.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all observers bound to the following property name</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unobserve(obj, path);

<span class="hljs-comment">// Unbind the observer bound with the following handler function</span>
Observer.unobserve(obj, path, originalCallback);

<span class="hljs-comment">// Unbind the observer bound with the following handler function and tags</span>
Observer.unobserve(obj, path, originalCallback, { <span class="hljs-attr">tags</span>: [ ...originalTags ] });

<span class="hljs-comment">// Unbind the observer bound with the following handler function and reflex type </span>
Observer.unobserve(obj, path, originalCallback, { <span class="hljs-attr">type</span>: â€™setâ€™ });

<span class="hljs-comment">// Unbind all observers bound with the following tags</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unobserve(obj, [ path, ... ], <span class="hljs-literal">null</span>, { <span class="hljs-attr">tags</span>: [ ...originalTags ] });</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>obj:             Object|Array</code></strong> - An object or array.</p></li>
<li><p><strong><code>path:            String|Array</code></strong> - If not <code>null</code>, a path to unobserve.</p></li>
<li><p><strong><code>originalCallback: Function</code></strong> - If not <code>null</code>, the <em>original</em> callback function used during <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></p></li>
<li><p><strong><code>params:          Object</code></strong> - Additional parameters for the method.</p>
<ul>
<li><strong><code>tags:     Array</code></strong> - If not <code>null</code>, the list of the <em>original</em> tags (in any order) used during <a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a>.</li></ul></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="usage">Usage</h2>
<p><em>See <a href="/tooling/observer/docs/api/subscribers/observe#usage"><code>Observer.observe()</code></a>.</em></p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/tooling/observer/docs/api/subscribers/observe"><code>Observer.observe()</code></a></li>
</ul>

					</div>
				</template>
			</template>
		</template>

		<template name="getting-started">
			<div exportgroup="readme">

				<h1 id="getting-started">Getting Started</h1>

			</div>

			<template name="download">
				<div exportgroup="readme">

					<h1 id="download-options">Download Options</h1>
<p>Observer can be used either from a CDN or as an npm package.</p>
<h2 id="option-1-from-a-cdn">Option 1: From a CDN</h2>
<p>Add the following script tag to your page to include the all-in-one Observer module:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@webqit/observer/dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>The above tag loads Observer into a global "WebQit" object.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">const</span> Observer = <span class="hljs-built_in">window</span>.WebQit.Observer;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="option-2-as-an-npm-package">Option 2: As an npm Package</h2>
<p>With <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">npm available on your terminal</a>, run the following command to install Observer:</p>
<pre><code class="hljs text language-text">$ npm i @webqit/observer</code></pre>
<p>Import the installed package:</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Import the initializer</span>
<span class="hljs-keyword">import</span> Observer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@webqit/observer&#x27;</span>;</code></pre>
<h2 id="next-steps">Next Steps</h2>
<p>Continue to <a href="/tooling/observer/docs/api">learning the API</a>.</p>

				</div>
			</template>

			<template name="explainer">
				<div exportgroup="readme">

					<h1 id="explainer">Explainer</h1>
<!--
Here is how the approach we took with the Observer API compares, or contrasts, with those of some existing alternatives.

## With JavaScript's Reflection APIs

The Observer API shares much in API surface with JavaScript's built-in [*Object*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) and [*Reflect*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) APIs. Compare:

+ [`Observer.set()`](/tooling/observer/docs/getting-started/api/set) / [`Reflect.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set)
+ [`Observer.get()`](/tooling/observer/docs/getting-started/api/get) / [`Reflect.get()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get)
+ [`Observer.has()`](/tooling/observer/docs/getting-started/api/has) / [`Reflect.has()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has)
+ [`Observer.ownKeys()`](/tooling/observer/docs/getting-started/api/ownkeys) / [`Reflect.ownKeys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)
+ [`Observer.deleteProperty()`](/tooling/observer/docs/getting-started/api/deleteproperty) / [`Reflect.deleteProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty) / [`Object.deleteProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/deleteProperty)
+ [`Observer.defineProperty()`](/tooling/observer/docs/getting-started/api/defineproperty) / [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
+ [`Observer.keys()`](/tooling/observer/docs/getting-started/api/defineproperty) / [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)

What they don't share in common is Observer's *observability* and *interceptibility* of these operations. Where these features are needed, Observer's APIs will serve as a drop-in replacement.

Learn more about what's possible with the following methods:

+ [`Observer.observe()`](/tooling/observer/docs/getting-started/api/observe)
+ [`Observer.intercept()`](/tooling/observer/docs/getting-started/api/intercept)

## JavaScript's Property Accessors, and Proxies

Both the Observer API and JavaScript's existing interceptibilty APIs - property [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) and [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), and [JavaScript Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) will let you intercept operations on JavaScript objects. But, the Observer API is designed for a pattern that is almost not possible with these existing approaches.

Problem is:

+ With property Accessors, there can be only one *intercepting code* over an object.

    ```js
    // The object
    let obj = {};

    // -------------------------

    // The intercepting code - logs operations
    Object.defineProperty(obj, 'someProperty', {
        get: () => {
            console.log('"get" operation');
            return 'some value';
        },
        set: (someValue) => {
            console.log('"set" operation');
            // Set someValue;
            return true;
        }
    });

    // -------------------------

    // Multiple actors
    let someValue = obj.someProperty; // "some value"; // from the "get" interceptor above
    obj.someProperty = 'some new value'; // triggers the "set" interceptor above
    obj.someProperty = 'some other new value'; // triggers the "set" interceptor above
    ```

+ With proxies, there can be only one *intercepting code* over an instance. In addition, the final object every other part of the code sees is a proxy, and not the object itself. And if they're not prepared for a proxy, the magic, or even the code, fails. **Obscuring object identity** thus becomes a big challenge.

    ```js
    // The object
    let obj = {};

    // -------------------------

    // The intercepting code - logs operations
    let wrapped = new Proxy(obj, {
        get: (target, propertyName) => {
            console.log('"get" operation');
            return 'some value';
        },
        set: (target, propertyName, propertyValue) => {
            console.log('"set" operation');
            // Set someValue;
            return true;
        }
    });

    // -------------------------

    // Multiple actors, but acting on a wrapper unknowingly
    let someValue = wrapped.someProperty; // "some value"; // from the "get" interceptor above
    // Or let someValue = Reflect.get(obj, 'someProperty');
    wrapped.someProperty = 'some new value'; // triggers the "set" interceptor above
    wrapped.someProperty = 'some other new value'; // triggers the "set" interceptor above

    // -------------------------

    // Try acting on the object itself
    let someValue = obj.someProperty; // undefined; // not intercepted
    // Or let someValue = Observer.get(obj, 'someProperty');
    obj.someProperty = 'some new value'; // not intercepted
    ```

But, with the Observer API:

+ An object's property setters and getters are not tied to a single *intercepting code*, nor are they - setters and getters - even used. We can thus have any number of *intercepting code* over an object - whether just *observing mutations* or actually *intercepting operations*. The object itself isn't wrapped or obscured in some way.

    ```js
    // The object
    let obj = {};

    // -------------------------

    // Any number of observers
    Observer.observe(obj, 'someProperty', event => {
        console.log('"' + event.type + '" operation');
    });
    Observer.observe(obj, 'someProperty', event => {
        console.log('same "' + event.type + '" operation');
    });

    // Any number of interceptors
    Observer.intercept(obj, 'get', (event, recieved, next) => {
        console.log('"get" operation', event.name);
        return next('some value');
    });
    Observer.intercept(obj, 'get', (event, recieved, next) => {
        console.log('"get" operation', event.name);
        return next(recieved/*from any preceding interceptor*/ || 'some different value');
    });

    // -------------------------

    // Multiple actors
    let someValue = Observer.get(obj, 'someProperty'); // "some value"; // from the interceptors above
    Observer.set(obj, 'someProperty', 'some new value'); // triggers both the interceptors and observers above
    Observer.set(obj, 'someProperty', 'some other new value'); // triggers both the interceptors and observers above
    ```

+ And interestingly, property setters and getters, and proxies, are still implementable with the Observer API, and this time, without their inherent limitations.

    ```js
    let someValue = obj.someProperty; // "some other new value"; // doesn't fire interceptors; so, obtained traditionally

    // -------------------------

    // With property setters and getters
    Observer.init(obj, 'someProperty');
    let someValue = obj.someProperty; // "some value"; // from the interceptors above
    obj.someProperty = 'some new value'; // triggers both the interceptors and observers above

    // On calling Observer.init() again with the same property name
    Observer.init(obj, 'someProperty'); // Has no additional effect
    // -------------------------

    // With proxies
    let wrapper = Observer.proxy(obj);
    let someValue = wrapper.someProperty; // "some value"; // from the interceptors above
    wrapper.someProperty = 'some new value'; // triggers both the interceptors and observers above
    // Obtain the real object from proxy wrapper
    let obj = Observer.unproxy(wrapper);

    // On calling Observer.proxy() again
    let wrapper2 = Observer.proxy(obj);
    let someValue = wrapper2.someProperty; // "some value"; // from the same interceptors above
    wrapper2.someProperty = 'some other new value'; // triggers both the same interceptors and same observers above
    // Obtain the real object from proxy wrapper
    let obj = Observer.unproxy(wrapper2);
    ```

Learn more about what's possible with the following methods:

+ [`Observer.observe()`](/tooling/observer/docs/getting-started/api/observe)
+ [`Observer.intercept()`](/tooling/observer/docs/getting-started/api/intercept)
+ [`Observer.set()`](/tooling/observer/docs/getting-started/api/set)
+ [`Observer.get()`](/tooling/observer/docs/getting-started/api/get)
+ [`Observer.init()`](/tooling/observer/docs/getting-started/api/init)
+ [`Observer.proxy()`](/tooling/observer/docs/getting-started/api/proxy)
+ [`Observer.unproxy()`](/tooling/observer/docs/getting-started/api/unproxy)

## JavaScript's Depreciated Object.observe()

The Observer API shares much in common with the once-exciting [`Object.observe()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Object.observe) function, but disagrees with it on a major behaviour. `Object.observe()` was designed to deliver detected changes *asynchronously*, while `Observer.observe()` is designed to deliver those changes *synchronously*. The difference is in the timing of events, and timing is everything in most usecases.

+ With [`Object.observe()`, operations on an object are announced asynchronously. Notice the order in which the following reports are logged to the console.

    ```js
    let obj = {};
    Object.observe(obj, changes => {
        console.log('Change detected on ' + changes[0].name);
    });

    // -------

    console.log('Before "set" operation');
    obj.someProperty = 'some value';
    // Or Reflect.set(obj, 'someProperty', 'some value');
    console.log('After "set" operation');
    ```

    Console:

    ```shell
    > Before "set" operation
    > After "set" operation
    > Change detected on someProperty
    ```

+ But with `Observer.observe()`, operations on an object are announced in realtime. Notice the order in which the following reports are logged to the console.

    ```js
    let obj = {};
    Observer.observe(obj, changes => {
        console.log('Change detected on ' + changes[0].name);
    });

    // -------

    console.log('Before "set" operation');
    Observer.set(obj, 'someProperty', 'some value');
    console.log('After "set" operation');
    ```

    Console:

    ```shell
    > Before "set" operation
    > Change detected on someProperty
    > After "set" operation
    ```

+ The asynchronous nature of [`Object.observe()` means that operations on an object are announced in batches. The following two operations will most-probbably be batched.

    ```js
    let obj = {};
    Object.observe(obj, changes => {
        console.log('Number of changes made: ' + changes.length);
    });

    // -------

    console.log('Before "set" operations');
    obj.someProperty = 'some value';
    // Or Reflect.set(obj, 'someProperty', 'some value');
    obj.someOtherProperty = 'some other value';
    // Or Reflect.set(obj, 'someOtherProperty', 'some other value');
    console.log('After "set" operations');
    ```

    Console:

    ```shell
    > Before "set" operations
    > After "set" operations
    > Number of changes made: 2
    ```

+ But with `Observer.observe()`, individual operations on an object are announced in realtime. Notice the difference in the console.

    ```js
    let obj = {};
    Observer.observe(obj, changes => {
        console.log('Number of changes made: ' + changes.length);
    });

    // -------

    console.log('Before "set" operations');
    Observer.set(obj, 'someProperty', 'some value');
    Observer.set(obj, 'someOtherProperty', 'some other value');
    console.log('After "set" operations');
    ```

    Console:

    ```shell
    > Before "set" operations
    > Number of changes made: 1
    > Number of changes made: 1
    > After "set" operations
    ```

    To take things further, the Observer API also makes it possible to batch operations. It just doesn't impose this behaviour on every usecase.

    The `Observer.set()` and `Observer.deleteProperty()` methods let us do this where needed.

    ```js
    console.log('Before "set" operations');
    Observer.set(obj, {
        someProperty: 'some value',
        someOtherProperty: 'some other value',
    });
    // Or Observer.deleteProperty(obj, ['someProperty', 'someOtherProperty']);
    console.log('After "set" operations');
    ```

    Console:

    ```shell
    > Before "set" operations
    > Number of changes made: 2
    > After "set" operations
    ```

Learn more about what's possible with the following methods:

+ [`Observer.set()`](/tooling/observer/docs/getting-started/api/set)
+ [`Observer.deleteProperty()`](/tooling/observer/docs/getting-started/api/deleteproperty)
-->

				</div>
			</template>

			<template name="overview">
				<div exportgroup="readme">

					<h1 id="overview">Overview</h1>
<p>Take a one-minute rundown of the Observer API.</p>
<h2 id="observe">Observe</h2>
<p>Observe operations on any object or arrayâ€¦</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};</code></pre>
<p>â€¦using the <a href="/tooling/observer/docs/getting-started/api/subscribers/observe"><code>Observer.observe()</code></a> method.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, <span class="hljs-function"><span class="hljs-params">changes</span> =&gt;</span> {
    changes.forEach(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(c.type, c.name, c.path, c.value, c.oldValue);
    });
});</code></pre>
<p>Now changes will be delivered <em>synchronously</em> - as they happen.</p>
<h2 id="mutate">Mutate</h2>
<p>Programmatically make <em>reactive</em> changes using the <em><a href="/tooling/observer/docs/getting-started/concepts#with-javascripts-reflection-apis">native-like</a></em> <a href="/tooling/observer/docs/getting-started/api/operators">set of operators</a>â€¦</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// A single set operation</span>
Observer.set(obj, <span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// A batch set operation</span>
Observer.set(obj, {
    <span class="hljs-attr">prop2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>,
    <span class="hljs-attr">prop3</span>: <span class="hljs-string">&#x27;value3&#x27;</span>,
});</code></pre>
<p>â€¦or switch to using <em>object accessors</em> - using the <a href="/tooling/observer/docs/getting-started/api/operators/accessorize"><code>Observer.accessorize()</code></a> methodâ€¦</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Accessorize all (existing) properties</span>
Observer.accessorize(obj);
<span class="hljs-comment">// Accessorize specific properties (existing or new)</span>
Observer.accessorize(obj, [<span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;prop5&#x27;</span>, <span class="hljs-string">&#x27;prop9&#x27;</span>]);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Make reactive operations</span>
obj.prop1 = <span class="hljs-string">&#x27;value1&#x27;</span>;
obj.prop5 = <span class="hljs-string">&#x27;value5&#x27;</span>;
obj.prop9 = <span class="hljs-string">&#x27;value9&#x27;</span>;</code></pre>
<p>â€¦or even go with a <em>reactive Proxy</em> of your object, and imply properties on the fly.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain a reactive Proxy</span>
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj);</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Make reactive operations</span>
_obj.prop1 = <span class="hljs-string">&#x27;value1&#x27;</span>;
_obj.prop4 = <span class="hljs-string">&#x27;value4&#x27;</span>;
_obj.prop8 = <span class="hljs-string">&#x27;value8&#x27;</span>;</code></pre>
<p>And no problem if you inadvertently cascade the approaches. No bizzare behaviours.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Accessorized properties are already reactive</span>
Observer.accessorize(obj, [<span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;prop6&#x27;</span>, <span class="hljs-string">&#x27;prop10&#x27;</span>]);

<span class="hljs-comment">// But no problem if we still want a proxy over an accessorized object</span>
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj);

<span class="hljs-comment">// And yet no problem if we still made a programmatic call over an already reactive Proxy</span>
Observer.set(_obj, <span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>);</code></pre>
<h2 id="intercept">Intercept</h2>
<p>How about some level of indirection - the ability to hook into operators like <code>Observer.set()</code> and  <code>Observer.deleteProperty()</code> to repurpose their operation? That's all possible using the <a href="/tooling/observer/docs/getting-started/api/subscribers/intercept"><code>Observer.intercept()</code></a> method!</p>
<p>Below, we catch any attempt to set an HTTP URL and force it to an HTTPS URL.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, previous, next</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.name === <span class="hljs-string">&#x27;url&#x27;</span> &amp;&amp; event.value.startsWith(<span class="hljs-string">&#x27;http:&#x27;</span>)) {
        <span class="hljs-keyword">return</span> next(event.value.replace(<span class="hljs-string">&#x27;http:&#x27;</span>, <span class="hljs-string">&#x27;https:&#x27;</span>));
    }
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<p>Now, only the first of the following will fly as-is.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;https://webqit.io&#x27;</span>);</code></pre>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;http://webqit.io&#x27;</span>);</code></pre>
<h2 id="cleaning-up">Cleaning Up</h2>
<p>You'll sometimes want to clean up? There are the methods for that!</p>
<ul>
<li><a href="/tooling/observer/docs/getting-started/api/subscribers/unobserve"><code>Observer.unobserve()</code></a></li>
<li><a href="/tooling/observer/docs/getting-started/api/subscribers/unintercept"><code>Observer.unintercept()</code></a></li>
<li><a href="/tooling/observer/docs/getting-started/api/operators/unproxy"><code>Observer.unproxy()</code></a></li>
<li><a href="/tooling/observer/docs/getting-started/api/operators/unaccessorize"><code>Observer.unaccessorize()</code></a></li>
</ul>
<h2 id="but-beyond-this-point-lies">But Beyond this Point Liesâ€¦</h2>
<p>Everything from the <a href="/tooling/observer/docs/getting-started/download">download</a> page, to the <a href="/tooling/observer/docs/getting-started/concepts">concepts</a> page, to the <a href="/tooling/observer/docs/getting-started/api">API Reference</a>.</p>

				</div>
			</template>
		</template>
	</template>

	
