
	<div exportgroup="readme">

		<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/webflo" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/webflo.svg" alt="NPM version" /></a></span> <span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/webflo" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/webflo.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<h2 id="for-a-full-development-story">For a Full Development Story!</h2>
<p>Start on a clean slate, in zero-abstraction, zero-config, and zero-dependency. Develop and deploy anything from a simple <code>'Hello World!'</code> to a rich web and mobile experience.</p>
<h2 id="getting-started">Getting Started</h2>
<p><a href="/tooling/webflo/docs">Visit the docs</a> for an overview, the commands and usage guides.</p>
<p><html-import data-id="quickstart" template="@layout/quickstart"></html-import></p>
<p>Also, <a href="https://github.com/webqit/webflo/discussions">join the Github Discussions</a> for OOHTML.</p>
<h2 id="contributing-to-the-project">Contributing to the Project</h2>
<p>Help report bugs, or request features; or join in the development.</p>
<ul>
<li><a href="https://github.com/webqit/webflo">Visit this project on github</a>.</li>
<li><a href="https://github.com/webqit/webqit-tooling.docs/edit/master/webflo/docs">Contribute to the docs on github</a>.</li>
</ul>
<h2 id="license">License</h2>
<p>The MIT license.</p>

	</div>

	

	<template name="docs">
		<div exportgroup="readme-1">

			<h1 id="project-layout">Project Layout</h1>
<p>It's a good practice to locate certain project files in conventional places. Webflo is thus able to automatically identify them at runtime. Here's an overview (keep in mind that everything below is optional, and/or can be renamed):</p>
<ul>
<li><a href="#the-public-directory"><code>/public</code></a></li>
<li><a href="#the-server-directory"><code>/server</code></a></li>
<li><a href="#the-client-directory"><code>/client</code></a></li>
<li><a href="#the-worker-directory"><code>/worker</code></a></li>
</ul>
<p>Let's now see what goes into each directory, and how they're all related.</p>
<h3 id="the-public-directory">The <code>/public</code> Directory</h3>
<p>If you intend to have static files (like images or CSS files) that should be served automatically, place them in this directory.</p>
<p>Your application's start page - <code>index.html</code> - should also be here.</p>
<ul>
<li><code>/public</code><ul>
<li><code>/index.html</code> - <em>Try add some Hello World greeting.</em></li></ul></li>
</ul>
<p>Now, when you start the Webflo server and navigate to <code>http://localhost:3000/</code> (or <code>http://localhost:3000/index.html</code>) on your browser, the start page is shown.</p>
<pre><code class="hljs bash language-bash">webflo start</code></pre>
<blockquote>
  <p>Ensure that you are at your project root <code>webflo-app</code> in the terminal to run the above Webflo command, and subsequent ones.</p>
</blockquote>
<blockquote>
  <p>Now, if all you're creating is a static site, your work ends in this directory!</p>
</blockquote>
<p>Webflo serves static files by simply mapping URL paths to filesystem paths. For example, the request URL <code>/</code> (or <code>/index.html</code>) would be mapped to the file <code>/public/index.html</code>, and the request URL <code>/products</code> (or <code>/products/index.html</code>) would be mapped to the file <code>/public/products/index.html</code>, and so on.</p>
<h3 id="the-server-directory">The <code>/server</code> Directory</h3>
<p>If you intend to have JavaScript files that handle dynamic routing on the server, place them in this directory.</p>
<ul>
<li><code>/server</code><ul>
<li><code>/index.js</code> - <em>This is a server-side route handler.</em></li></ul></li>
</ul>
<p>Now, what happens is, when you navigate to <code>http://localhost:3000/</code> (or <code>http://localhost:3000/index.html</code>) on your browser, the route handler in <code>index.js</code> is hit first with the HTTP request. It then decides to either return its own response (in object format) or simply allow the request to <em>flow</em> to the default <code>/public/index.html</code> file, in which case an <em>HTML response</em> is returned.</p>
<ul>
<li>-&gt; enter <code>/server</code><ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/public</code> if exists; match <code>index.html</code></li>
</ul>
<p>So, route handlers can both return <em>response data</em> of their own and act as a gateway for the request/response flow. As we will see shortly, response data returned from route handlers can either serve as <em>automatic JSON (API) responses</em> or get rendered into the default <code>/public/index.html</code> file and returned as a rendered <em>HTML response</em>.</p>
<p>So far, with just two files - <code>/public/index.html</code> and <code>/server/index.js</code> - we can already return either of three responses for the URL <code>http://localhost:3000/</code>: a JSON API response, a static HTML response, or a dynamically-rendered HTML response. Code examples ahead.</p>
<blockquote>
  <p>Now, if all you're creating is a traditional server-side application or simply an API backend, your work ends in this directory! Routing is covered in <a href="#routing">the next section</a>. And <a href="/tooling/webflo/docs/learn/server-side-routing">here</a> are server-side routing examples.</p>
</blockquote>
<h3 id="the-client-directory">The <code>/client</code> Directory</h3>
<p>If you intend to have JavaScript files that handle routing (e.g navigation requests) in the browser, place them in this directory.</p>
<ul>
<li><code>/client</code><ul>
<li><code>/index.js</code> - <em>This is a client-side route handler.</em></li></ul></li>
</ul>
<p>Next, run a Webflo command that automatically <em>builds</em> these files into a single script that you can include on your <code>/public/index.html</code> page.</p>
<pre><code class="hljs bash language-bash">webflo build</code></pre>
<blockquote>
  <p>Client builds are covered later on. But let's assume for now that the generated JavaScript file is now included in the HTML page.</p>
</blockquote>
<p>Now, what happens is, when you navigate to <code>http://localhost:3000/</code> (or <code>http://localhost:3000/index.html</code>) on your browser, this client-side route handler is hit first with the HTTP request. It then decides to either return an in-browser <em>response data</em> that's rendered to the UI or simply allow the request to <em>flow</em> to the server - all while preventing the browser from performing a page reload.</p>
<ul>
<li>-&gt; enter <code>/client</code><ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/server</code> if exists<ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/public</code> if exists; match <code>index.html</code></li>
</ul>
<p>As we will see, being able to either return an in-browser response data or act as a gateway for the request/response flow is a powerful way to create fast and smooth client-side experiences.</p>
<p>At this point, with just three files - <code>/public/index.html</code>, <code>/server/index.js</code> and <code>/client/index.js</code> - we can already have either a static site, an API backend, a server-side app, a client-side app, or a combination of all of these. Code examples ahead.</p>
<blockquote>
  <p>Okay, if all you're creating is a client-side application, your work ends in this directory! Routing is covered in <a href="#routing">the next section</a>. And <a href="/tooling/webflo/docs/learn/client-side-routing">here</a> are client-side routing examples.</p>
</blockquote>
<h3 id="the-worker-directory">The <code>/worker</code> Directory</h3>
<p>What happens here is quite advanced and you can ignore this until you really need it. But if you already know about application Service Workers and intend to enhance your app's client-side experience with Service Workers, Webflo lets you implement routing at the service-worker level, and you place your route handlers in this directory.</p>
<ul>
<li><code>/worker</code><ul>
<li><code>/index.js</code> - <em>This is a worker-level route handler.</em></li></ul></li>
</ul>
<p>Next, run a Webflo command that automatically <em>builds</em> these files into a single script that will form part of the service worker file for your page.</p>
<pre><code class="hljs bash language-bash">webflo build</code></pre>
<blockquote>
  <p>Worker builds are covered later on. But let's assume for now that the generated JavaScript file is now part of the service worker file for your page.</p>
</blockquote>
<p>Now, what happens is, when you navigate to <code>http://localhost:3000/</code> (or <code>http://localhost:3000/index.html</code>) on your browser, <em>and the HTTP navigation request is passed on from the initial client-side route handler <code>/client/index.js</code>, where exists</em>, the request next enters the Service orker layer and hits this route handler. This handler then decides to either return an in-browser <em>response data</em> that's rendered to the UI or simply allow the request to finally <em>flow</em> to the server.</p>
<ul>
<li>-&gt; enter <code>/client</code> if exists<ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/worker</code><ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/server</code> if exists<ul>
<li>-&gt; call <code>index.js</code>; continue?</li></ul></li>
<li>-&gt; enter <code>/public</code> if exists; match <code>index.html</code></li>
</ul>
<p>Woohoo! With a combition of just four files - <code>/public/index.html</code>, <code>/server/index.js</code>, <code>/client/index.js</code> and <code>/worker/index.js</code> - we can already have any type of application with great offline experiences.</p>
<blockquote>
  <p>It is even just possible to build an entire app out of the <code>/worker</code> directory alone, if all you're building is a client-side, offline-capable app! Routing is covered in <a href="#routing">the next section</a>. And <a href="/tooling/webflo/docs/learn/worker-level-routing">here</a> are worker-level routing examples. Service Workers are covered in detail in <a href="/tooling/webflo/docs/learn/progressive-web-apps">the Progressive Web Apps (PWA) tutorial</a>.</p>
</blockquote>
<p>Webflo lets us follow the traditional filesystem layout for a project. The concept of routing is simply drawn on this layout. It is all about the <em>request/response flow and what happens along the path it takes</em>. Webflo's <em>skillfulness with flows</em> is probabbly the best thing about its name.</p>
<p>If we've grasped the concept of <a href="#project-layout">project layout</a> above, we've done routing in Webflo, basically. What we will now cover is orchestrating routes along the request/response flow.</p>
<p>In Webflo, we can implement routing at <em>vertical layers</em> between the client and the server. And in a routing layer, we can lay out route handlers in <em>horizontal steps</em> for URL paths of more than one level (e.g <code>/a/b/c</code>).</p>
<ul>
<li><a href="#vertical-routing-layers">Vertical Routing Layers</a></li>
<li><a href="#horizontal-routing-steps">Horizontal Routing Steps</a></li>
<li><a href="#route-handlers">Route Handlers</a></li>
</ul>
<h2 id="vertical-routing-layers">Vertical Routing Layers</h2>
<p>Each directory discussed in the <a href="#project-layout">Project Layout</a> section above lives at a point on a vertical path between the client and the server. Here's that layout now in the order of request/response flow.</p>
<ul>
<li>-&gt; enter <code>/client</code> if exists; continue?</li>
<li>-&gt; enter <code>/worker</code> if exists; continue?</li>
<li>-&gt; enter <code>/server</code> if exists; continue?</li>
<li>-&gt; enter <code>/public</code> if exists; match a static file.</li>
</ul>
<p>As seen in the <a href="#project-layout">Project Layout</a> section above, the type of application you're building will determine where you choose to implement routing. It could be just client-side routing, just server-side routing or fullstack routing in any combination of it, as we will see soon.</p>
<h2 id="horizontal-routing-steps">Horizontal Routing Steps</h2>
<p>In a routing directory, we can lay out route handlers in a way that represents the structure of the URLs that they will handle. If we chose to do routing in the <code>/server</code> directory, for a example, we would place a route handler at <code>/server/index.js</code> to handle the request URL <code>/</code>, and a route handler at <code>/server/products/index.js</code> to handle the request URL <code>/products</code>, and so on. So, each level of an URL path (e.g <code>/a/b/c</code>) is a place to implement a route handler.</p>
<p>But in Webflo, requests are processed in steps along an URL path, that is, are made to <em>flow</em> through every handler in the route path until it hits the final handler. Here, the request URL <code>/products</code> would actually flow like this:</p>
<ul>
<li>-&gt; enter <code>/server</code><ul>
<li>-&gt; call <code>/index.js</code>; continue?</li>
<li>-&gt; enter <code>/products</code><ul>
<li>-&gt; call <code>/index.js</code>; return response.</li></ul></li></ul></li>
</ul>
<p>This is called <em>step routing</em>, and its the most-empowering way to orchestrate routes. </p>
<h2 id="route-handlers">Route Handlers</h2>
<p>Route handlers are <code>index.js</code> files that are laid out in the routing directory to handle the application's request/response flow. The most important content of these files are a simple function that is exported as the <em>default export</em> of the file.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flo, received, next</span>) </span>{
}</code></pre>
<p>This function is what is called when a request flow hits a route.</p>
<p>Of the three parameters of a route handler, the <code>next</code> parameter is what it uses to forward a request, if it chooses to. This is the concept of flow control.</p>
<h2 id="flow-control">Flow Control</h2>
<p>Given the following route hierarchy…</p>
<ul>
<li><code>/server</code><ul>
<li><code>/index.js</code></li>
<li><code>/products</code><ul>
<li><code>/index.js</code></li></ul></li></ul></li>
</ul>
<p>Here is how our route handlers could look:</p>
<p><code>file: /server/index.js</code></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">process, received, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.pathname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>, };
}</code></pre>
<p><code>file: /server/products/index.js</code></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">process, received, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.pathname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Our Products&#x27;</span>, };
}</code></pre>
<p>In the first handler, we started by asking if the route path has another step ahead. For a path like <code>/products</code>, the answer is yes, and the flow is forwarded to the next handler in the path.</p>
<p>In the second handler, we again started by asking if the route path has another step ahead. This time, the answer is no, and <em>reponse data</em> is returned here for the request.</p>
<p>Flow control is especially important for root-level handlers, i.e handlers that handle the application's root URL <code>/</code>, since they act as the <em>gateway</em> to all of the application's routes - both static and dynamic routes.</p>
<p>Given the following layout…</p>
<ul>
<li><code>/server</code><ul>
<li><code>/index.js</code></li></ul></li>
<li><code>/public</code><ul>
<li><code>/index.html</code></li>
<li><code>/assets</code><ul>
<li><code>/main.css</code></li></ul></li></ul></li>
</ul>
<p>The request URL <code>/index.html</code> would flow this way:</p>
<ul>
<li>-&gt; enter <code>/server</code><ul>
<li>-&gt; call <code>/index.js</code>; continue? Yes! (test <code>next.pathname</code>: <code>'index.html'</code>; then <code>next()</code>)</li></ul></li>
<li>-&gt; enter <code>/public</code>; match <code>index.html</code></li>
</ul>
<p>While, the client request URL <code>/</code> would flow this way:</p>
<ul>
<li>-&gt; enter <code>/server</code><ul>
<li>-&gt; call <code>/index.js</code>; continue? No! (test <code>next.pathname</code>: <code>''</code>; return <code>{ title: 'Hello World', }</code>)</li></ul></li>
</ul>
<p>This way, <em>static file URLs</em> are properly allowed at this critical point in the application's URL-handling. Also noteworthy is that the <em>static file URL</em>  <code>/index.html</code> is still handled differently from the <em>path URL</em> <code>/</code>. Thanks to <code>next.pathname</code> and <code>next()</code>.</p>
<blockquote>
  <p>As we would expect, if we had no route handlers intercepting the request, both URLs - <code>/index.html</code> and <code>/</code> - would be mapping directly to <code>/public/index.html</code>.</p>
</blockquote>
<blockquote>
  <p>Try figuring out on your own the flow for the URL <code>/assets/main.css</code>.</p>
</blockquote>
<p>As a general rule, it is good to always use <code>next.pathname</code>and <code>next()</code> to properly manage the flow, even when writing the last handler for a given route hierarchy. There are many important advantages to this:</p>
<ul>
<li><p>Given an earlier example, while the last handler in our route hierarchy is designed for the URL <code>/products</code>, our flow control code in there would make an unexpected, extended URL like <code>/products/specials</code> trigger the <code>next()</code> function; and since nothing like that really exists ahead, an empty respone would be returned, which Webflo gracefully translates into a <code>404</code> HTTP response. Without that check in place, an invalid URL would be returning a <em>falsely-valid</em> response.</p></li>
<li><p>Furthermore, if, or when, we do eventually place a handler there for that level of the route path, our flow control code in the current handler would have already ensured that requests can flow through to the new level.</p></li>
<li><p>Or, where another routing layer exists below the given routing layer, our flow control code in this last handler for the route would be forwarding those requests to the next layer.</p>
<p>In the layout below, the request URL <code>/products/specials</code> that is non-existent in the upper routing layer is actually existent in the lower routing layer.</p>
<ul>
<li><code>/server</code><ul>
<li><code>/index.js</code></li>
<li><code>/products</code><ul>
<li><code>/index.js</code></li></ul></li></ul></li>
<li><code>/public</code><ul>
<li><code>/products</code><ul>
<li><code>/specials</code><ul>
<li><code>/index.html</code></li></ul></li></ul></li></ul></li></ul>
<p>Calling <code>next()</code> at the last handler for the URL will forward the flow off the <code>/server</code> routing layer into the <code>/public</code> routing layer, and the HTML file is served for the URL.</p>
<p>Here is how that would flow:</p>
<ul>
<li>-&gt; enter <code>/server</code><ul>
<li>-&gt; call <code>/index.js</code>; continue? Yes! (test <code>next.pathname</code>: <code>'products/specials/index.html'</code>; then <code>next()</code>)</li>
<li>-&gt; enter <code>/products</code><ul>
<li>-&gt; call <code>/index.js</code>; continue? Yes! (test <code>next.pathname</code>: <code>'specials/index.html'</code>; then <code>next()</code>)</li></ul></li></ul></li>
<li>-&gt; enter <code>/public</code>; match <code>products/specials/index.html</code></li></ul>
<blockquote>
  <p>A side benefit we've enjoyed with this <code>products/specials</code> URL is the convenience of having it begin life as a static route until we can make it dynamic by creating a route handler for it.</p>
</blockquote></li>
</ul>
<h3 id="parameter-passing">Parameter Passing</h3>
<p>While being used to forward a request, the <code>next()</code> function can help to pass on anything to the next handler.</p>
<p><code>file: /server/index.js</code></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">process, received, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.pathname) {
        <span class="hljs-keyword">return</span> next({ <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> });
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>, };
}</code></pre>
<p><code>file: /server/products/index.js</code></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">process, received, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.pathname) {
        <span class="hljs-keyword">return</span> next(received);
    }
    <span class="hljs-keyword">if</span> (received.userId) {
        <span class="hljs-comment">// Show recommended products</span>
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Recommended Products For You&#x27;</span>, };
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Our Products&#x27;</span>, };
}</code></pre>
<p>In the first handler, we passed an object via the <code>next()</code> function. In the second handler, we received it on the <code>received</code> parameter.</p>
<p>Parameter passing is a great way to implement one source of truth for subsequent handlers in the route hierarchy. Think authentication, certain database or external API queries, etc. Doing these at the earliest level in the route hierarchy and passing tokens or objects down is a perfect way to avoid repeating code down the hierarchy.</p>
<h3 id="the-process-object">The <code>process</code> Object</h3>
<p>When called, route handlers recieve very useful information about the ongoing HTTP process. This and a few other metadata are passed together as an object into the first parameter of the handler - the <code>process</code> parameter.</p>

		</div>

		<div exportgroup="readme">

			<h1 id="webflo-documentation">Webflo Documentation</h1>
<p>Welcome to the Webflo documentation. We hope you find it easy to understand and navigate.</p>
<p>If you have questions about anything related to the Webflo, you're always welcome to ask on our <a href="https://github.com/webqit/webflo/discussions">GitHub Discussions</a>.</p>
<h2 id="explore-the-docs">Explore the Docs</h2>

		</div>

		<template name="api">
			<template name="IncomingRequest">
				<div exportgroup="readme">

					<h1 id="interface-incomingrequest-"><code>interface IncomingRequest {}</code></h1>
<p>This is an interface that is additionally implemented by the incoming request instances that route handlers receive via <code>event.request</code>. (Client-side <code>event.request</code> objects are an instance of the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> interface. Server-side <code>event.request</code> objects are an instance of node.js's <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> class.)</p>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>cookies: Object</code></strong> - An object representing the request <em>cookies</em>. This is an object model of the submitted cookies. Cookie names in path notation are written to their equivalent path in the object. For example, the cookie <code>q7[sublevel1]=deepvalue</code> will be accessed as <code>event.request.cookies.q7.sublevel1</code>;</li>
<li><strong><code>accepts: Object</code></strong> - (Available only in server-side instances.) An <em>accepts</em> object for the request as returned by <a href="https://www.npmjs.com/package/accepts">Accepts</a>.</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li><p><strong><code>parse(): &lt;Promise&gt;Object</code></strong> - This returns a promise that resolves to the request payload.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> submits = <span class="hljs-keyword">await</span> event.request.parse();</code></pre>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>submits: Object</code></strong> - The parsed request data. <em>(See <a href="#submits">Submits</a> below.)</em></li></ul></li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<ul>
<li><em>For client-side <code>event.request</code> objects, see the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> interface.</em></li>
<li><em>For server-side <code>event.request</code> objects, see node.js's <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> class.</em></li>
</ul>
<h2 id="submits">Submits</h2>
<p>This is the object returned by <code>await event.request.parse()</code>, containing the below details of the request payload.</p>
<ul>
<li><strong>type: String</strong> - The content type of the request payload, based on the <code>Content-Type</code> header of the request. This would be <code>form-data</code> for <code>Content-Type === 'application/x-www-form-urlencoded'</code> or <code>Content-Type === 'multipart/form-data'</code>, <code>json</code> for <code>Content-Type === 'application/json'</code>, <code>plain</code> for <code>Content-Type === 'text/plain'</code>, <code>other</code> for other <code>Content-Type</code> values.</li>
<li><strong>payload: Any</strong> - The parsed contents of the request body. This would be <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> for <code>submits.type === 'form-data'</code>, JSON (object, array, or primitive) for <code>submits.type === 'json'</code>, plain text for <code>submits.type === 'text'</code>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> for <code>submits.type === 'other'</code>.</li>
<li><strong>inputs: Object</strong> - An object representing the request <em>inputs</em>, as taken from <code>submits.payload</code>, where <code>submits.payload</code> is <code>FormData</code> or where <code>submits.payload</code> is a JSON object or array.</li>
<li><strong>files: Object</strong> - An object representing the uploaded <em>files</em>, as taken from <code>submits.payload</code>, where <code>submits.payload</code> is <code>FormData</code>.</li>
</ul>
<p>The <code>inputs</code> and <code>files</code> properties above are object models of the submitted fields. Field names in path notation are written to their equivalent path in the object.</p>
<p>The fields below…</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user[profile][visibility]&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;public&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user[profile][pics][]&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">multiple</span> /&gt;</span></code></pre>
<p>…will be accessed in the application as:</p>
<pre><code class="hljs js language-js">lat payload = <span class="hljs-keyword">await</span> event.request.parse();
<span class="hljs-keyword">let</span> profileVisibility = submits.inputs.user.profile.visibility;
<span class="hljs-keyword">let</span> profilePics = submits.files.user.profile.pics;</code></pre>

				</div>
			</template>

			<template name="NavigationEvent">
				<div exportgroup="readme">

					<h1 id="class-navigationevent-"><code>class NavigationEvent {}</code></h1>
<p>This is the <code>NavigationEvent</code> that is fired on every request which route handlers receive on their <code>event</code> parameter.</p>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>url: URLX</code></strong> - An object representing the request URL. <em>(See class <a href="/tooling/webflo/docs/api/URLX"><code>URLX</code></a>.)</em></li>
<li><strong><code>request: IncomingRequest</code></strong> - The incoming request object. <em>(See interface <a href="/tooling/webflo/docs/api/IncomingRequest"><code>IncomingRequest</code></a>.)</em> On the client side, this would be an extended instance of the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> interface. On the server side, this would be an extended instance of node.js's <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> class.</li>
<li><strong><code>Response: Class</code></strong> - A <em>class</em> for instantiating a new reponse. <em>(See class <a href="/tooling/webflo/docs/api/event_Response"><code>event.Response</code></a>.)</em></li>
</ul>

				</div>
			</template>

			<div exportgroup="readme">

				<h1 id="api">API</h1>
<p>The Webflo API reference.</p>

			</div>

			<template name="URLX">
				<div exportgroup="readme">

					<h1 id="class-urlx-"><code>class URLX {}</code></h1>
<p>This is an interface that is additionally implemented by the request URL objects that route handlers receive via <code>event.url</code>. (Both client-side and server-side <code>event.url</code> objects are instances of the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><code>URL</code></a> interface.)</p>
<h2 id="properties">Properties</h2>
<ul>
<li><p><strong><code>query: Object</code></strong> - An object model of the URL query parameters. This maintains a live, two-way relationship between itself and the <code>.search</code> string property of its base URL object. Changes made on one end are automatically reflected on the other.</p>
<p><strong>Case:</strong></p>
<blockquote>
  <p><em><code>event.url.href</code>: <code>https://example.com/path?q1=value1&amp;q2=value2</code></em></p>
</blockquote>
<p><em>Modify the query string:</em></p>
<pre><code class="hljs js language-js">event.url.search += <span class="hljs-string">&#x27;&amp;q3=value3&#x27;</span>;
<span class="hljs-built_in">console</span>.log(event.url.query);
<span class="hljs-comment">// { q1: &#x27;value1&#x27;, q2: &#x27;value2&#x27;, q3: &#x27;value3&#x27; }</span></code></pre>
<p><em>Replace the query object:</em></p>
<pre><code class="hljs js language-js">event.url.query += { <span class="hljs-attr">q4</span>: <span class="hljs-string">&#x27;value4&#x27;</span>, <span class="hljs-attr">q5</span>: <span class="hljs-string">&#x27;value5&#x27;</span>, };
<span class="hljs-built_in">console</span>.log(event.url.search);
<span class="hljs-comment">// ?q4=value4&amp;q5=value5</span></code></pre>
<p><em>Modify the query object in-place:</em></p>
<pre><code class="hljs js language-js">event.url.query.q6 = <span class="hljs-string">&#x27;value6&#x27;</span>;
<span class="hljs-keyword">delete</span> event.url.query.q4;
<span class="hljs-built_in">console</span>.log(event.url.search);
<span class="hljs-comment">// ?q5=value5&amp;q6=value6</span></code></pre>
<p>Additionally, query parameter names in path notation are written to their equivalent path in the object model.</p>
<p><strong>Case:</strong></p>
<blockquote>
  <p><em><code>event.url.href</code>: <code>https://example.com/path</code></em></p>
</blockquote>
<p><em>Set an path parameter that resolves to an object:</em></p>
<pre><code class="hljs js language-js">event.url.search = <span class="hljs-string">&#x27;q7[sublevel1][sublevel2]=deepvalue&#x27;</span>;
<span class="hljs-built_in">console</span>.log(event.url.query);
<span class="hljs-comment">// { q7: { sublevel1: { sublevel2: &#x27;deepvalue&#x27; } } }</span></code></pre>
<p><em>Set an path parameter that resolves to an array:</em></p>
<pre><code class="hljs js language-js">event.url.search = <span class="hljs-string">&#x27;q7[sublevel1][sublevel2][]=deepvalue&#x27;</span>;
<span class="hljs-built_in">console</span>.log(event.url.query);
<span class="hljs-comment">// { q7: { sublevel1: { sublevel2: [ &#x27;deepvalue&#x27; ] } } }</span></code></pre></li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<ul>
<li><em>See the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><code>URL</code></a> interface.</em></li>
</ul>

				</div>
			</template>

			<template name="event_Response">
				<div exportgroup="readme">

					<h1 id="class-eventresponse-"><code>class event.Response {}</code></h1>
<p>This class is used for returning responses from route handlers. It is available to route handlers via the <code>event.Response</code> parameter.</p>
<p>Returning responses with this class allows a handler to include an HTTP status code and some HTTP headers.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> event.Response({
        <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, },
        <span class="hljs-attr">body</span>: { <span class="hljs-attr">prop1</span>: value1, }
    });
}</code></pre>
<p>But in many cases, creating an <code>event.Response</code> instance will not be necessary as Webflo will dynamically figure out an appropriate HTTP status code along with a <code>Content-Type</code> header for the response as detailed in: <a href="/tooling/webflo/docs/fundamentals/requests-and-responses#api-calls-and-page-requests">API Calls and Page Requests</a>. Here, returning the plain data object will just suffice.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">prop1</span>: value1, };
}</code></pre>
<blockquote>
  <p>With the first handler above returning a <code>Content-Type</code> header, no automatic content negotiation will be made by Webflo.</p>
</blockquote>
<h2 id="properties">Properties</h2>
<ul>
<li><strong><code>query: Object</code></strong> - An object model of the URL query parameters. This maintains a live, two-way relationship between itself and the <code>.search</code> string property of its base URL object. Changes made on one end are automatically reflected on the other.</li>
</ul>
<h2 id="header-shortcuts">Header Shortcuts</h2>
<h3 id="content-type">Content-Type</h3>
<h3 id="redirect">Redirect</h3>
<h3 id="cache-control">Cache-Control</h3>
<h3 id="cookies">Cookies</h3>
<h3 id="cross-origin-requests-cors">Cross-Origin Requests (CORs)</h3>

				</div>
			</template>
		</template>

		<template name="cli">
			<div exportgroup="readme">

				<h1 id="command-line">Command Line</h1>
<p>The Play UI command-line tool.</p>

			</div>

			<template name="bundle">
				<div exportgroup="readme">

					<h1 id="-playui-bundle"><code>$ playui bundle</code></h1>
<p>The <strong><code>playui bundle</code></strong> command is used to automatically bundle static HTML files from the filesystem into <em><a href="/tooling/oohtml/docs/getting-started/overview#html-modules">HTML Modules</a></em>.</p>
<h2 id="overview">Overview</h2>
<p>Here, each directory will represent a <em>module</em> element and the files within it will be the module's exports. We will take the following directory structure as an example:</p>
<pre><code class="hljs html language-html">project-root
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>The goal is to translate the above layout into the following <em>module</em> structure and get it written to a single file that can be linked to:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;views&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p><em>file: <code>./bundle.html</code></em></p>
<p>You can find a working example of <a href="/tooling/oohtml/docs/learn/examples/spa">a typical module structure</a> right at OOHTML's documentation.</p>
<p>Now, on getting the files into a single bundle, we would next link to it as a remote content for a <code>&lt;template&gt;</code> element - the actual module element - in the main document.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

  <span class="hljs-comment">&lt;!--
  Here, we link to the remote content
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bundle.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-comment">&lt;!--
  Here our application router would be dynamically pointing to either &quot;home&quot; or &quot;about&quot;
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">template</span>=<span class="hljs-string">&quot;main/views/about&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>That said, lets go on to bundle.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui bundle</code></strong></p>
</blockquote>
<p>Navigate to <code>project-root</code> and run <strong><code>playui bundle</code></strong>. Two files should be reported bundled. </p>
<p><html-import name="playui-bundle-1" template="page/tooling/play-ui/docs/cli/bundle"></html-import></p>
<p>Remote content is now ready at <code>./bundle.html</code>!</p>
<p>Now, beyond this point are so many other things we can do! And here is where a few configurations come in!</p>
<p>Run <strong><code>playui config bundler</code></strong> to walk down the options.</p>
<blockquote>
  <p>On completing the options below, the <strong><a href="/tooling/webflo/docs/cli/config"><code>playui config</code></a></strong> command will save the configurations to a JSON file at <code>./.webqit/playui-cli/config/bundler.json</code>. Subsequent calls to <strong><code>playui bundle</code></strong> will be based on the saved configurations. And subsequent calls to <strong><code>playui config bundler</code></strong> will pull up the saved configurations for update.</p>
</blockquote>
<h3 id="options">Options</h3>
<h4 id="entry_dir"><code>[ENTRY_DIR]</code></h4>
<p>This specifies the entry point into the filesystem - the <em>source directory</em>. The default value is <code>./</code>, which resolves to the current working directory (CWD) on the terminal.</p>
<p>This is good for pointing the bundler to the actual <em>views (or equivalent)</em> folder in the project directory. E.g. <code>./views</code>. (An absolute path may also be used.)</p>
<p>To specify multiple entry directories, slot in the exact string <code>[name]</code> as a placeholder on a segment in the path. Bundler will loop through all folders at that level in the directory to resolve the placeholder and obtain a final path. Specifying <code>./views/[name]</code> as the entry directory, for example, will equate to running <strong><code>playui bundle</code></strong> on both <code>./views/about</code> and <code>./views/home</code>.</p>
<h4 id="output_file"><code>[OUTPUT_FILE]</code></h4>
<p>This specifies the file name of the output bundle. The default value is <code>./bundle.html</code>, which is resolved relative to <a href="#entry_dir"><code>[ENTRY_DIR]</code></a>.</p>
<p>This is good for directing the output bundle to the actual <em>public (or equivalent)</em> folder of the application. E.g. <code>./public/bundle.html</code>. (An absolute path may also be used.)</p>
<p>Where multiple source directories are specified in the <a href="#entry_dir"><code>[ENTRY_DIR]</code></a> option above, this option will require a <code>[name]</code> placeholder, this time, to specify a unique output file each for the source directories. Specifying <code>./public/[name].bundle.html</code> as the output file, for example, will equate to saving the output bundle of <code>./views/about</code> to <code>./public/about.bundle.html</code>, and the output bundle of <code>./views/home</code> to <code>./public/home.bundle.html</code>.</p>
<h4 id="assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></h4>
<p>This specifies the output directory for images or other assets bundled from the source directory. (See <a href="#bundling-assets">Bundling Assets</a> below.) The default value is <code>./</code>, which is resolved relative to <a href="#entry_dir"><code>[ENTRY_DIR]</code></a>, and which means assets will not be copied to any new location. If set to <em>empty</em>, the same directory as <a href="#output_file"><code>[OUTPUT_FILE]</code></a>'s is used.</p>
<p>This is good for directing assets like images to the actual place in the <em>public (or equivalent)</em> folder of the application. E.g. <code>./public/assets</code>. (An absolute path may also be used.)</p>
<p>This option supports the same <code>[name]</code> placeholder as used in the <a href="#entry_dir"><code>[ENTRY_DIR]</code></a> option, this time, to specify a unique <em>assets storage</em> directory each for the source directories. Specifying <code>./public/assets/[name]</code> as the <em>assets storage</em> path, for example, will equate to saving the assets bundled at <code>./views/about</code> to <code>./public/assets/about</code>, and the assets bundled at <code>./views/home</code> to <code>./public/assets/home</code>.</p>
<h4 id="assets_public_base"><code>[ASSETS_PUBLIC_BASE]</code></h4>
<p>This specifies the HTTP path that maps to <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> in the filesystem. The default value is <code>/</code>, which is assumed to map to the <em>public (or equivalent)</em> folder of the application. The <em><code>src</code> (or equivalent)</em> attribute of every asset bundled will be prefixed with this path.</p>
<p>This is good for aligning the public path for assets with the internal <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> path. E.g. <code>/assets</code>, where <code>[ASSETS_STORAGE_BASE]</code> had been set to <code>./public/assets</code>.</p>
<h4 id="max_data_url_size"><code>[MAX_DATA_URL_SIZE]</code></h4>
<p>This specifies the upper limit of the file size under which to inline the contents of an image file or other asset as <em><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">data URLs</a></em>. (See <a href="#bundling-assets">Bundling Assets</a> below.) The default value is <code>1024</code>, in bytes. Assets smaller than this size will be bundled with <em>data URLs</em>.</p>
<p>This is good for having small image files embed their own content instead of having them create additional HTTP requests on the page.</p>
<h4 id="loaders"><code>[LOADERS]</code></h4>
<p>This specifies an optional list of loaders for the bundling operation. (See <a href="/tooling/webflo/docs/cli/bundle/loaders">Loaders</a>.) The default value is an empty object <code>{}</code>.</p>
<p>This is good for extending the capabilities of the bundler to custom-load certain file formats that are not natively provided for.</p>
<p>Skip where not apply. Or follow the prompt to interactively specify loaders, optionally along with their arguments or flags. The following options are presented recursively:</p>
<ul>
<li><p><strong><code>[name]</code></strong> - The path to a function, or the name of an installed npm package, that is a <a href="/tooling/webflo/docs/cli/bundle/loaders">Play UI loader</a>. (The bundler imports loaders using the ES6 <code>import()</code> syntax.)</p>
<p>To refer to the bundler's <a href="/tooling/webflo/docs/cli/bundle/loaders#built-ins">built-in loaders</a>, like the markdown-to-HTML loader (<a href="/tooling/webflo/docs/cli/bundle/loaders#md-loader"><code>md-loader</code></a>), simply add the prefix <code>default:</code> to the loader's bare name. E.g. <code>default:md-loader</code>.</p></li>
<li><p><strong><code>[args]</code></strong> - Optional list of parameters (arguments/flags) for a loader - each in name/value pair.</p>
<p>Skip where not apply. Or follow the prompt to interactively specify parameters. The following options are presented recursively:</p>
<ul>
<li><strong><code>[name]</code></strong> - The name of the parameter as required by a loader. E.g. <code>flavor</code> - in the default <a href="/tooling/webflo/docs/cli/bundle/loaders#md-loader"><code>md-loader</code></a>.</li>
<li><strong><code>[value]</code></strong> - The value of the parameter. E.g. <code>github</code> - for the <code>flavor</code> parameter above.</li></ul></li>
</ul>
<h3 id="advanced-options">Advanced Options</h3>
<h4 id="ignore_folders_by_prefix"><code>[IGNORE_FOLDERS_BY_PREFIX]</code></h4>
<p>This specifies a comma-separated list of prefixes for certain types of folders to ignore. Folders with a name that begins with any of the listed prefixes are ingnored. The default value is an array of one prefix: dot <code>.</code>.</p>
<p>This is good for excluding certain system folders or <em>dot directories</em> like <code>.git</code>. <em>Dot directories</em> are automatically excluded by the default value.</p>
<h4 id="create_outline_file"><code>[CREATE_OUTLINE_FILE]</code></h4>
<p>This specifies whether or not to generate a JSON outline of the bundle. The default value is <code>create</code>. The generated file is named after <a href="#output_file"><code>[OUTPUT_FILE]</code></a>; e.g. <code>./bundle.html.json</code>. Set to <code>create_merge</code> to merge the generated JSON outline with any previously generated one. Set to <em>empty</em> to disable outline generation.</p>
<p>This is good for programmatically traversing the module tree. Simply <code>JSON.parse()</code> the contents of <code>./bundle.html.json</code>.</p>
<h3 id="oohtml-related-options">OOHTML-Related Options</h3>
<h4 id="module_ext"><code>[MODULE_EXT]</code></h4>
<p>This specifies an extended tag name for the module element. This value will be set to the <code>is</code> attribute of the <code>&lt;template&gt;</code> elements generated by the bundler. The is empty by default.</p>
<p>This is good for automatically extending generated <code>&lt;template&gt;</code> elements. A value like <code>special-module</code> will generate <code>&lt;template is="special-module"&gt;&lt;/template&gt;</code> elements. Be sure to take into account the <code>element.template</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<h4 id="module_id_attr"><code>[MODULE_ID_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>module ID</em>. The default value is <code>name</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default module ID attribute</a> in the OOHTML spec.</p>
<p>This should generally only be changed to align with the <code>attr.moduleid</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<h4 id="export_mode"><code>[EXPORT_MODE]</code></h4>
<p>This specifies the syntax for designating the <em>module exports</em> within the generated <code>&lt;template&gt;</code> elements. The default value is <code>attribute</code> which translates to using the <code>exportgroup</code> attribute (or <a href="#export_group_attr"><code>[EXPORT_GROUP_ATTR]</code></a>) to designate <em>module exports</em>. Set to <code>element</code> to use the <code>&lt;export&gt;</code> element (or <a href="#export_element"><code>[EXPORT_ELEMENT]</code></a>) instead.  (See <a href="/tooling/oohtml/docs/spec/html-modules#convention">the two standard convetions</a>.)</p>
<h4 id="export_group_attr"><code>[EXPORT_GROUP_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>export ID</em> in <a href="#export_mode">attribute mode</a>. The default value is <code>exportgroup</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;div exportgroup="export-id"&gt;&lt;/div&gt;</code>.</p>
<p>This should generally only be changed to align with the <code>attr.exportgroup</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>attribute</code>.</p>
</blockquote>
<h4 id="export_element"><code>[EXPORT_ELEMENT]</code></h4>
<p>This specifies the tag name for designating <em>module exports</em> in <a href="#export_mode">element mode</a>. The default value is <code>export</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;export&gt; &lt;div&gt;&lt;/div&gt; &lt;/export&gt;</code></p>
<p>This should generally only be changed to align with the <code>element.export</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>element</code>.</p>
</blockquote>
<h4 id="export_id_attr"><code>[EXPORT_ID_ATTR]</code></h4>
<p>This specifies the attribute name for designating the <em>export ID</em> in <a href="#export_mode">element mode</a>. The default value is <code>name</code> which conforms to <a href="/tooling/oohtml/docs/spec/html-modules#convention">the default syntax</a> in the OOHTML spec. E.g. <code>&lt;export name="export-id"&gt; &lt;div&gt;&lt;/div&gt; &lt;/export&gt;</code></p>
<p>This should generally only be changed to align with the <code>element.export</code> setting in the <a href="/tooling/oohtml/docs/spec/html-modules#polyfill-support">OOHTML meta tag</a> of the page where the bundle will be used.</p>
<blockquote>
  <p>This option is only shown when the <a href="#export_mode">export mode</a> option is set to <code>element</code>.</p>
</blockquote>
<h2 id="bundling-assets">Bundling Assets</h2>
<p>While HTML modules are created by reading the file's contents, assets, like images, are handled differently. These files are copied from their location into the <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> directory to make them accessible to HTTP requests. An appropriate HTML element that points to this new location is automatically generated as the <em>module export</em> in the bundle. This is illustrated below.</p>
<p>We have an image file at <code>project-root/assets/img</code> and we have set the <a href="#assets_storage_base"><code>[ASSETS_STORAGE_BASE]</code></a> to <code>./public</code>, and the <a href="#output_file"><code>[OUTPUT_FILE]</code></a> option to <code>./public</code>.</p>
<pre><code class="hljs html language-html">project-root
  │
  ├-- assets
  │ ├-- img
  │   ├-- image1.png
  │
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>On running the <strong><code>playui bundle</code></strong> command, our final directory structure will be…</p>
<pre><code class="hljs html language-html">project-root
  │
  ├-- assets
  │ ├-- img
  │   ├-- image1.png
  │
  ├-- public
  │ ├-- assets
  │ │ ├-- img
  │ │   ├-- image1.png
  │ │
  │ ├-- bundle.html
  │
  ├-- views
    ├-- about
    │ ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    ├-- home
      ├-- index.html <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>…and an <code>&lt;img&gt;</code> element pointing to the <em>public</em> location of <code>image1.png</code> is added as a <em>module export</em> to the bundle.</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;assets&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;img&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;image1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/assets/img/image1.png&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;views&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-container&quot;</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>
<p>Taking things further, it is possible to bundle small images (or other assets) with inline <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">data URLs</a>. This way, the browser won't have to load them via HTTP request. Cutting down on the number of assets to load should greatly speed up the site's load time.</p>
<p>The Bundler just needs to know under what file size to use the <em>data-URL</em> format. Set the <a href="#max_data_url_size"><code>[MAX_DATA_URL_SIZE]</code></a> option to a size measured in bytes. E.g. <code>2048</code>. Assets below this size will now be bundled in <em>data-URL</em> format.</p>
<p>In the case of <code>image1.png</code> above, the generated <em>module export</em> would look like:</p>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">exportgroup</span>=<span class="hljs-string">&quot;image1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/png,%89PNG%0D%0A=&quot;</span> /&gt;</span></code></pre>
<h2 id="further-reading">Further Reading</h2>

				</div>

				<template name="loaders">
					<div exportgroup="readme">

						<h1 id="loaders">Loaders</h1>
<p>Play UI loaders are packages that extend the capabilities of the OOHTML Bundler. Play UI comes with certain loaders built-in and also makes it possible to provide custom loaders.</p>
<h2 id="overview">Overview</h2>
<p>Loaders are functions that are called with each file during the bundling process. Multiple loaders are made cascaded and a loader will be expected to call the next. This makes for an awesome processing pipeline for each file being bundled. But it also requires thoughtfulness in the order in which these loaders are specified.</p>
<p>By default, the main Play UI bundler only handles <code>.html</code> files and images (<code>.ico</code>, <code>.png</code>, <code>.jpg</code>, <code>.jpeg</code>, <code>.svg</code>). Then it features built-in loaders that extend the list.</p>
<h2 id="built-ins">Built-Ins</h2>
<h3 id="md-loader"><code>md-loader</code></h3>
<p>The <code>md-loader</code> loader is used to load <code>.md</code> (markdown) files into HTML exports just the way regular HTML files are. It takes an initial step of converting the markdown content into HTML using the <a href="https://github.com/showdownjs/showdown">Showdown</a> library, then goes ahead to add it to the bundle as a <em>module export</em>. Markdown links are automatically resolved to better work as HTML links. A few other transformations are supported through arguments/flags. (Learn more about specifying arguments/flags for a loader <a href="/tooling/webflo/docs/cli/bundle/#loaders">here</a>.)</p>
<h4 id="argumentsflags">Arguments/Flags</h4>
<p>All parameters are optional.</p>
<ul>
<li><strong><code>base_url</code></strong> - Set this to a value that will be used as the base URL for relative links. This is similar to how the <a href="/tooling/webflo/docs/cli/bundle/#assets_public_base"><code>[ASSETS_PUBLIC_BASE]</code></a> option works.</li>
<li><strong><code>outline_generation</code></strong> - Set this to a <em>non-empty</em> value to generate a JSON outline of the page's content. The generated outline will show up in the meta data for the file in the bundle's overall <a href="/tooling/webflo/docs/cli/bundle/#create_outline_file">JSON outline</a>.</li>
<li><strong><code>code_highlighting</code></strong> - Set this to a <em>non-empty</em> value to transform code blocks into stylable markup using the <a href="https://github.com/Bloggify/showdown-highlight">Showdown-Highlight</a> utility. The transformed code blocks are highlighted in the UI on adding any of the <a href="https://highlightjs.org/">Highlight.js</a> CSS to the page.</li>
<li><strong><code>flavor</code></strong> - This equates to any of <a href="https://github.com/showdownjs/showdown#flavors">Showdown's three flavours</a>: <code>original</code>, <code>vanilla</code>, <code>github</code>.</li>
</ul>
<h4 id="other">Other</h4>
<ul>
<li><strong>Markdown Metadata</strong> - By default, <code>md-loader</code> automatically parses any found markdown metadata (defined at the top of the document between ««« and »»» or between --- and ---) into JSON and this will show up in the meta data for the file in the bundle's overall <a href="/tooling/webflo/docs/cli/bundle/#create_outline_file">JSON outline</a>. Below is an example metadata:</li>
</ul>
<pre><code class="hljs md language-md">  ---
  description: Page description.
  ---
  # Page Title</code></pre>
<ul>
<li><strong>Markdown Tables</strong> - The markdown table syntax is supported by default. Below is an example table:</li>
</ul>
<pre><code class="hljs md language-md">  | h1    |    h2   |      h3 |
  |:------|:-------:|--------:|
  | 100   | [<span class="hljs-string">a</span>][<span class="hljs-symbol">1</span>]  | ![<span class="hljs-string">b</span>][<span class="hljs-symbol">2</span>] |
  | <span class="hljs-emphasis">*foo*</span> | <span class="hljs-strong">**bar**</span> | ~~baz~~ |</code></pre>
<h4 id="usage">Usage</h4>
<p>The <code>md-loader</code> loader is used by specifying <code>default:md-loader</code> in the <a href="/tooling/webflo/docs/cli/bundle/#loaders"><code>[LOADERS]</code></a> config option.</p>
<h2 id="custom-loaders">Custom Loaders</h2>
<p>Custom Loaders are easy to develop. They are basic functions that recieve the current file being processed along with a few paramters, to return a fully-formed <em>module export</em> markup.</p>
<h3 id="syntax">Syntax</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadsCSS</span>(<span class="hljs-params">resource, params, args, received, meta, next</span>) </span>{
  <span class="hljs-keyword">if</span> (received || !resource.endsWith(<span class="hljs-string">&#x27;.css&#x27;</span>)) {
      <span class="hljs-comment">// Or let the flow continue</span>
      <span class="hljs-keyword">return</span> next(received);
  }
  <span class="hljs-comment">// Return a module export format</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;style exportgroup=&quot;&quot;&gt;...&lt;/style&gt;&#x27;</span>;
}</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>resource: String</code></strong> - The filename of the resource being processed - relative to the current working directory (CWD).</li>
<li><strong><code>params: Object</code></strong> - The <a href="/tooling/webflo/docs/cli/bundle/#options"><code>options</code> object</a> that the Bundler was initialized with. It also has an additional property <code>indentation</code> - a number which represents how deep in the source directory the given resource is. This number is <code>0</code> at the root of the source directory.</li>
<li><strong><code>args: Object</code></strong> - The <a href="/tooling/webflo/docs/cli/bundle/#loaders"><code>args</code> object</a> defined specifically for the loader.</li>
<li><strong><code>received: String</code></strong> - The output forwarded (that is, <code>next()</code>ed) by the previous loader in the list, if any.</li>
<li><strong><code>meta: Object</code></strong> - The <em>meta</em> object for the given resource. Properties can be added and they will show up in the meta data for the file in the bundle's overall <a href="/tooling/webflo/docs/cli/bundle/#create_outline_file">JSON outline</a>.</li>
<li><strong><code>next: Function</code></strong> - A function that forwards control to the next loader in the list, if any, and if none, to the default internal loader. It accpets only one parameter, which is received by the next loader on its <code>received</code> parameter. (When any value passed this way reaches the internal loader, it is added to the bundle as-is without any further processing of the resource.)</li>
</ul>
<p><strong>Return Value</strong></p>
<p>Loaders are expected to return a valid markup string as the <em>module export</em> for the resource.</p>
<h3 id="error-handling">Error Handling</h3>
<p>Loaders may throw exceptions, they will be gracefully handled, that is, formatted and printed to the console.</p>
<h3 id="usage-1">Usage</h3>
<p>Custom loaders are used by specifying their filename in the <a href="/tooling/webflo/docs/cli/bundle/#loaders"><code>[LOADERS]</code></a> config option. Loaders installed as an npm package are used by specifying their package name.</p>

					</div>
				</template>

				<img src="/html/tooling/webflo/docs/cli/bundle/playui-bundle-1.png"  exportgroup="playui-bundle-1" />
			</template>

			<template name="config">
				<div exportgroup="readme">

					<h1 id="-playui-config"><code>$ playui config</code></h1>
<p>The <strong><code>playui config</code></strong> command is used to configure other Play UI commands or a feature.</p>
<h2 id="overview">Overview</h2>
<p>The <strong><code>playui config</code></strong> command is part of thoughtful strategies to make the developer experience on the command line great. Its sole purpose is to provide an interactive way to configure flags for other commands and to persist such configurations. It is indeed painstaking and error-prone to write commands with a long list of flags each time. The <strong><code>playui config</code></strong> command will eliminate this for you.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui config &lt;command&gt;</code></strong> - where <code>&lt;command&gt;</code> is any of the other <a href="/tooling/webflo/docs/cli">Play UI commands</a>, or the ellipsis <code>...</code>, which lets you pick from a list.</p>
</blockquote>
<p><em>Config</em> will walk you through the configuration options for the specified command and save your configurations for repeat use. (Configurations are generally saved to a JSON file in the project-relative directory: <code>./.webqit/playui-cli/config/</code>, except as otherwise stated in the documentation for a specific command.) Now, subsequent calls to <strong><code>playui config &lt;command&gt;</code></strong> will pull up the saved configurations for update. But, config files may also be updated, or even created, by hand.</p>
<p>To try, run <strong><code>playui config ...</code></strong>, pick a command from the list and follow the prompt. Be sure to consult the documentation for a command to achieve good configurations.</p>

				</div>
			</template>

			<template name="help">
				<div exportgroup="readme">

					<h1 id="-playui-help"><code>$ playui help</code></h1>
<p>The <strong><code>playui help</code></strong> command is used to show available Play UI commands.</p>
<h2 id="overview">Overview</h2>
<p>Remembering things is hard. Run the <strong><code>playui help</code></strong> command anytime to show a list of available commands.</p>
<h2 id="usage">Usage</h2>
<blockquote>
  <p>Syntax: <strong><code>playui help</code></strong>.</p>
</blockquote>
<p><html-import name="playui-help" template="page/tooling/play-ui/docs/cli/help"></html-import></p>
<p>Refer to the documentation of the command you want to use.</p>

				</div>

				<img src="/html/tooling/webflo/docs/cli/help/playui-help.png"  exportgroup="playui-help" />
			</template>
		</template>

		<template name="deployment">
			
		</template>

		<template name="fundamentals">
			<div exportgroup="readme">

				<h1 id="fundamentals">Fundamentals</h1>

			</div>

			<template name="rendering">
				<div exportgroup="readme">

					<h1 id="rendering">Rendering</h1>

				</div>
			</template>

			<template name="requests-and-responses">
				<div exportgroup="readme">

					<h1 id="http-requests-and-responses">HTTP Requests and Responses</h1>
<p>Routes in Webflo can be designed for different types of requests and responses.</p>
<h2 id="api-calls-and-page-requests">API Calls and Page Requests</h2>
<p>HTTP requests are capable of specifying (using the <code>Accept</code> header) in which format a response should be returned by the server. Webflo makes it possible to use this medium to access the <em>data component</em> of a route differently from its <em>HTML component</em>. Routes in Webflo are therefore designed to treat data as a standalone component from HTML, enabling reusability for both.</p>
<p>A route handler would simply concern itself with data.</p>
<pre><code class="hljs js language-js">webflo-app
  ├⏤server
     ├⏤index.js
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
            <span class="hljs-keyword">if</span> (next.stepname) {
                <span class="hljs-keyword">return</span> next();
            }
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
        }</code></pre>
<p>The data returned would be returned as-is - a JSON response - where the <code>Accept</code> header of the request  does not match <code>text/html</code> but matches <code>application/json</code>. This would be taken as an <em>API call</em>. The response header is automatically given <code>Content-Type: 'application/json'</code>.</p>
<p>For API endpoints, the above would be everything for the request and response flow. For routes that will deliver a rendered HTML response, the HTML to render would be a standalone file in the <code>/public</code> directory.</p>
<pre><code class="hljs html language-html">webflo-app
  ├⏤public
    ├⏤index.html <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Webflo knows to find a <code>/public/index.html</code> file for <a href="/tooling/webflo/docs/fundamentals/rendering">rendering</a> the data returned by <code>/server/index.js</code>. Nested routes are given the choice to either have their own <code>index.html</code> file at the corresponding location in the <code>/public</code> directory or inherit the closest one up in their ancestrial line.</p>
<p>A rendered HTML page is therefore returned where the <code>Accept</code> header of the request matches <code>text/html</code> (as a web browser would normally have it for page navigation). This would be taken as a <em>page request</em>. The response header is automatically given <code>Content-Type: 'text/html'</code>.</p>
<p>The general rule for this content negotiation therefore becomes: a rendered HTML response for <em>page requests</em> (<code>Accept</code> header matching <code>text/html</code>), and a JSON response for API calls (<code>Accept</code> header not matching <code>text/html</code> but matching <code>application/json</code>).</p>
<blockquote>
  <p>An automatic <code>Accept: application/json</code> header - <a href="#automatic-headers">just ahead</a> - can always be used on API-only endpoints to tell Webflo to always return a JSON response.</p>
</blockquote>
<p>As for the static <code>index.html</code> file in the <code>/public</code> directory, being in the <code>/public</code> directory means that a direct access would still be possible, as it is with all the files in this directory. But route handlers will have a chance to intercept this direct access, where actually necessary.</p>
<pre><code class="hljs js language-js">webflo-app
  ├⏤server
  │  ├⏤index.js
  │     <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
  │         <span class="hljs-keyword">if</span> (next.stepname &amp;&amp; next.stepname !== <span class="hljs-string">&#x27;index.html&#x27;</span>) {
  │             <span class="hljs-keyword">return</span> next();
  │         }
  │         <span class="hljs-comment">// Both URLs &quot;/&quot; and &quot;/index.html&quot; will lead here </span>
  │         <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
  │     }
  ├⏤public
    │  <span class="hljs-comment">// No more direct access to this file</span>
    ├⏤index.html &lt;html&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>&lt;/html&gt;</code></pre>
<p>Overall, this approach lets us <em>reuse more</em> and <em>repeat less</em>. A route handler alone gives us data; an <code>index.html</code> file alone gives us static HTML; a combination gives us the choice of either data, static HTML or rendered HTML - in just simple <em>content negotiation</em>.</p>
<p>Now, where a route handler returns a value other than an array or an object, no content negotiation takes place (and no automatic <code>Content-Type</code> header). Webflo will try to make a string response of the returned value.</p>
<h2 id="other-types-of-responses">Other Types of Responses</h2>
<p>Route handlers may return an instance of the <a href="/tooling/webflo/docs/api/event_Response"><code>event.Response</code></a> class as a response. And Webflo's automatic content negotiation can still take place.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> event.Response({
        <span class="hljs-attr">body</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> },
    });
}</code></pre>
<p>The response data will be available in the <code>.body</code> property of the instance. Parent handlers may test for this type of response object to obtain the actual reponse data.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">let</span> childResponse = <span class="hljs-keyword">await</span> next();
        <span class="hljs-keyword">if</span> (childResponse <span class="hljs-keyword">instanceof</span> event.Response) {
            childResponse = childResponse.body;
            <span class="hljs-keyword">return</span> { ... };
        }
    }
    <span class="hljs-keyword">return</span> { ... };
}</code></pre>
<p>HTTP status codes and headers may be returned with the instance via the <code>status</code> and <code>headers</code> fields respectively.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> event.Response({
    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> },
    <span class="hljs-attr">body</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> },
});</code></pre>
<p>The <code>Content-Type</code> header is a special header that will mark the response as final; no automatic content negotiation will take place. This is also the case with the <code>Location</code> header, used to initiate a redirect.</p>
<p><a href="/tooling/webflo/docs/api/event_Response#header-shortcuts">Header Shortcuts</a> may also be used to more conveniently set and access common headers.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">new</span> event.Response({
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;some value&#x27;</span> },
    <span class="hljs-attr">body</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// JSON Boolean value</span>
});
response.contentType = <span class="hljs-string">&#x27;application/json&#x27;</span>;
response.cacheControl = <span class="hljs-string">&#x27;no-store&#x27;</span>;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(response.headers);
<span class="hljs-comment">// { &#x27;X-Custom-Header&#x27;: &#x27;some value&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;Cache-Control&#x27;: &#x27;no-store&#x27; }</span>
<span class="hljs-built_in">console</span>.log(response.contentType);
<span class="hljs-comment">// &#x27;application/json&#x27;</span>
<span class="hljs-built_in">console</span>.log(response.cacheControl);
<span class="hljs-comment">// &#x27;no-store&#x27;</span></code></pre>
<p>And the <code>.setHeader()</code> and <code>.getHeader()</code> methods can always be used to set and access headers in a case-insensitive manner.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(response.getHeader(<span class="hljs-string">&#x27;x-custom-Header&#x27;</span>));
<span class="hljs-comment">// &#x27;some value&#x27;</span></code></pre>
<p>Put together, any type of response can be conveniently returned this way.</p>
<p>Now, where a route handler returns nothing, Webflo will know to return a <code>404</code> HTTP response.</p>
<h2 id="the-request-and-response-cycle">The Request and Response Cycle</h2>
<p>HTTP request and response cycles are generally controlled by headers. Webflo offers the easiest way to work with headers.</p>
<h3 id="automatic-headers">Automatic Headers</h3>
<p>Request headers can always be sent by a HTTP client or browser, and <a href="/tooling/webflo/docs/api/event_Response">response headers</a> can always be returned by route handlers. But in Webflo, it is possible to get certain headers automatically added to these requests and responses. These <em>automatic headers</em> are defined on the command line using <a href="/tooling/webflo/docs/cli/config#headers"><code>$ webflo config headers</code></a>.</p>
<p>The underlying JSON config file <code>.webqit/webflo/config/headers.json</code> may be directly edited. Entries go into the <code>entries</code> array field as shown below.</p>
<pre><code class="hljs json language-json">{
    <span class="hljs-attr">&quot;entries&quot;</span>: [
        {
            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-comment">// Or &quot;response&quot;</span>
            <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;/api/v1&quot;</span>, <span class="hljs-comment">// Or a glob pattern</span>
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-comment">// Or any other header</span>
            <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>
        }
    ]
}</code></pre>
<p><strong>Fields</strong></p>
<ul>
<li><p><strong><code>type: String</code></strong> - The header type. This can be one of two values: <code>request</code> for request headers, <code>response</code> for response headers.</p></li>
<li><p><strong><code>url: String</code></strong> - The URL on which the header takes effect. This can be a glob pattern. For example, the value <code>*</code> would mean <em>any URL</em>, and the value <code>*.js</code> would mean <em>any URL ending as <code>.js</code></em>, and so on. <em>(See the <a href="https://www.npmjs.com/package/micromatch">Micromatch</a> documentation for a detailed glob syntax.)</em></p></li>
<li><p><strong><code>name: String</code></strong> - The header name. This can take a convention that gets the header either appended or prepended to any existing declaration in the target headers list: the prefix <code>+</code> to append; the suffix <code>+</code> to prepend.</p>
<p>In the example above, the name <code>Accept</code> would set the value <code>application/json</code> as the <code>Accept</code> header of the incoming request; but <code>+Accept</code> would get it rather appended to any existing <code>Accept</code> header, and <code>Accept+</code> would get it prepended.</p></li>
<li><p><strong><code>value: String</code></strong> - The header value.</p></li>
</ul>
<h3 id="automatic-redirects">Automatic Redirects</h3>
<p>A <em><a href="/tooling/webflo/docs/api/event_Response#redirect">redirect response header</a></em> can always be returned by route handlers. But in Webflo, it is possible to get certain URLs automatically redirected as the requests enter the application. <em>Automatic redirects</em> are defined on the command line using <a href="/tooling/webflo/docs/cli/config#redirects"><code>$ webflo config redirects</code></a>.</p>
<p>The underlying JSON config file <code>.webqit/webflo/config/redirects.json</code> may be directly edited. Entries go into the <code>entries</code> array field as shown below.</p>
<pre><code class="hljs json language-json">{
    <span class="hljs-attr">&quot;entries&quot;</span>: [
        {
            <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-string">&quot;/old-url&quot;</span>, <span class="hljs-comment">// Or a glob pattern</span>
            <span class="hljs-attr">&quot;to&quot;</span>: <span class="hljs-string">&quot;/api/v1&quot;</span>,
            <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;302&quot;</span> <span class="hljs-comment">// 301 by default</span>
        }
    ]
}</code></pre>
<p><strong>Fields</strong></p>
<ul>
<li><p><strong><code>from: String</code></strong> - The URL on which the redirect takes effect. This can be a glob pattern. For example, the value <code>*</code> would mean <em>any URL</em>, and the value <code>*.js</code> would mean <em>any URL ending as <code>.js</code></em>, and so on. <em>(See the <a href="https://www.npmjs.com/package/micromatch">Micromatch</a> documentation for a detailed glob syntax.)</em></p></li>
<li><p><strong><code>to: String</code></strong> - The destination URL. Where the <code>from</code> URL is a glob pattern that matches only the begining part of an incoming request URL, the final destination URL will be the <code>to</code> URL plus the rest of the incoming request URL.</p>
<p>For example, if the <code>from</code> URL is <code>/old-url*</code> and the <code>to</code> URL is <code>/new-url</code>, and the incoming request URL is <code>/old-url/page</code>, the final destination URL will be <code>/new-url/page</code>.</p></li>
<li><p><strong><code>reuseQuery: Boolean</code></strong> - A flag that specifies whether to reuse the query parameters from the incoming request URL in the destination URL. Default is false.</p>
<p>For example, if the incoming request URL is <code>/old-url/page?q=search-word</code>, the final destination URL will be <code>/new-url/page?q=search-word</code>.</p></li>
<li><p><strong><code>code: Number</code></strong> - The redirect code. This can be one of two values: <code>301</code> for a permanent redirect - the default, <code>302</code> for a temporary redirect.</p></li>
</ul>
<blockquote>
  <p>Webflo also supports HTTPS redirects and <code>www</code> subdomain redirect. See <a href="/tooling/webflo/docs/cli/config#server"><code>$ webflo config server</code></a> for details.</p>
</blockquote>

				</div>
			</template>

			<template name="routing">
				<div exportgroup="readme">

					<h1 id="routing">Routing</h1>
<p>In Webflo, routing is filesystem-based. Here, we simply create a file on the filesystem to automatically become available as an URL.</p>
<p>The application's root URL <code>/</code>, for example, would be implemented by creating an <em>index file</em> - <code>&lt;indexFile&gt;</code> - in a chosen <em>routing directory</em> - <code>&lt;routingDirectory&gt;</code>.</p>
<pre><code class="hljs text language-text">&lt;routingDirectory&gt;
  ├⏤&lt;indexFile&gt;</code></pre>
<p>Nested URLs like <code>/shop</code> would be implemented by creating the equivalent directory structure <code>/&lt;routingDirectory&gt;/shop/&lt;indexFile&gt;</code>.</p>
<pre><code class="hljs text language-text">&lt;routingDirectory&gt;
  ├⏤shop
  │  ├⏤&lt;indexFile&gt;
  ├⏤&lt;indexFile&gt;</code></pre>
<p>The actual name for <code>&lt;routingDirectory&gt;</code> and <code>&lt;indexFile&gt;</code> will depend on the URL-handling facilities for the URL.</p>
<h3 id="url-handling-facilities">URL-Handling Facilities</h3>
<p>Depending on the type of application, a given URL can be internally handled either statically or dynamically. Webflo lets us define an application's URL-handling facilities in dedicated directories.</p>
<ul>
<li><strong><code>/public</code></strong> - for static files serving</li>
<li><strong><code>/server</code></strong> - for server-side routing</li>
<li><strong><code>/client</code></strong> - for client-side routing</li>
<li><strong><code>/worker</code></strong> - for worker-level routing</li>
</ul>
<h4 id="the-public-directory">The <code>/public</code> Directory</h4>
<p>This is where static files (like images or CSS files) are placed to be served automatically. <em>(Implement this directory for an application that serves static content.)</em></p>
<p>The application's homepage <code>/index.html</code>, for example, can be served statically by simply placing an <code>index.html</code> file in the <code>/public</code> directory.</p>
<pre><code class="hljs html language-html">public
  ├⏤index.html  -  <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Home | Co<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<blockquote>
  <p>Webflo automatically finds the <code>index.html</code> file where a path URL <code>/</code> is given.</p>
</blockquote>
<h4 id="the-server-directory">The <code>/server</code> Directory</h4>
<p>This is where JavaScript files for server-side routing are placed. <em>(Implement this directory for a server-side application, or an isomorphic application, or an API backend.)</em></p>
<p>The application's root URL <code>/</code>, for example, can be handled on the server by simply placing an <code>index.js</code> file in the <code>/server</code> directory.</p>
<pre><code class="hljs js language-js">server
  ├⏤index.js  -  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> } }</code></pre>
<blockquote>
  <p>The data returned by these handlers are either <em>rendered</em> into the correspnding <code>index.html</code> page from the <code>/public</code> directory - <em><a href="#rendering">Server-Side Rendering</a></em>, or returned as a JSON response - <em><a href="#rendering">API Responses</a></em>. The <code>Accept</code> header of the request is used to determine this. (Learn more in <a href="/tooling/webflo/docs/fundamentals/requests-and-responses">Requests and Responses</a>.)</p>
</blockquote>
<h4 id="the-client-directory">The <code>/client</code> Directory</h4>
<p>This is where JavaScript files for client-side routing are placed. <em>(Implement this directory for an application that will deliver a rich client-side experience.)</em></p>
<p>The application's root URL <code>/</code>, for example, can be handled on the client (the browser) by simply placing an <code>index.js</code> file in the <code>/client</code> directory.</p>
<pre><code class="hljs js language-js">client
  ├⏤index.js  -  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> } }</code></pre>
<blockquote>
  <p>The data returned by these handlers are <em>rendered</em> into the already running page in the browser - <em><a href="#rendering">Client-Side Rendering</a></em>.</p>
</blockquote>
<h4 id="the-worker-directory">The <code>/worker</code> Directory</h4>
<p>This is where JavaScript files for service-worker-level routing are placed. <em>(Implement this directory for an application that will deliver powerful offline capabilities.)</em></p>
<p>The application's root URL <code>/</code>, for example, can be handled in the browser's service-worker layer by simply placing an <code>index.js</code> file in the <code>/worker</code> directory.</p>
<pre><code class="hljs js language-js">worker
  ├⏤index.js  -  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> } }</code></pre>
<blockquote>
  <p>The data returned by these handlers are <em>rendered</em> into the already running page in the browser - <em><a href="#rendering">Client-Side Rendering</a></em>. (These handlers will also be able to intercept certain other browser-generated requests that cannot be intercepted by client-level handlers.)</p>
</blockquote>
<h3 id="url-handling-patterns">URL-Handling Patterns</h3>
<p>URL-handling in Webflo is like an assembly line. Route handlers that are related by a given URL are able to communicate to fullfil a request with a dynamically composed response.</p>
<p>Route handlers recieve a <code>next()</code> function that they can call to get a request moving in this assembly line.</p>
<h4 id="flow-through">Flow-Through</h4>
<p>In real life, the equivalent directory structure for nested URLs creates a parent-child relationship. URL handlers are implicitly subject to this relationship.</p>
<pre><code class="hljs text language-text">&lt;routingDirectory&gt;
  ├⏤shop
  │  ├⏤index.js
  ├⏤index.js</code></pre>
<p>Webflo follows an approach that gets a request going from a parent handler to a child handler. This creates a <em>flow-through</em> effect that lets us take advantage of this relationship for new routing capabilities.</p>
<p>A request for the URL <code>/shop</code>, for example, would <em>flow through</em> two route handlers.</p>
<blockquote>
  <p><em><code>file: /server/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">let</span> shop = <span class="hljs-keyword">await</span> next();
        <span class="hljs-keyword">return</span> { ...shop, <span class="hljs-attr">title</span>: shop.title + <span class="hljs-string">&#x27; | Co&#x27;</span>, };
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
}</code></pre>
<blockquote>
  <p><em><code>file: /server/shop/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Shop&#x27;</span>, <span class="hljs-attr">data</span>: ... };
}</code></pre>
<blockquote>
  <p><em><code>file: /server/shop/products/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next();
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Products&#x27;</span>, <span class="hljs-attr">data</span>: [
        ...
    ] };
}</code></pre>
<p>In the first handler, we started by asking <code>next.stepname</code> if the URL has another step ahead. For an URL like <code>/shop</code>, the answer is yes, and the request is exchanged for the child's data (obviously, the ability to intercept both the request going into the child and the response returned).</p>
<p>In the second handler, we again started by asking <code>next.stepname</code> if the URL has another step ahead. This time, the answer is no, and reponse data is returned here for the request.</p>
<p>As the URL <code>/shop</code> terminates on the second handler, an outright call to <code>next()</code> does not get the request to the third handler. Rather, a <em>fall-through</em> effect happens.</p>
<h4 id="fall-through">Fall-Through</h4>
<p>In real life, each of Webflo's routing directories above represents a point between the browser and the server across which a request flows. Put together, they give us the following URL-handling layers in the given order.</p>
<pre><code class="hljs text language-text">/client     ⥮</code></pre>
<pre><code class="hljs text language-text">/worker     ⥮</code></pre>
<pre><code class="hljs text language-text">/server     ⥮</code></pre>
<pre><code class="hljs text language-text">/public     ⥮</code></pre>
<p>Webflo makes it possible to intercept a request in one layer and forward it <em>down</em> to the next layer. For example, a navigation to the root URL <code>/</code> can be intercepted by the client-side handler <code>/client/index.js</code> and forwarded down - to be further intercepted by the server-side handler <code>/server/index.js</code>, where exists. This creates a <em>fall-through</em> effect that lets us combine powerful cross-stack routing capabilities on a single URL.</p>
<p>A request for the root URL <code>/</code>, for example, would <em>fall through</em> on a call to <code>next()</code>.</p>
<blockquote>
  <p><em>file: <code>/client/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">let</span> remoteContent = <span class="hljs-keyword">await</span> next();
    <span class="hljs-keyword">return</span> remoteContent ? remoteContent : { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Offline Home | Co&#x27;</span> };
}</code></pre>
<blockquote>
  <p><em>file: <code>/server/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">let</span> shop = <span class="hljs-keyword">await</span> next();
        <span class="hljs-keyword">return</span> { ...shop, <span class="hljs-attr">title</span>: shop.title + <span class="hljs-string">&#x27; | Co&#x27;</span>, };
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
}</code></pre>
<p>Wholistically, requests fall through layers in the following flow:</p>
<pre><code class="hljs text language-text">-&gt; enter `/client` if exists
    -&gt; call `index.js`; return response here? or continue</code></pre>
<pre><code class="hljs text language-text">-&gt; enter `/worker` if exists
    -&gt; call `index.js`; return response here? or continue</code></pre>
<pre><code class="hljs text language-text">-&gt; enter `/server` if exists
    -&gt; call `index.js`; return response here? or continue</code></pre>
<pre><code class="hljs text language-text">-&gt; enter `/public` if exists; find and return `index.html`</code></pre>
<p>Now, with the <code>/public</code> directory being the last in the stack, a fall-through effect will be especially important for an application that will both implement dynamic routes and serve static content. Static file requests must be forwarded in order to reach the <code>/public</code> directory.</p>
<p>The handler below has been designed to ensure that the URL <code>/logo.png</code> and <code>/index.html</code>, and in fact, other URLs that are not exactly terminating on it, can <em>flow through</em> and <em>fall through</em>.</p>
<pre><code class="hljs js language-js">webflo-app
  ├⏤server
  │  ├⏤index.js
  │     <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
  │         <span class="hljs-keyword">if</span> (next.stepname<span class="hljs-comment">/* logo.png or index.html, or other */</span>) {
  │             <span class="hljs-keyword">return</span> next();
  │         }
  │         <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
  │     }
  ├⏤public
    ├⏤index.html
    ├⏤logo.png</code></pre>
<p>The above also demonstrates that the URLs <code>/</code> and <code>/index.html</code> would mean two different things where a route handler exists.</p>
<ul>
<li>While the URL <code>/</code> would be intercepted by the handler, the URL <code>/index.html</code> would be served as a static file.</li>
<li>If the request to <code>/</code> was made with an <code>Accept</code> header that matches <code>text/html</code>, Webflo will know to <em>render</em> the handler's response into the <code>index.html</code> file of the URL and return a rendered HTML response. Otherwise, Webflo will know to return the handler's response as-is - a JSON response. This is detailed in <a href="/tooling/webflo/docs/fundamentals/requests-and-responses">Requests and Responses</a>,</li>
</ul>
<h2 id="route-handlers">Route Handlers</h2>
<p>Route handlers are simple <em>export</em> functions that are designed to intercept a request and return a response. Webflo sticks with one way to define route handlers across all routing layers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
}</code></pre>
<p>The syntax also supports naming a handler after a specific HTTP method, where that level of modularity is needed.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">event, app, next</span>) </span>{
}</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">event, app, next</span>) </span>{
}</code></pre>
<p><em>The default handler will always be called where no method-specific handlers exist.</em></p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong><code>event: NavigationEvent</code></strong> - A <a href="/tooling/webflo/docs/fundamentals/requests-and-responses#class-navigationevent-"><code>NavigationEvent</code></a> instance fired for the request.</p></li>
<li><p><strong><code>app: Any</code></strong> - Any incoming value being passed by a parent handler. <em>(See <a href="#parameter-passing">Parameter Passing</a> below.)</em></p></li>
<li><p><strong><code>next: Function</code></strong> - The function to call to forward a request.</p>
<p><strong>Syntax</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> next([app[, pathname]]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><strong><code>app: Any</code></strong> - An optional value to pass to child handler. <em>(See <a href="#parameter-passing">Parameter Passing</a> below.)</em></li>
<li><strong><code>pathname: String</code></strong> - An optional pathname specifying the direction of the flow. <em>(See <a href="#route-bending">Route Bending</a> below.)</em></li></ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>response: Promise&lt;Object|event.Response&gt;</code></strong> - A promise that resolves to the return value from child handler. <em>(Handler return values just ahead.)</em></li></ul></li>
</ul>
<p><strong>Contextual Parameters</strong></p>
<ul>
<li><strong><code>this.stepname: String</code></strong> - The exact name of the current step in the URL path.</li>
<li><strong><code>this.pathname: String</code></strong> - The pathname to the current step in the URL path.</li>
<li><strong><code>this.dirname: String</code></strong> - (Available only in server-side handlers.) The file name of the current handler.</li>
<li><strong><code>this.env: Object</code></strong> - (Available only in server-side handlers.) Any environmental variables defined in an <code>.env</code> file at project root.</li>
<li><strong><code>this.layout: Object</code></strong> - (Available only in server-side handlers.) An object that exposes the filesystem layout of the project as configured via <code>$ webflo config layout</code>.</li>
<li><strong><code>next.stepname: String</code></strong> - The exact name of the next step in the URL path.</li>
<li><strong><code>next.pathname: String</code></strong> - The pathname for the rest of the steps in the URL path.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><strong><code>Object|Array</code></strong> - A plain JavaScript object or array (JSON-stringifiable) may be returned and will translate to the <em>reponse data</em> (stringified JSON) where the request is an <a href="/tooling/webflo/docs/fundamentals/requests-and-responses#api-calls-and-page-requests">API Call</a>, or the <em>rendering data</em> where the request is a <a href="/tooling/webflo/docs/fundamentals/requests-and-responses#api-calls-and-page-requests">Page Request</a>. (For example: <code>return { title: 'Home | Co' }</code>).</li>
<li><strong><code>&lt;falsey&gt;</code></strong> - A falsey value, e.g.  <code>undefined</code>, <code>null</code>, <code>0</code>, etc, will translate to a <code>404 - Not Found</code> HTTP response. (For example: <code>return</code>).</li>
<li><strong><code>event.Response</code></strong> - An instance of <a href="/tooling/webflo/docs/fundamentals/requests-and-responses#class-event-response-"><code>event.Response</code></a> with a <code>.body</code> property being any of the above may be returned. (For example: <code>return new event.Response({ body: { title: 'Home | Co' }, headers: {...} })</code>).</li>
<li><strong><code>Promise</code></strong> - A promise that resolves to any of the above may be returned. (Route handlers can thus be an <code>async</code> function.)</li>
</ul>
<h3 id="parameter-passing">Parameter Passing</h3>
<p>While being used to forward a request, the <code>next()</code> function can help to pass on anything to the next handler.</p>
<blockquote>
  <p><em>file: <code>/server/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next({ <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> });
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Home | Co&#x27;</span> };
}</code></pre>
<blockquote>
  <p><em>file: <code>/server/shop/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">if</span> (next.stepname) {
        <span class="hljs-keyword">return</span> next(app);
    }
    <span class="hljs-keyword">if</span> (app.userId) {
        <span class="hljs-comment">// Show recommended products</span>
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Shop Plus Recomendations&#x27;</span>, };
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Shop&#x27;</span>, };
}</code></pre>
<p>In the first handler, we passed an object with the <code>next()</code> function. In the second handler, we received it on the <code>app</code> parameter. (The <code>app</code> parameter is always empty for root URL handlers.)</p>
<blockquote>
  <p>Parameter passing is a great way to implement one source of truth for subsequent handlers in the route hierarchy. Think authentication states, certain database or external API tokens, etc.</p>
</blockquote>
<h3 id="route-bending">Route Bending</h3>
<p>While a call to <code>next()</code> automatically takes the request to the next handler in line for the URL, a redirect to an adjacent handler can be made. The <code>next()</code> function accepts a second parameter that specifies in which direction to go.</p>
<blockquote>
  <p><em>file: <code>/server/docs/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-comment">// Serve the highest version of the docs for /latest</span>
    <span class="hljs-keyword">if</span> (next.stepname === <span class="hljs-string">&#x27;latest&#x27;</span>) {
        <span class="hljs-keyword">return</span> next(app, next.pathname.replace(<span class="hljs-string">&#x27;latest&#x27;</span>, <span class="hljs-string">&#x27;v2&#x27;</span>));
    }
    <span class="hljs-keyword">return</span> next(app);
}</code></pre>
<blockquote>
  <p><em>file: <code>/server/docs/v2/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Docs: V2&#x27;</span>, };
}</code></pre>
<blockquote>
  <p><em>file: <code>/server/docs/v1/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Docs: V1&#x27;</span>, };
}</code></pre>
<h3 id="wildcard-steps">Wildcard Steps</h3>
<p>A handler can be designed for a step that is dynamically resolved from the request URL. This generic point in the layout is called a <em>wildcard step</em>. Wildcard steps are always a hyphen <code>-</code>. (Notice the <code>-</code> hyphen in the directory below.)</p>
<pre><code class="hljs text language-text">&lt;routingDirectory&gt;
  ├⏤docs
  │  ├⏤-
  │  │  ├⏤index.js
  │  ├⏤index.js
  ├⏤index.js</code></pre>
<p>Above, the handler at <code>/server/docs/-/index.js</code> will be called for all matching URLs - like <code>/docs/v1</code>, <code>/docs/v2/getting-started/overview</code>, etc.</p>
<blockquote>
  <p><em>file: <code>/server/docs/-/index.js</code></em></p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, app, next</span>) </span>{
    <span class="hljs-comment">// The resolved stepname from the request URL will be available as this.stepname</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.stepname); <span class="hljs-comment">// v2</span>
    <span class="hljs-built_in">console</span>.log(next.stepname); <span class="hljs-comment">// getting-started</span>
    <span class="hljs-built_in">console</span>.log(next.pathname); <span class="hljs-comment">// getting-started/overview</span>
}</code></pre>

				</div>
			</template>

			<template name="templating">
				<div exportgroup="readme">

					<h1 id="templating">Templating</h1>

				</div>
			</template>
		</template>

		<template name="getting-started">
			<div exportgroup="readme">

				<h1 id="getting-started">Getting Started</h1>

			</div>

			<template name="installation">
				<div exportgroup="readme">

					<h1 id="installation">Installation</h1>
<p>Every Webflo project starts on an empty directory that you can create on your machine. The command below will make a new directory <code>webflo-app</code> from the terminal and navigate into it.</p>
<pre><code class="hljs bash language-bash">mkdir webflo-app
<span class="hljs-built_in">cd</span> webflo-app</code></pre>
<p>With <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">npm available on your terminal</a>, the following command will install Webflo to your project:</p>
<blockquote>
  <p>System Requirements: Node.js 12.0 or later</p>
</blockquote>
<pre><code class="hljs text language-text">$ npm i @webqit/webflo</code></pre>
<p>The installation automatically creates a <code>package.json</code> file at project root, containing <code>@webqit/webflo</code> as a project dependency.</p>
<pre><code class="hljs json language-json">{
  <span class="hljs-attr">&quot;dependencies&quot;</span>: {
    <span class="hljs-attr">&quot;@webqit/webflo&quot;</span>: &lt;webflo version&gt;
  }
}</code></pre>
<p>Other important definitions like project name, package type, and aliases for common Webflo commands will also belong in this file.</p>
<pre><code class="hljs json language-json">{
  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;webflo-app&quot;</span>,
  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span>,
  <span class="hljs-attr">&quot;scripts&quot;</span>: {
    <span class="hljs-attr">&quot;start:dev&quot;</span>: <span class="hljs-string">&quot;webflo start --dev&quot;</span>,
    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webflo build&quot;</span>
  },
  <span class="hljs-attr">&quot;dependencies&quot;</span>: {
    <span class="hljs-attr">&quot;@webqit/webflo&quot;</span>: &lt;webflo version&gt;
  }
}</code></pre>
<p>All is now set! The commands <a href="/tooling/webflo/docs/cli/start"><code>npm run start:dev</code></a> and <a href="/tooling/webflo/docs/cli/build"><code>npm run build</code></a> will be coming in often during the development process.</p>
<p>Other Webflo commands will also be used at some point. For these, we will be prefixing the command to run with <code>npx</code>; e.g. <code>npx webflo help</code>.</p>
<blockquote>
  <p>A global installation of Webflo wouldn't require aliases in <code>package.json</code> or the <code>npx</code> prefix to run. To install Webflo globally, run <code>npm install</code> with the <code>-g</code> (or <code>--global</code>) flag: <code>npm i -g @webqit/webflo</code>.</p>
</blockquote>
<p>To be sure Webflo is listening, run <a href="/tooling/webflo/docs/cli/help"><code>npx webflo help</code></a>; an overview of available commands will be shown.</p>
<h2 id="hello-webflo">"Hello Webflo!"</h2>
<p>The start page of our sample app could be a simple <code>index.html</code> file served statically. This would go into the <code>/public</code> directory of the app. (More about project layout in <a href="/tooling/webflo/docs/fundamentals/routing">Routing</a>.)</p>
<ul>
<li><code>/public</code><ul>
<li><code>/index.html</code> - <code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hello Webflo!&lt;/body&gt;&lt;/html&gt;</code></li></ul></li>
</ul>
<p>Now, when you start the Webflo server and navigate to <code>http://localhost:3000/</code> (or <code>http://localhost:3000/index.html</code>) on your browser, the start page is shown.</p>
<pre><code class="hljs bash language-bash">$ npm run start:dev</code></pre>
<blockquote>
  <p>Be sure to give Webflo a better "Hello!" with a more beautiful start page.</p>
</blockquote>
<h2 id="common-setup">Common Setup</h2>
<p>As with every project that might be heading outside its local development environment, certain files, folders or parameters for Webflo applications may need to be excluded from upstream repositories. And it is good to remember these <em>environmental factors</em>  early.</p>
<h3 id="the-env-file">The <code>.env</code> File</h3>
<p>An <code>.env</code> file is commonly used to maintain environment-specific varaiables for an application. Consider using this file to keep any sensitive values that your application might need, e.g. database credentials. This file would be kept local using the <code>.gitignore</code> file below. The <em>ignore rule</em> would be: <code>.env</code>.</p>
<p>Consider paring the <code>.env</code> file with an <code>.env.example</code> file - written with no actual values, and for simply providing an example of what might be in the <code>.env</code> file. This file would be what goes to other deployment environments.</p>
<p>To edit the <code>.env</code> file from the command line, run <a href="/tooling/webflo/docs/cli/config#variables"><code>$ webflo config variables</code></a>. Add the flag <code>--env=example</code> to explicitly edit the <code>.env.example</code> file.</p>
<p>When creating the <code>.env</code> file for the first time, Webflo will try to guide you using the variable names and available example values in the <code>.env.example</code> file, where exists.</p>
<h3 id="the-webqit-directory">The <code>.webqit</code> Directory</h3>
<p>All WebQit command-line interfaces maintain certain command-line edits in the WebQit-specific folder: <code>.webqit</code>. Webflo's own edits go into the <code>./.webqit/webflo</code> directory; and these files are to be kept local using the <code>.gitignore</code> file below. The <em>ignore rule</em> would be: <code>.webqit</code>.</p>
<p>The <code>--env=example</code> flag may be used to create <em>example copies</em> of these configurations - written with no actual values, and for simply providing an example of what might be in the actual configuration. Edits made with <code>$ webflo config variables --env=example</code>, for example, will be written to the file: <code>./.webqit/webflo/variables.example.json</code>. These <em>example copies</em> are what goes to other deployment environments. The <em>allow rule</em> would be: <code>!.webqit/**.example.json</code>.</p>
<h3 id="the-gitignorefile">The <code>.gitignore</code>File</h3>
<p>This file should now be part of your project. And an important folder to ignore is the <code>node_modules</code> folder. Together with the environment-specific files above, your <code>.gitignore</code> file could be looking similar to the below:</p>
<pre><code class="hljs text language-text">node_modules
.env
.webqit
!.webqit/**.example.json</code></pre>
<p><em>Feel free to add more rules as needed.</em></p>
<h2 id="next-steps">Next Steps</h2>
<p>Continue to <a href="/tooling/webflo/docs/fundamentals">learning the fundamentals</a>.</p>

				</div>
			</template>

			<template name="overview">
				<div exportgroup="readme">

					<h1 id="overview">Overview</h1>
<p>Webflo is the universal JavaScript framework for Web, Mobile, and API Backends, and the single tool that takes you from development, to deployment, to continous delivery. The Webflo experience is: <em>all of the possibilities</em> delivered in a <em>long-story-short approach</em>!</p>
<p>Take an overview!</p>
<h2 id="starting">Starting</h2>
<p>Every Webflo project starts on an empty directory that you can create on your machine. We are creating one below - named <code>webflo-app</code> - and navigating into it on the terminal.</p>
<pre><code class="hljs bash language-bash">mkdir webflo-app
<span class="hljs-built_in">cd</span> webflo-app</code></pre>
<p>Next is to have Webflo installed, following the <a href="/tooling/webflo/docs/getting-started/installation">installation guide</a>. This makes the <code>webflo</code> command available on the terminal. And that is all the setup required!</p>
<blockquote>
  <p>Webflo does not need to be imported and instantiated. In fact, it keeps itself and its files outside of the project folders. This lets everything that is framework-related stay outside of your code. A zero-footprint philosophy gives us a clean slate to think and code.</p>
</blockquote>
<p>Everything from here will be application-specific!</p>
<h2 id="project-layout">Project Layout</h2>
<p>Any project will normally live in files and folders. Webflo lets us follow a layout that just defines the capabilities of the application.</p>
<p>The following directories are used as the application's URL-handling facilities.</p>
<ul>
<li><strong><code>/public</code></strong> - for static files serving</li>
<li><strong><code>/server</code></strong> - for server-side routing</li>
<li><strong><code>/client</code></strong> - for client-side routing</li>
<li><strong><code>/worker</code></strong> - for worker-level routing</li>
</ul>
<p>Any other directory (e.g. <code>/src</code>) may exist here at root level for other purposes.</p>
<h2 id="routing">Routing</h2>
<blockquote>
  <p><strong>Main Topic:</strong> <a href="/tooling/webflo/docs/fundamentals/routing">Routing</a></p>
</blockquote>

				</div>
			</template>
		</template>

		<template name="runtime">
			
		</template>
	</template>

	
